import random

import numpy as np
import pathlib as pl

import graph_jsp_utils.jsp_instance_parser as parser

from graph_jsp_utils.name_generator import generate_name
from graph_jsp_utils.disjunctive_graph_logger import log


def generate_jsp_instance(target_dir: pl.Path, n_jobs: int = 3, n_machines: int = 4,
                          min_processing_time: int = 2, max_processing_time: int = 20) -> (np.array, np.array):
    """
    generates a singe jsp instance and saves it in Taillard-specification (http://jobshop.jjvh.nl/explanation.php)
    and saves it in a subdirectory (according to the size of the jsp) in the custom instance folder.
    See `jss_utils.PATHS`

    the order of the machines for the jobs and the duration of the task within a job are chosen randomly.

    the name is generated by the `jss_util.name_generator.generate_name`-fuction.

    :param n_jobs:              number of jobs
    :param n_machines:          number of machines
    :param min_processing_time: minimal duration of a task within a job
    :param max_processing_time: maximal duration of a task within a job

    :return:                    jsp as numpy array, Taillard style jsp numpy array

    """
    log.info(f"generating jsp instance of size ({n_jobs}, {n_machines}) (#jobs, #machines).")
    machine_order = [
        random.sample(list(range(1, n_machines + 1)), n_machines) for _ in range(n_jobs)
    ]
    processing_times = [
        [random.randint(min_processing_time, max_processing_time) for m in range(n_machines)] for _ in range(n_jobs)
    ]

    name = generate_name()

    save_dir = target_dir.joinpath(f"{n_jobs}x{n_machines}")
    save_dir.mkdir(exist_ok=True, parents=True)

    save_file = save_dir.joinpath(f"{name}.txt")

    log.info(f"saving instance as .txt-file ({save_file})")
    with open(save_file, "w") as txt_file:

        txt_file.write(f"{n_jobs}\t{n_machines}\n")

        for job_pts in processing_times:
            job_pts = [str(e) for e in job_pts]
            txt_file.write("\t".join(job_pts) + "\n")

        for job_machines in machine_order:
            job_machines = [str(e) for e in job_machines]
            txt_file.write("\t".join(job_machines) + "\n")

    jsp_np_array, taillard_matrix = parser.parse_jps_taillard_specification(save_file)

    specified_jsp = np.array([*processing_times, *machine_order])

    assert np.array_equal(specified_jsp, taillard_matrix)

    return jsp_np_array, taillard_matrix


def generate_jsp_instances(target_dir: pl.Path, n_instances: int = 100, n_jobs: int = 3, n_machines: int = 3,
                           min_processing_time: int = 2, max_processing_time: int = 20) -> None:
    """
    Wrapper for the `jss_utils.jsp_custom_instance_generator.generate_jsp_instance` function.

    Generates `n_instances` instances and updates the corresponding details file.

    :param n_jobs:                  number of jobs
    :param n_machines:              number of machines
    :param min_processing_time:     minimal duration of a task within a job
    :param max_processing_time:     maximal duration of a task within a job

    :return:                        None

    """
    for _ in range(n_instances):
        generate_jsp_instance(
            target_dir=target_dir,
            n_jobs=n_jobs,
            n_machines=n_machines,
            max_processing_time=max_processing_time,
            min_processing_time=min_processing_time
        )


if __name__ == '__main__':
    import os

    target_path = pl.Path(os.path.abspath(__file__)).parent.parent.parent\
        .joinpath("resources")\
        .joinpath("jsp_instances")\
        .joinpath("custom")

    generate_jsp_instances(
        target_dir=target_path,
        n_instances=100,
        n_jobs=6,
        n_machines=6
    )
