from __future__ import annotations

import inspect
from enum import EnumMeta
from typing import Any, Dict, List, Optional, Tuple, Type, Union

import numpy as np
import pyfields
from pandas import DataFrame, Index
from pyfields import copy_value
from pyfields.core import DescriptorField, Symbols

from optool.logging import LOGGER
from optool.types import Quantity, RobustEnum


def autocomplete(cls: Optional[Type[Any]] = None,
                 /,
                 *,
                 make_init: bool = True,
                 make_hash: bool = True,
                 make_eq: bool = True,
                 make_str: bool = True,
                 make_repr: bool = True):
    """
    A decorator to conveniently add functions to a class.

    The implementation is heavily inspired by `pyfields.autoclass
    <https://smarie.github.io/python-pyfields/api_reference/#autoclass>`_.

    Args:
        make_init (bool): generates the constructor based on all fields present, using
            `pyfields.make_init <https://smarie.github.io/python-pyfields/api_reference/#make_init>`_.
        make_hash (bool): generates an `__hash__` method, so that instances can be inserted in sets or dict keys.
        make_eq (bool): generates an `__eq__` method, so that instances can be compared to other instances.
        make_str (bool): generates an `__str__` method, so that instances can be printed in human-readable form.
        make_repr (bool): generates an `__repr__` method, so that instances can be printed in human-readable form.

    Returns: a decorator for classes
    """

    # noinspection PyShadowingNames
    def wrap(cls):
        return _make_class_complete(cls, make_init, make_hash, make_eq, make_str, make_repr)

    # See if we're being called with or without parentheses
    if cls is None:
        # We're called with parentheses
        return wrap

    # We're called without parentheses
    return wrap(cls)


def _get_attributes(obj) -> Dict[str, Any]:
    cls_dict = type(obj).__dict__
    if '__slots__' not in cls_dict:
        raise ValueError(f"The class {type(obj).__name__} does not have slots. Please add them.")
    cls_slots = _as_tuple(cls_dict['__slots__'])
    try:
        field_values = pyfields.get_field_values(obj)
    except Exception as e:
        raise AttributeError(f"Cannot get attributes of {obj.__class__.__name__} at this point.") from e
    all_instance_attr_names = [(v.lstrip('_') if v.lstrip('_') in field_values else v) for v in cls_slots]
    return {name: getattr(obj, name) for name in all_instance_attr_names}


def _is_equal(this, that) -> bool:
    if isinstance(this, (DataFrame, Index)) and isinstance(that, (DataFrame, Index)):
        return this.equals(that)
    if isinstance(this, Quantity) and isinstance(that, Quantity):
        return this.is_compatible_with(that.units) and _is_equal(this.magnitude, that.m_as(this.units))
    if type(this) is not type(that):
        return False
    if isinstance(this, np.ndarray):
        return np.array_equal(this, that, equal_nan=True)

    try:
        return this == that
    except Exception as e:
        raise ValueError(f"Cannot compare {this} to {that}.") from e


# Create the decorator function
def _make_class_complete(cls, make_init, make_hash, make_eq, make_str, make_repr):
    _check_class_declaration(cls)

    # make init if not already explicitly present
    if make_init and "__init__" not in cls.__dict__:
        new_init = pyfields.make_init()
        cls.__init__ = new_init
        # attach explicitly to the class so that the descriptor is correctly completed.
        # noinspection PyUnresolvedReferences
        new_init.__set_name__(cls, '__init__')

    # __str__ and __repr__
    def to_string(self):
        """
        Generated by :py:func:`~optool.util.decorators.autocomplete` based on the class attributes.
        """
        public_values = [f"{k}={v}" for (k, v) in _get_attributes(self).items() if not k.startswith('_')]
        return f"{self.__class__.__name__}({', '.join(public_values)})"

    if make_str:
        if "__str__" not in cls.__dict__:
            cls.__str__ = to_string

    if make_repr:
        if "__repr__" not in cls.__dict__:
            cls.__repr__ = to_string

    # __eq__
    if make_eq:

        def __eq__(self, other):
            """
            Generated by :py:func:`~optool.util.decorators.autocomplete` based on the class attributes.
            """

            if isinstance(self, other.__class__):
                # comparison with objects of the same class or a parent
                this_attrs = _get_attributes(self)
                that_attrs = _get_attributes(other)

                if set(this_attrs.keys()) != set(that_attrs.keys()):
                    return False
                attribute_pairs = [(this_attrs[k], that_attrs[k]) for k in this_attrs]
                return all(_is_equal(this_value, that_value) for (this_value, that_value) in attribute_pairs)

            elif isinstance(other, self.__class__):
                # other is a subtype: call method on other
                return other.__eq__(self)  # same as NotImplemented ?
            else:
                # classes are not related: False
                return False

        if "__eq__" not in cls.__dict__:
            cls.__eq__ = __eq__

    # __hash__
    if make_hash:

        def __hash__(self):
            """
            Generated by :py:func:`~optool.util.decorators.autocomplete`.

            Implements the __hash__ method by hashing a tuple of the type and a list of the attribute values.
            """
            return hash(tuple([type(self)] + list(_get_attributes(self).values())))

        if "__hash__" not in cls.__dict__:
            cls.__hash__ = __hash__

    return cls


def _is_class_attribute(name: str, value) -> bool:
    return name == name.upper() or isinstance(value, EnumMeta)


def _is_function_or_method(val):
    return inspect.isfunction(val) or isinstance(val, (staticmethod, classmethod))


def _as_tuple(value: Union[tuple, str, list]) -> tuple:
    if isinstance(value, tuple):
        return value
    if isinstance(value, list):
        return tuple(value)
    if isinstance(value, str):
        return value,
    raise TypeError(f"The type of the input is {type(value).__name__}, which is not supported.")


def _check_class_declaration(cls: Type[Any]):
    cls_dict = cls.__dict__
    has_annotations = '__annotations__' in cls_dict
    has_slots = '__slots__' in cls_dict

    cls_annotations = cls_dict['__annotations__'] if has_annotations else {}
    cls_slots = _as_tuple(cls_dict['__slots__']) if has_slots else ()
    all_attrs = {k: v for k, v in cls_dict.items() if not k.startswith("__")}
    class_attrs = {k: v for (k, v) in all_attrs.items() if _is_class_attribute(k, v)}
    slotted_attrs = {k: v for (k, v) in all_attrs.items() if k in cls_slots}
    method_attrs = {k: v for (k, v) in all_attrs.items() if _is_function_or_method(v)}
    property_attrs = {k: v for (k, v) in all_attrs.items() if isinstance(v, property)}

    misc_attrs = {k: v for (k, v) in all_attrs.items() if k in ['_abc_impl']}

    all_except_instance_attrs = class_attrs | slotted_attrs | method_attrs | property_attrs | misc_attrs
    instance_attrs = dict(tup for tup in all_attrs.items() if tup[0] not in all_except_instance_attrs)

    if any(type(v).__name__ != 'member_descriptor' for v in slotted_attrs.values()):
        raise ValueError(f"Not all elements defined as slots are member descriptors as expected, see: {slotted_attrs}")
    if set(slotted_attrs.keys()) != set(cls_slots):
        raise ValueError(f"The detected slots are not identical, see {set(slotted_attrs.keys())} vs. {set(cls_slots)}")

    LOGGER.debug("Class annotations: {}", cls_annotations)
    LOGGER.debug("All attributes: {}", all_attrs)
    LOGGER.debug("Class attributes: {}", class_attrs)
    LOGGER.debug("Slotted attributes: {}", slotted_attrs)
    LOGGER.debug("Function attributes: {}", method_attrs)
    LOGGER.debug("Property attributes: {}", property_attrs)
    LOGGER.debug("Miscellaneous attributes: {}", misc_attrs)
    LOGGER.debug("Instance attributes: {}", instance_attrs)

    LOGGER.info(
        "The following attributes are found in {}: "
        "class attributes: {}, slots: {}, (remaining) instance attributes: {}", cls.__name__, list(class_attrs.keys()),
        list(slotted_attrs.keys()), list(instance_attrs.keys()))

    if not_field_attrs := {k: v for (k, v) in instance_attrs.items() if not isinstance(v, pyfields.Field)}:
        not_fields_readable = [f"{k}: {type(v).__name__}" for (k, v) in not_field_attrs.items()]
        raise ValueError(f"Not all instant attributes of {cls.__name__} are fields, see: {not_fields_readable}")

    auto_gen_instance_attr_names = [f"_{k}" for k in instance_attrs]
    if has_slots:
        for name in auto_gen_instance_attr_names:
            if name not in cls_slots:
                raise ValueError(f"The instance attribute {name} of class {cls.__name__}, which will be created "
                                 f"automatically as it is declared as field without the leading underscore, is not "
                                 f"contained in the slots, which are currently defined as {cls_slots}.")
    else:
        slots_definition = f"__slots__ = {str(auto_gen_instance_attr_names).strip('[]')}"
        raise ValueError(f"There are no slots defined. "
                         f"Add the following line to the definition of the class {cls.__name__}: {slots_definition}")


class ArrayMutability(RobustEnum):
    """
    Specify if individual entries of Numpy arrays can be changed.

    Numpy arrays are mutable by default, meaning that a value at a certain index can be change without being noticed by
    the validator. However, to ensure consistency they are set to be immutable (not writeable) when assigned to the
    numeric attributes.
    """
    ALWAYS = True
    NEVER = False
    MAYBE_LATER = False
    INHERIT = None

    def __new__(cls, *args):
        value = len(cls.__members__) + 1
        obj = object.__new__(cls)
        obj._value_ = value
        return obj

    def __init__(self, array_is_mutable: Optional[bool], *args):
        super().__init__(*args)
        self._array_is_mutable = array_is_mutable

    def is_mutable(self) -> Optional[bool]:
        return self._array_is_mutable


class Attribute(DescriptorField):
    """
    An instance attribute with additional features.

    The values that are assigned to this attribute are automatically validated using the provided validators and the
    type hint. If a default value is specified, the field is "optional" and does not have to be set during
    initialization. `None` values are allowed if either the default value is `None` or the type hint is
    `typing.Optional[]`.

    Args:
        default: The default value. Providing a `default` makes the field "optional".
        validators: one or multiple validators (See
            `valid8 simple syntax <https://smarie.github.io/python-valid8/validation_funcs/c_simple_syntax/>`_ for
            details, default: None)
        array_mutability (ArrayMutability): specify if the underlying Numpy array is mutable
            (default: :py:const:`~ArrayMutability.INHERIT`)
        read_only (bool): stating if a field can be modified after initial value has been provided. (default: False)

    Example::

    >>> class MyAwesomeClass:
    >>> \"\"\"This is my class.\"\"\"
    >>> name: str = Attribute(validators=non_empty)
    >>> \"\"\"The name of my member attribute.\"\"\"

    See Also: `Pyfields documentation <https://smarie.github.io/python-pyfields/>`_
    """

    def _make_immutable_converter(self):

        # noinspection PyUnusedLocal
        def _array_mutability_converter(obj, val):
            array_typically_is_mutable = self._specified_array_mutability.is_mutable()
            if self._value_is_nd_array(val) and array_typically_is_mutable is not None:
                array_is_mutable = array_typically_is_mutable or id(obj) in self._provisionally_mutable_objects
                self._set_numpy_write_flag(val, array_is_mutable)
            return val

        return _array_mutability_converter

    def __init__(self,
                 default: Optional[Any] = Symbols.EMPTY,
                 validators: Optional[Any] = None,
                 array_mutability: ArrayMutability = ArrayMutability.INHERIT,
                 read_only: bool = False):
        super().__init__(
            check_type=True,
            default=None if default is None else Symbols.EMPTY,  # only None is directly set, and combined with nonable
            nonable=Symbols.GUESS,  # allows var: Optional[Type] = ... and var: Type = Attribute(default=None, ...)
            default_factory=None if default is None or default is Symbols.EMPTY else copy_value(default),  # type:ignore
            validators=validators,
            converters=self._make_immutable_converter(),
            read_only=read_only)
        self.serialize_as: Any = None
        self._specified_array_mutability = array_mutability
        self._provisionally_mutable_objects: List[int] = []

        # Ensure that MyPy thinks name is a string, which it will eventually be!
        self.name: str = self.name

    @classmethod
    def reveal(cls, class_or_obj: Union[Type[Any], Any]) -> Tuple[Attribute]:
        return pyfields.get_fields(class_or_obj)

    def get_value(self, obj) -> Any:
        return getattr(obj, self.name)

    def set_array_mutability(self, obj, mutable: bool):
        value = self.get_value(obj)
        self.check_mutability_change(mutable)
        self._set_numpy_write_flag(value, mutable)
        obj_id = id(obj)
        if mutable and obj_id not in self._provisionally_mutable_objects:
            self._provisionally_mutable_objects.append(obj_id)
        elif not mutable and obj_id in self._provisionally_mutable_objects:
            self._provisionally_mutable_objects.remove(obj_id)

    def check_mutability_change(self, mutable):
        if self._specified_array_mutability != ArrayMutability.MAYBE_LATER:
            raise ValueError(f"Cannot set {mutable=} of attribute named {self.name!r} since the mutability is "
                             f"already defined at construction level to be {self._specified_array_mutability}.")

    @classmethod
    def set_all_arrays_mutability(cls, obj, mutable: bool):
        fields = cls.reveal(obj)
        for field in fields:
            field.check_mutability_change(mutable)
        for field in fields:
            field.set_array_mutability(obj, mutable)

    @classmethod
    def set_arrays_mutability_where_possible(cls, obj, mutable: bool):
        for field in cls.reveal(obj):
            if field._specified_array_mutability == ArrayMutability.MAYBE_LATER:
                field.set_array_mutability(obj, mutable)

    @staticmethod
    def _value_is_nd_array(value: Union[np.ndarray, Quantity]) -> bool:
        return isinstance(value, np.ndarray) or (isinstance(value, Quantity) and isinstance(value.m, np.ndarray))

    @staticmethod
    def _set_numpy_write_flag(value: Union[np.ndarray, Quantity], mutable: bool = True) -> None:
        if isinstance(value, np.ndarray):
            value.setflags(write=mutable)
        elif isinstance(value, Quantity) and isinstance(value.magnitude, np.ndarray):
            value.magnitude.setflags(write=mutable)
        else:
            TypeError(f"Unsupported type {value.__class__.__name__!r}. Either the value is a Numpy ndarray or a "
                      f"Quantity where the magnitude is a Numpy ndarray.")
