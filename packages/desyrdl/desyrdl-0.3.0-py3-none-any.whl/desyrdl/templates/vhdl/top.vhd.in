------------------------------------------------------------------------------
--          ____  _____________  __                                         --
--         / __ \/ ____/ ___/\ \/ /                 _   _   _               --
--        / / / / __/  \__ \  \  /                 / \ / \ / \              --
--       / /_/ / /___ ___/ /  / /               = ( M | S | K )=            --
--      /_____/_____//____/  /_/                   \_/ \_/ \_/              --
--                                                                          --
------------------------------------------------------------------------------
--! @copyright Copyright 2021-2022 DESY
--! SPDX-License-Identifier: Apache-2.0
------------------------------------------------------------------------------
--! @date 2021-04-07
--! @author Michael BÃ¼chler <michael.buechler@desy.de>
--! @author Lukasz Butkowski <lukasz.butkowski@desy.de>
------------------------------------------------------------------------------
--! @brief
--! Top component of DesyRDL address space decoder for {node.type_name}
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library desyrdl;
use desyrdl.common.all;
use desyrdl.pkg_{node.orig_type_name}.all;

-- library desy;
-- use desy.common_axi.all;

entity {node.orig_type_name} is
  port (
    pi_clock : in std_logic;
    pi_reset : in std_logic;
    -- TOP subordinate memory mapped interface
    pi_s_top  : in  t_{node.orig_type_name}_m2s;
    po_s_top  : out t_{node.orig_type_name}_s2m;
    -- pi_s_top_if  : in  t_{desyrdl_interface:lower}_m2s;
    -- po_s_top_if  : out t_{desyrdl_interface:lower}_s2m;
    -- to logic interface
    pi_addrmap : in  t_addrmap_{node.orig_type_name}_in;
    po_addrmap : out t_addrmap_{node.orig_type_name}_out
  );
end entity {node.orig_type_name};

architecture arch of {node.orig_type_name} is

  type t_data_out is array (natural range<>) of std_logic_vector(C_DATA_WIDTH-1 downto 0) ;
  signal reg_data_out_vect : t_data_out({n_regcount}-1 downto 0);

  signal reg_rd_stb   : std_logic_vector({n_regcount}-1 downto 0);
  signal reg_wr_stb   : std_logic_vector({n_regcount}-1 downto 0);
  signal reg_data_out : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal reg_data_in  : std_logic_vector(C_DATA_WIDTH-1 downto 0);

  signal mem_data_out_vect : t_data_out({n_memitems}-1 downto 0);
  signal mem_stb      : std_logic_vector({n_memitems}-1 downto 0);
  signal mem_we       : std_logic;
  signal mem_addr     : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
  signal mem_data_out : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal mem_data_in  : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  signal mem_ack      : std_logic;

  signal ext_if_i     : t_{desyrdl_interface:lower}_s2m_array({n_extitems}-1 downto 0);
  signal ext_if_o     : t_{desyrdl_interface:lower}_m2s_array({n_extitems}-1 downto 0);

begin

  -- Assign the unused array index that is always present, even if the number
  -- of mem or reg items is 0.
  --mem_data_out_vect({n_memitems}) <= (others => '0');

  inst_decoder_axi4l: entity desyrdl.decoder_{desyrdl_interface:lower}
    generic map (
      g_addr_width    => C_ADDR_WIDTH,
      g_data_width    => C_DATA_WIDTH,
      g_register_info => C_REGISTER_INFO,
      g_regitems      => {n_regitems},
      g_regcount      => {n_regcount},
      g_mem_info      => C_MEM_INFO,
      g_memitems      => {n_memitems},
      g_memcount      => {n_memitems},
      g_ext_info      => C_EXT_INFO,
      g_extitems      => {n_extitems},
      g_extcount      => {n_extitems}
    )
    port map (
      pi_clock      => pi_clock,
      pi_reset      => pi_reset,

      po_reg_rd_stb => reg_rd_stb,
      po_reg_wr_stb => reg_wr_stb,
      po_reg_data   => reg_data_in,
      pi_reg_data   => reg_data_out,
      po_mem_stb    => mem_stb,
      po_mem_we     => mem_we,
      po_mem_addr   => mem_addr,
      po_mem_data   => mem_data_in,
      pi_mem_data   => mem_data_out,
      pi_mem_ack    => mem_ack,

      pi_ext      => ext_if_i,
      po_ext      => ext_if_o,

      pi_s_top    => pi_s_top,
      po_s_top    => po_s_top
    );

  prs_reg_rd_mux: process(pi_clock)
  begin
    if rising_edge(pi_clock) then
      for idx in 0 to {n_regcount}-1 loop
        if reg_rd_stb(idx) = '1' then
          reg_data_out <= reg_data_out_vect(idx);
        end if;
      end loop;
    end if;
  end process prs_reg_rd_mux;

  prs_mem_rd_mux: process(pi_clock)
  begin
    if rising_edge(pi_clock) then
      for idx in 0 to {n_memitems}-1 loop
        if mem_stb(idx) = '1' then
          mem_data_out <= mem_data_out_vect(idx);
        end if;
      end loop;
    end if;
  end process prs_mem_rd_mux;
  -- gen_no_mem: if {n_memitems} = 0 generate
  --   mem_data_out <= (others => '0');
  -- end generate;
  -- ===========================================================================
  -- generated registers instances{regitems:repeat:
  -- ---------------------------------------------------------------------------
  -- reg name: {{reg.inst_name}}  reg type: {{reg.type_name}}
  -- ---------------------------------------------------------------------------
  blk_reg_{{i}}_{{name}} : block
  begin  --{{context:if:eq:dim:1:
    inst_{{name}}: entity desyrdl.{node.type_name}_{{reg.type_name}}
      port map(
        pi_clock        => pi_clock,
        pi_reset        => pi_reset,
        -- to/from adapter
        pi_decoder_rd_stb => reg_rd_stb({{index}}),
        pi_decoder_wr_stb => reg_wr_stb({{index}}),
        pi_decoder_data   => reg_data_in,
        po_decoder_data   => reg_data_out_vect({{index}}),

        pi_reg  => pi_addrmap.{{{{reg.inst_name}}}},
        po_reg  => po_addrmap.{{{{reg.inst_name}}}}
      );--}} --{{context:if:eq:dim:2:
    gen_m: for idx_m in 0 to {{dim_m}}-1 generate
      inst_{{name}}: entity desyrdl.{node.type_name}_{{reg.type_name}}
        port map(
          pi_clock        => pi_clock,
          pi_reset        => pi_reset,
          -- to/from adapter
          pi_decoder_rd_stb => reg_rd_stb({{index}}+idx_m),
          pi_decoder_wr_stb => reg_wr_stb({{index}}+idx_m),
          pi_decoder_data   => reg_data_in,
          po_decoder_data   => reg_data_out_vect({{index}}+idx_m),

          pi_reg  => pi_addrmap.{{{{reg.inst_name}}}}(idx_m),
          po_reg  => po_addrmap.{{{{reg.inst_name}}}}(idx_m)
        );
    end generate;--}} --{{context:if:eq:dim:3:
    gen_n : for idx_n in 0 to {{dim_n}}-1 generate  -- outer dim, for 3D arrays
      gen_m: for idx_m in 0 to {{dim_m}}-1 generate -- inner dim, for 2D arrays
        constant l_idx : natural := (idx_n*{{dim_m}} + idx_m) ;
      begin
        inst_{{reg.inst_name}}: entity desyrdl.{node.type_name}_{{reg.type_name}}
          port map(
            pi_clock        => pi_clock,
            pi_reset        => pi_reset,
            -- to/from adapter
            pi_decoder_rd_stb => reg_rd_stb({{index}}+l_idx),
            pi_decoder_wr_stb => reg_wr_stb({{index}}+l_idx),
            pi_decoder_data   => reg_data_in,
            po_decoder_data   => reg_data_out_vect({{index}}+l_idx),

            pi_reg  => pi_addrmap.{{{{reg.inst_name}}}}(idx_n,idx_m),
            po_reg  => po_addrmap.{{{{reg.inst_name}}}}(idx_n,idx_m)
          );
      end generate;
    end generate;--}}
  end block; --}

  -- ===========================================================================
  -- generated regfile instances{regfileitems:repeat:
  -- ---------------------------------------------------------------------------
  -- regfile name: {{regfile.inst_name}}  regfile type: {{regfile.type_name}}
  -- ---------------------------------------------------------------------------
  blk_regfile_{{i}}_{{name}} : block
  begin  --{{context:if:eq:dim:1:
    -- ===========================================================================
    -- generated registers instances{{{{regitems:repeat:
    -- ---------------------------------------------------------------------------
    -- reg name: {{{{{{{{reg.inst_name}}}}}}}}  reg type: {{{{{{{{reg.type_name}}}}}}}}
    -- ---------------------------------------------------------------------------
    blk_{{{{{{{{i}}}}}}}}_{{{{{{{{name}}}}}}}} : block
    begin  --{{{{{{{{context:if:eq:dim:1:
      inst_{{{{{{{{name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
        port map(
          pi_clock        => pi_clock,
          pi_reset        => pi_reset,
          -- to/from adapter
          pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}}),
          pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}}),
          pi_decoder_data   => reg_data_in,
          po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}}),

          pi_reg  => pi_addrmap.{{regfile.inst_name}}.{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}},
          po_reg  => po_addrmap.{{regfile.inst_name}}.{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}
        ); --}}}}}}}} --{{{{{{{{context:if:eq:dim:2:
      gen_m: for inner_idx_m in 0 to {{{{{{{{dim_m}}}}}}}}-1 generate
        inst_{{{{{{{{name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
          port map(
            pi_clock        => pi_clock,
            pi_reset        => pi_reset,
            -- to/from adapter
            pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}}+inner_idx_m),
            pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}}+inner_idx_m),
            pi_decoder_data   => reg_data_in,
            po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}}+inner_idx_m),

            pi_reg  => pi_addrmap.{{regfile.inst_name}}.{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(inner_idx_m),
            po_reg  => po_addrmap.{{regfile.inst_name}}.{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(inner_idx_m)
          );
      end generate; --}}}}}}}} --{{{{{{{{context:if:eq:dim:3:
      gen_n : for inner_idx_n in 0 to {{{{{{{{dim_n}}}}}}}}-1 generate  -- outer dim, for 3D arrays
        gen_m: for inner_idx_m in 0 to {{{{{{{{dim_m}}}}}}}}-1 generate -- inner dim, for 2D arrays
          constant l_idx : natural := (inner_idx_n*{{{{{{{{dim_m}}}}}}}} + inner_idx_m) ;
        begin
          inst_{{{{{{{{reg.inst_name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
            port map(
              pi_clock        => pi_clock,
              pi_reset        => pi_reset,
              -- to/from adapter
              pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}}+l_idx),
              pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}}+l_idx),
              pi_decoder_data   => reg_data_in,
              po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}}+l_idx),

              pi_reg  => pi_addrmap.{{regfile.inst_name}}.{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(inner_idx_n,inner_idx_m),
              po_reg  => po_addrmap.{{regfile.inst_name}}.{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(inner_idx_n,inner_idx_m)
            );
        end generate;
      end generate; --}}}}}}}}
    end block; --}}}} --}} --{{context:if:eq:dim:2:
    gen_m: for outer_idx_m in 0 to {{dim_m}}-1 generate
      -- ===========================================================================
      -- generated registers instances{{{{regitems:repeat:
      -- ---------------------------------------------------------------------------
      -- reg name: {{{{{{{{reg.inst_name}}}}}}}}  reg type: {{{{{{{{reg.type_name}}}}}}}}
      -- ---------------------------------------------------------------------------
      blk_{{{{{{{{i}}}}}}}}_{{{{{{{{name}}}}}}}} : block
      begin  --{{{{{{{{context:if:eq:dim:1:
        inst_{{{{{{{{name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
          port map(
            pi_clock        => pi_clock,
            pi_reset        => pi_reset,
            -- to/from adapter
            pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m),
            pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m),
            pi_decoder_data   => reg_data_in,
            po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m),

            pi_reg  => pi_addrmap.{{regfile.inst_name}}(outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}},
            po_reg  => po_addrmap.{{regfile.inst_name}}(outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}
          ); --}}}}}}}} --{{{{{{{{context:if:eq:dim:2:
        gen_m: for idx_m in 0 to {{{{{{{{dim_m}}}}}}}}-1 generate
          inst_{{{{{{{{name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
            port map(
              pi_clock        => pi_clock,
              pi_reset        => pi_reset,
              -- to/from adapter
              pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m + idx_m),
              pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m + idx_m),
              pi_decoder_data   => reg_data_in,
              po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m + idx_m),

              pi_reg  => pi_addrmap.{{regfile.inst_name}}(outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(idx_m),
              po_reg  => po_addrmap.{{regfile.inst_name}}(outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(idx_m)
            );
        end generate; --}}}}}}}} --{{{{{{{{context:if:eq:dim:3:
        gen_n : for idx_n in 0 to {{{{{{{{dim_n}}}}}}}}-1 generate  -- outer dim, for 3D arrays
          gen_m: for idx_m in 0 to {{{{{{{{dim_m}}}}}}}}-1 generate -- inner dim, for 2D arrays
            constant l_idx : natural := (idx_n*{{{{{{{{dim_m}}}}}}}} + idx_m) ;
          begin
            inst_{{{{{{{{reg.inst_name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
              port map(
                pi_clock        => pi_clock,
                pi_reset        => pi_reset,
                -- to/from adapter
                pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m + l_idx),
                pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m + l_idx),
                pi_decoder_data   => reg_data_in,
                po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}} + {{regcount}}*outer_idx_m + l_idx),

                pi_reg  => pi_addrmap.{{regfile.inst_name}}(outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(idx_n,idx_m),
                po_reg  => po_addrmap.{{regfile.inst_name}}(outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(idx_n,idx_m)
              );
          end generate;
        end generate; --}}}}}}}}
      end block; --}}}}
    end generate; --}} --{{context:if:eq:dim:3:
    gen_n : for outer_idx_n in 0 to {{dim_n}}-1 generate  -- outer dim, for 3D arrays
      gen_m: for outer_idx_m in 0 to {{dim_m}}-1 generate -- inner dim, for 2D arrays
        constant l_idx : natural := (outer_idx_n*{{dim_m}} + outer_idx_m) * {{{{regcount}}}} ;
      begin
        -- ===========================================================================
        -- generated registers instances{{{{regitems:repeat:
        -- ---------------------------------------------------------------------------
        -- reg name: {{{{{{{{reg.inst_name}}}}}}}}  reg type: {{{{{{{{reg.type_name}}}}}}}}
        -- ---------------------------------------------------------------------------
        blk_{{{{{{{{i}}}}}}}}_{{{{{{{{name}}}}}}}} : block
        begin  --{{{{{{{{context:if:eq:dim:1:
          inst_{{{{{{{{name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
            port map(
              pi_clock        => pi_clock,
              pi_reset        => pi_reset,
              -- to/from adapter
              pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}} + l_idx),
              pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}} + l_idx),
              pi_decoder_data   => reg_data_in,
              po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}} + l_idx),

              pi_reg  => pi_addrmap.{{regfile.inst_name}}(outer_idx_n,outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}},
              po_reg  => po_addrmap.{{regfile.inst_name}}(outer_idx_n,outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}
            ); --}}}}}}}} --{{{{{{{{context:if:eq:dim:2:
          gen_m: for inner_idx_m in 0 to {{{{{{{{dim_m}}}}}}}}-1 generate
            inst_{{{{{{{{name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
              port map(
                pi_clock        => pi_clock,
                pi_reset        => pi_reset,
                -- to/from adapter
                pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}} + l_idx + inner_idx_m),
                pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}} + l_idx + inner_idx_m),
                pi_decoder_data   => reg_data_in,
                po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}} + l_idx + inner_idx_m),

                pi_reg  => pi_addrmap.{{regfile.inst_name}}(outer_idx_n,outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(inner_idx_m),
                po_reg  => po_addrmap.{{regfile.inst_name}}(outer_idx_n,outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(inner_idx_m)
              );
          end generate; --}}}}}}}} --{{{{{{{{context:if:eq:dim:3:
          gen_n : for inner_idx_n in 0 to {{{{{{{{dim_n}}}}}}}}-1 generate  -- outer dim, for 3D arrays
            gen_m: for inner_idx_m in 0 to {{{{{{{{dim_m}}}}}}}}-1 generate -- inner dim, for 2D arrays
              constant ll_idx : natural := (inner_idx_n*{{{{{{{{dim_m}}}}}}}} + inner_idx_m) ;
            begin
              inst_{{{{{{{{reg.inst_name}}}}}}}}: entity desyrdl.{node.type_name}_{{{{{{{{reg.type_name}}}}}}}}
                port map(
                  pi_clock        => pi_clock,
                  pi_reset        => pi_reset,
                  -- to/from adapter
                  pi_decoder_rd_stb => reg_rd_stb({{{{{{{{index}}}}}}}} + l_idx + ll_idx),
                  pi_decoder_wr_stb => reg_wr_stb({{{{{{{{index}}}}}}}} + l_idx + ll_idx),
                  pi_decoder_data   => reg_data_in,
                  po_decoder_data   => reg_data_out_vect({{{{{{{{index}}}}}}}} + l_idx + ll_idx),

                  pi_reg  => pi_addrmap.{{regfile.inst_name}}(outer_idx_n,outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(inner_idx_n,inner_idx_m),
                  po_reg  => po_addrmap.{{regfile.inst_name}}(outer_idx_n,outer_idx_m).{{{{{{{{{{{{{{{{reg.inst_name}}}}}}}}}}}}}}}}(inner_idx_n,inner_idx_m)
                );
            end generate;
          end generate; --}}}}}}}}
        end block; --}}}}
      end generate;
    end generate; --}}
  end block; --}

  mem_ack <= '1'; -- not used at the moment from external memories
  -- ===========================================================================
  --{memitems:repeat:
  -- ---------------------------------------------------------------------------
  -- mem name: {{mem.inst_name}}  mem type: {{mem.type_name}}
  -- ---------------------------------------------------------------------------
  blk_{{i}}_{{name}} : block
  begin
    mem_data_out_vect({{i}})({{datawidth}}-1 downto 0) <= pi_addrmap.{{mem.inst_name}}.data;{{context:if:lt:datawidth:32:
    mem_data_out_vect({{{{i}}}})(C_DATA_WIDTH-1 downto {{{{datawidth}}}}) <= (others => '0');}}
    po_addrmap.{{mem.inst_name}}.addr <= mem_addr({{addrwidth}}-1 downto 0);
    po_addrmap.{{mem.inst_name}}.data <= mem_data_in({{datawidth}}-1 downto 0);
    po_addrmap.{{mem.inst_name}}.en <= mem_stb({{i}});
    po_addrmap.{{mem.inst_name}}.we <= mem_we;
  end block;
  --}

  -- ===========================================================================
  --{extitems:repeat:
  -- ---------------------------------------------------------------------------
  -- ext name: {{ext.inst_name}}  ext type: {{ext.type_name}}
  -- ---------------------------------------------------------------------------
  blk_{{i}}_{{ext.inst_name}} : block
  begin
    ins_{desyrdl_interface:lower}_to_{{desyrdl_interface:lower}} : entity desyrdl.{desyrdl_interface:lower}_to_{{desyrdl_interface:lower}}
      port map (
        pi_clock => pi_clock,
        pi_reset => pi_reset,
        pi_s_decoder => ext_if_o({{i}}),
        po_s_decoder => ext_if_i({{i}}),
        po_m_ext     => po_addrmap.{{ext.inst_name}},
        pi_m_ext     => pi_addrmap.{{ext.inst_name}}
      );
  end block;
  --}

end architecture;
