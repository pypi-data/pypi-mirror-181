# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ryml
else:
    import _ryml

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def parse_csubstr(s, t):
    return _ryml.parse_csubstr(s, t)

def parse_substr(s, t):
    return _ryml.parse_substr(s, t)

def emit_yaml_malloc(t, id):
    return _ryml.emit_yaml_malloc(t, id)

def emit_json_malloc(t, id):
    return _ryml.emit_json_malloc(t, id)

def emit_yaml_length(t, id):
    return _ryml.emit_yaml_length(t, id)

def emit_json_length(t, id):
    return _ryml.emit_json_length(t, id)

def emit_yaml_to_substr(t, id, s):
    return _ryml.emit_yaml_to_substr(t, id, s)

def emit_json_to_substr(t, id, s):
    return _ryml.emit_json_to_substr(t, id, s)

def _get_as_csubstr(s):
    return _ryml._get_as_csubstr(s)

def _get_as_substr(s):
    return _ryml._get_as_substr(s)

def _same_ptr(l, r):
    return _ryml._same_ptr(l, r)

def _same_mem(l, r):
    return _ryml._same_mem(l, r)


from deprecation import deprecated


def as_csubstr(s):
    return _get_as_csubstr(s)

def as_substr(s):
    return _get_as_substr(s)

def u(memview):
    return str(memview, "utf8")


def children(tree, node=None):
    assert tree is not None
    if node is None:
        node = tree.root_id()
    ch = tree.first_child(node)
    while ch != NONE:
        yield ch
        ch = tree.next_sibling(ch)


def siblings(tree, node):
    assert tree is not None
    if node is None:
        return
    ch = tree.first_sibling(node)
    while ch != NONE:
        yield ch
        ch = tree.next_sibling(ch)


def walk(tree, node=None, indentation_level=0):
    assert tree is not None
    if node is None: node = tree.root_id()
    yield node, indentation_level
    ch = tree.first_child(node)
    while ch != NONE:
       for gc, il in walk(tree, ch, indentation_level + 1):
           yield gc, il
       ch = tree.next_sibling(ch)


@deprecated(deprecated_in="0.5.0", details="Use parse_in_arena() instead")
def parse(buf, **kwargs):
    return parse_in_arena(tree, id)
def parse_in_arena(buf, **kwargs):
    return _call_parse(parse_csubstr, buf, **kwargs)
def parse_in_place(buf, **kwargs):
    _check_valid_for_in_situ(buf)
    return _call_parse(parse_substr, buf, **kwargs)



def _call_parse(parse_fn, buf, **kwargs):
    tree = kwargs.get("tree", Tree())
    parse_fn(buf, tree)
    return tree


def _check_valid_for_in_situ(obj):
    if type(obj) in (str, bytes):
        raise TypeError("cannot parse in situ: " + type(obj).__name__)



@deprecated(deprecated_in="0.5.0", details="Use emit_yaml() instead")
def emit(tree, id=None):
    return emit_yaml(tree, id)
def emit_yaml(tree, id=None):
    if id is None:
        id = tree.root_id()
    return emit_yaml_malloc(tree, id)
def emit_json(tree, id=None):
    if id is None:
        id = tree.root_id()
    return emit_json_malloc(tree, id)


@deprecated(deprecated_in="0.5.0", details="Use compute_emit_yaml_length() instead")
def compute_emit_length(tree, id=None):
    return compute_emit_yaml_length(tree, id)
def compute_emit_yaml_length(tree, id=None):
    if id is None:
        id = tree.root_id()
    return emit_yaml_length(tree, id)
def compute_emit_json_length(tree, id=None):
    if id is None:
        id = tree.root_id()
    return emit_json_length(tree, id)


@deprecated(deprecated_in="0.5.0", details="Use emit_yaml_in_place() instead")
def emit_in_place(tree, buf, id=None):
    return emit_yaml_in_place(tree, buf, id)
def emit_yaml_in_place(tree, buf, id=None):
    return _emit_fn_in_place(tree, buf, id, emit_yaml_to_substr)
def emit_json_in_place(tree, buf, id=None):
    return _emit_fn_in_place(tree, buf, id, emit_json_to_substr)
def _emit_fn_in_place(tree, buf, id, fn):
    if id is None:
        id = tree.root_id()
    (failed, expected_size) = fn(tree, id, buf)
    if failed:
        raise IndexError("Output buffer has {} bytes, but emit requires {} bytes".format(
            len(buf), expected_size))
    return memoryview(buf)[:expected_size]


NOTYPE = _ryml.NOTYPE
VAL = _ryml.VAL
KEY = _ryml.KEY
MAP = _ryml.MAP
SEQ = _ryml.SEQ
DOC = _ryml.DOC
STREAM = _ryml.STREAM
KEYREF = _ryml.KEYREF
VALREF = _ryml.VALREF
KEYANCH = _ryml.KEYANCH
VALANCH = _ryml.VALANCH
KEYTAG = _ryml.KEYTAG
VALTAG = _ryml.VALTAG
class NodeType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_ryml.NodeType_type_get, _ryml.NodeType_type_set)

    def __init__(self, *args):
        _ryml.NodeType_swiginit(self, _ryml.new_NodeType(*args))
    __swig_destroy__ = _ryml.delete_NodeType

    @staticmethod
    def type_str(*args):
        return _ryml.NodeType_type_str(*args)

    def set(self, t):
        return _ryml.NodeType_set(self, t)

    def add(self, t):
        return _ryml.NodeType_add(self, t)

    def rem(self, t):
        return _ryml.NodeType_rem(self, t)

    def is_stream(self):
        return _ryml.NodeType_is_stream(self)

    def is_doc(self):
        return _ryml.NodeType_is_doc(self)

    def is_container(self):
        return _ryml.NodeType_is_container(self)

    def is_map(self):
        return _ryml.NodeType_is_map(self)

    def is_seq(self):
        return _ryml.NodeType_is_seq(self)

    def has_val(self):
        return _ryml.NodeType_has_val(self)

    def has_key(self):
        return _ryml.NodeType_has_key(self)

    def is_val(self):
        return _ryml.NodeType_is_val(self)

    def is_keyval(self):
        return _ryml.NodeType_is_keyval(self)

    def has_key_tag(self):
        return _ryml.NodeType_has_key_tag(self)

    def has_val_tag(self):
        return _ryml.NodeType_has_val_tag(self)

    def has_key_anchor(self):
        return _ryml.NodeType_has_key_anchor(self)

    def has_val_anchor(self):
        return _ryml.NodeType_has_val_anchor(self)

    def has_anchor(self):
        return _ryml.NodeType_has_anchor(self)

    def is_key_ref(self):
        return _ryml.NodeType_is_key_ref(self)

    def is_val_ref(self):
        return _ryml.NodeType_is_val_ref(self)

    def is_ref(self):
        return _ryml.NodeType_is_ref(self)

    def is_anchor_or_ref(self):
        return _ryml.NodeType_is_anchor_or_ref(self)

    def is_key_quoted(self):
        return _ryml.NodeType_is_key_quoted(self)

    def is_val_quoted(self):
        return _ryml.NodeType_is_val_quoted(self)

    def is_quoted(self):
        return _ryml.NodeType_is_quoted(self)

# Register NodeType in _ryml:
_ryml.NodeType_swigregister(NodeType)
cvar = _ryml.cvar
NONE = cvar.NONE

def NodeType_type_str(*args):
    return _ryml.NodeType_type_str(*args)

class Tree(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _ryml.Tree_swiginit(self, _ryml.new_Tree())
    __swig_destroy__ = _ryml.delete_Tree

    def reserve(self, node_capacity):
        return _ryml.Tree_reserve(self, node_capacity)

    def reserve_arena(self, node_capacity):
        return _ryml.Tree_reserve_arena(self, node_capacity)

    def clear(self):
        return _ryml.Tree_clear(self)

    def clear_arena(self):
        return _ryml.Tree_clear_arena(self)

    def size(self):
        return _ryml.Tree_size(self)

    def capacity(self):
        return _ryml.Tree_capacity(self)

    def slack(self):
        return _ryml.Tree_slack(self)

    def arena_size(self):
        return _ryml.Tree_arena_size(self)

    def arena_capacity(self):
        return _ryml.Tree_arena_capacity(self)

    def arena_slack(self):
        return _ryml.Tree_arena_slack(self)

    def resolve(self):
        return _ryml.Tree_resolve(self)

    def type(self, node):
        return _ryml.Tree_type(self, node)

    def type_str(self, node):
        return _ryml.Tree_type_str(self, node)

    def key(self, node):
        return _ryml.Tree_key(self, node)

    def key_tag(self, node):
        return _ryml.Tree_key_tag(self, node)

    def key_ref(self, node):
        return _ryml.Tree_key_ref(self, node)

    def key_anchor(self, node):
        return _ryml.Tree_key_anchor(self, node)

    def keysc(self, node):
        return _ryml.Tree_keysc(self, node)

    def val(self, node):
        return _ryml.Tree_val(self, node)

    def val_tag(self, node):
        return _ryml.Tree_val_tag(self, node)

    def val_ref(self, node):
        return _ryml.Tree_val_ref(self, node)

    def val_anchor(self, node):
        return _ryml.Tree_val_anchor(self, node)

    def valsc(self, node):
        return _ryml.Tree_valsc(self, node)

    def is_root(self, node):
        return _ryml.Tree_is_root(self, node)

    def is_stream(self, node):
        return _ryml.Tree_is_stream(self, node)

    def is_doc(self, node):
        return _ryml.Tree_is_doc(self, node)

    def is_container(self, node):
        return _ryml.Tree_is_container(self, node)

    def is_map(self, node):
        return _ryml.Tree_is_map(self, node)

    def is_seq(self, node):
        return _ryml.Tree_is_seq(self, node)

    def has_val(self, node):
        return _ryml.Tree_has_val(self, node)

    def has_key(self, node):
        return _ryml.Tree_has_key(self, node)

    def is_val(self, node):
        return _ryml.Tree_is_val(self, node)

    def is_keyval(self, node):
        return _ryml.Tree_is_keyval(self, node)

    def has_key_tag(self, node):
        return _ryml.Tree_has_key_tag(self, node)

    def has_val_tag(self, node):
        return _ryml.Tree_has_val_tag(self, node)

    def has_key_anchor(self, node):
        return _ryml.Tree_has_key_anchor(self, node)

    def has_val_anchor(self, node):
        return _ryml.Tree_has_val_anchor(self, node)

    def is_key_ref(self, node):
        return _ryml.Tree_is_key_ref(self, node)

    def is_val_ref(self, node):
        return _ryml.Tree_is_val_ref(self, node)

    def is_ref(self, node):
        return _ryml.Tree_is_ref(self, node)

    def is_anchor_or_ref(self, node):
        return _ryml.Tree_is_anchor_or_ref(self, node)

    def is_key_quoted(self, node):
        return _ryml.Tree_is_key_quoted(self, node)

    def is_val_quoted(self, node):
        return _ryml.Tree_is_val_quoted(self, node)

    def is_quoted(self, node):
        return _ryml.Tree_is_quoted(self, node)

    def is_anchor(self, node):
        return _ryml.Tree_is_anchor(self, node)

    def parent_is_seq(self, node):
        return _ryml.Tree_parent_is_seq(self, node)

    def parent_is_map(self, node):
        return _ryml.Tree_parent_is_map(self, node)

    def empty(self, node):
        return _ryml.Tree_empty(self, node)

    def has_anchor(self, node, a):
        return _ryml.Tree_has_anchor(self, node, a)

    def has_parent(self, node):
        return _ryml.Tree_has_parent(self, node)

    def has_child(self, node, key):
        return _ryml.Tree_has_child(self, node, key)

    def has_children(self, node):
        return _ryml.Tree_has_children(self, node)

    def has_sibling(self, node, key):
        return _ryml.Tree_has_sibling(self, node, key)

    def has_other_siblings(self, node):
        return _ryml.Tree_has_other_siblings(self, node)

    def root_id(self):
        return _ryml.Tree_root_id(self)

    def parent(self, node):
        return _ryml.Tree_parent(self, node)

    def prev_sibling(self, node):
        return _ryml.Tree_prev_sibling(self, node)

    def next_sibling(self, node):
        return _ryml.Tree_next_sibling(self, node)

    def num_children(self, node):
        return _ryml.Tree_num_children(self, node)

    def child_pos(self, node, ch):
        return _ryml.Tree_child_pos(self, node, ch)

    def first_child(self, node):
        return _ryml.Tree_first_child(self, node)

    def last_child(self, node):
        return _ryml.Tree_last_child(self, node)

    def child(self, node, pos):
        return _ryml.Tree_child(self, node, pos)

    def find_child(self, node, key):
        return _ryml.Tree_find_child(self, node, key)

    def num_siblings(self, node):
        return _ryml.Tree_num_siblings(self, node)

    def num_other_siblings(self, node):
        return _ryml.Tree_num_other_siblings(self, node)

    def sibling_pos(self, node, sib):
        return _ryml.Tree_sibling_pos(self, node, sib)

    def first_sibling(self, node):
        return _ryml.Tree_first_sibling(self, node)

    def last_sibling(self, node):
        return _ryml.Tree_last_sibling(self, node)

    def sibling(self, node, pos):
        return _ryml.Tree_sibling(self, node, pos)

    def find_sibling(self, node, key):
        return _ryml.Tree_find_sibling(self, node, key)

    def to_keyval(self, node, key, val, more_flags=0):
        return _ryml.Tree_to_keyval(self, node, key, val, more_flags)

    def to_val(self, node, val, more_flags=0):
        return _ryml.Tree_to_val(self, node, val, more_flags)

    def to_stream(self, node, more_flags=0):
        return _ryml.Tree_to_stream(self, node, more_flags)

    def to_map(self, *args):
        return _ryml.Tree_to_map(self, *args)

    def to_seq(self, *args):
        return _ryml.Tree_to_seq(self, *args)

    def to_doc(self, node, more_flags=0):
        return _ryml.Tree_to_doc(self, node, more_flags)

    def set_key_tag(self, node, tag):
        return _ryml.Tree_set_key_tag(self, node, tag)

    def set_key_anchor(self, node, anchor):
        return _ryml.Tree_set_key_anchor(self, node, anchor)

    def set_val_anchor(self, node, anchor):
        return _ryml.Tree_set_val_anchor(self, node, anchor)

    def set_key_ref(self, node, ref):
        return _ryml.Tree_set_key_ref(self, node, ref)

    def set_val_ref(self, node, ref):
        return _ryml.Tree_set_val_ref(self, node, ref)

    def _set_key(self, node, key, more_flags=0):
        return _ryml.Tree__set_key(self, node, key, more_flags)

    def _set_val(self, node, val, more_flags=0):
        return _ryml.Tree__set_val(self, node, val, more_flags)

    def set_val_tag(self, node, tag):
        return _ryml.Tree_set_val_tag(self, node, tag)

    def rem_key_anchor(self, node):
        return _ryml.Tree_rem_key_anchor(self, node)

    def rem_val_anchor(self, node):
        return _ryml.Tree_rem_val_anchor(self, node)

    def rem_key_ref(self, node):
        return _ryml.Tree_rem_key_ref(self, node)

    def rem_val_ref(self, node):
        return _ryml.Tree_rem_val_ref(self, node)

    def rem_anchor_ref(self, node):
        return _ryml.Tree_rem_anchor_ref(self, node)

    def insert_child(self, parent, after):
        return _ryml.Tree_insert_child(self, parent, after)

    def prepend_child(self, parent):
        return _ryml.Tree_prepend_child(self, parent)

    def append_child(self, parent):
        return _ryml.Tree_append_child(self, parent)

    def insert_sibling(self, node, after):
        return _ryml.Tree_insert_sibling(self, node, after)

    def prepend_sibling(self, node):
        return _ryml.Tree_prepend_sibling(self, node)

    def append_sibling(self, node):
        return _ryml.Tree_append_sibling(self, node)

    def remove(self, node):
        return _ryml.Tree_remove(self, node)

    def remove_children(self, node):
        return _ryml.Tree_remove_children(self, node)

    def reorder(self):
        return _ryml.Tree_reorder(self)

    def move(self, *args):
        return _ryml.Tree_move(self, *args)

    def duplicate(self, *args):
        return _ryml.Tree_duplicate(self, *args)

    def duplicate_children(self, *args):
        return _ryml.Tree_duplicate_children(self, *args)

    def duplicate_contents(self, node, where):
        return _ryml.Tree_duplicate_contents(self, node, where)

    def duplicate_children_no_rep(self, node, parent, after):
        return _ryml.Tree_duplicate_children_no_rep(self, node, parent, after)

# Register Tree in _ryml:
_ryml.Tree_swigregister(Tree)



