# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AlertingFilters',
    'AlertingFiltersFilter',
    'AlertingFiltersFilterCustom',
    'AlertingFiltersFilterCustomDescription',
    'AlertingFiltersFilterCustomTitle',
    'AlertingFiltersFilterPredefined',
    'AlertingProfileEventTypeFilter',
    'AlertingProfileEventTypeFilterCustomEventFilter',
    'AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter',
    'AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter',
    'AlertingProfileEventTypeFilterPredefinedEventFilter',
    'AlertingProfileMetadata',
    'AlertingProfileRule',
    'AlertingProfileRuleTagFilter',
    'AlertingProfileRuleTagFilterTagFilter',
    'AlertingRules',
    'AlertingRulesRule',
    'ApplicationAnomaliesFailureRate',
    'ApplicationAnomaliesFailureRateAuto',
    'ApplicationAnomaliesFailureRateThresholds',
    'ApplicationAnomaliesResponseTime',
    'ApplicationAnomaliesResponseTimeAuto',
    'ApplicationAnomaliesResponseTimeThresholds',
    'ApplicationAnomaliesTraffic',
    'ApplicationAnomaliesTrafficDrops',
    'ApplicationAnomaliesTrafficSpikes',
    'ApplicationDataPrivacySessionReplayDataPrivacy',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules',
    'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule',
    'ApplicationDetectionRuleFilterConfig',
    'ApplicationErrorRulesCustomErrors',
    'ApplicationErrorRulesCustomErrorsRule',
    'ApplicationErrorRulesHttpErrors',
    'ApplicationErrorRulesHttpErrorsRule',
    'AutotagEntitySelectorBasedRule',
    'AutotagMetadata',
    'AutotagRule',
    'AutotagRuleCondition',
    'AutotagRuleConditionApplicationType',
    'AutotagRuleConditionApplicationTypeComparison',
    'AutotagRuleConditionAzureComputeMode',
    'AutotagRuleConditionAzureComputeModeComparison',
    'AutotagRuleConditionAzureSkuComparision',
    'AutotagRuleConditionAzureSkus',
    'AutotagRuleConditionBaseComparisonBasic',
    'AutotagRuleConditionBaseConditionKey',
    'AutotagRuleConditionBitness',
    'AutotagRuleConditionBitnessComparision',
    'AutotagRuleConditionCloudType',
    'AutotagRuleConditionCloudTypeComparison',
    'AutotagRuleConditionComparison',
    'AutotagRuleConditionCustomApplicationType',
    'AutotagRuleConditionCustomApplicationTypeComparison',
    'AutotagRuleConditionCustomHostMetadata',
    'AutotagRuleConditionCustomHostMetadataConditionKey',
    'AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey',
    'AutotagRuleConditionCustomHostMetadataDynamicKey',
    'AutotagRuleConditionCustomProcessMetadata',
    'AutotagRuleConditionCustomProcessMetadataConditionKey',
    'AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
    'AutotagRuleConditionCustomProcessMetadataDynamicKey',
    'AutotagRuleConditionDatabaseTopology',
    'AutotagRuleConditionDatabaseTopologyComparison',
    'AutotagRuleConditionDcrumDecoder',
    'AutotagRuleConditionDcrumDecoderComparison',
    'AutotagRuleConditionEntity',
    'AutotagRuleConditionEntityIdComparison',
    'AutotagRuleConditionHostTech',
    'AutotagRuleConditionHostTechValue',
    'AutotagRuleConditionHypervisor',
    'AutotagRuleConditionHypervisorTypeComparision',
    'AutotagRuleConditionIndexedName',
    'AutotagRuleConditionIndexedNameComparison',
    'AutotagRuleConditionIndexedString',
    'AutotagRuleConditionIndexedStringComparison',
    'AutotagRuleConditionIndexedTag',
    'AutotagRuleConditionIndexedTagComparison',
    'AutotagRuleConditionIndexedTagComparisonValue',
    'AutotagRuleConditionIndexedTagValue',
    'AutotagRuleConditionInteger',
    'AutotagRuleConditionIntegerComparison',
    'AutotagRuleConditionIpaddress',
    'AutotagRuleConditionIpaddressComparison',
    'AutotagRuleConditionKey',
    'AutotagRuleConditionMobilePlatform',
    'AutotagRuleConditionMobilePlatformComparison',
    'AutotagRuleConditionOsArch',
    'AutotagRuleConditionOsType',
    'AutotagRuleConditionOsarchitectureComparison',
    'AutotagRuleConditionOstypeComparison',
    'AutotagRuleConditionPaasType',
    'AutotagRuleConditionPaasTypeComparison',
    'AutotagRuleConditionProcessMetadata',
    'AutotagRuleConditionProcessMetadataConditionKey',
    'AutotagRuleConditionServiceTopology',
    'AutotagRuleConditionServiceTopologyComparison',
    'AutotagRuleConditionServiceType',
    'AutotagRuleConditionServiceTypeComparison',
    'AutotagRuleConditionSimpleHostTechComparison',
    'AutotagRuleConditionSimpleHostTechComparisonValue',
    'AutotagRuleConditionSimpleTechComparison',
    'AutotagRuleConditionSimpleTechComparisonValue',
    'AutotagRuleConditionString',
    'AutotagRuleConditionStringComparison',
    'AutotagRuleConditionStringConditionKey',
    'AutotagRuleConditionStringKey',
    'AutotagRuleConditionSyntheticEngine',
    'AutotagRuleConditionSyntheticEngineTypeComparison',
    'AutotagRuleConditionTag',
    'AutotagRuleConditionTagComparison',
    'AutotagRuleConditionTagComparisonValue',
    'AutotagRuleConditionTagValue',
    'AutotagRuleConditionTech',
    'AutotagRuleConditionTechValue',
    'AwsCredentialsAuthenticationData',
    'AwsCredentialsSupportingServicesToMonitor',
    'AwsCredentialsSupportingServicesToMonitorMonitoredMetric',
    'AwsCredentialsTagsToMonitor',
    'AzureCredentialsMonitorOnlyExcludingTagPair',
    'AzureCredentialsMonitorOnlyTagPair',
    'AzureCredentialsSupportingService',
    'AzureCredentialsSupportingServiceMonitoredMetric',
    'BrowserMonitorAnomalyDetection',
    'BrowserMonitorAnomalyDetectionLoadingTimeThreshold',
    'BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold',
    'BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold',
    'BrowserMonitorAnomalyDetectionOutageHandling',
    'BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy',
    'BrowserMonitorKeyPerformanceMetrics',
    'BrowserMonitorScript',
    'BrowserMonitorScriptConfiguration',
    'BrowserMonitorScriptConfigurationBandwidth',
    'BrowserMonitorScriptConfigurationCookies',
    'BrowserMonitorScriptConfigurationCookiesCookie',
    'BrowserMonitorScriptConfigurationDevice',
    'BrowserMonitorScriptConfigurationHeaders',
    'BrowserMonitorScriptConfigurationHeadersHeader',
    'BrowserMonitorScriptConfigurationIgnoredErrorCodes',
    'BrowserMonitorScriptConfigurationJavascriptSetttings',
    'BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings',
    'BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions',
    'BrowserMonitorScriptEvents',
    'BrowserMonitorScriptEventsEvent',
    'BrowserMonitorScriptEventsEventClick',
    'BrowserMonitorScriptEventsEventClickTarget',
    'BrowserMonitorScriptEventsEventClickTargetLocator',
    'BrowserMonitorScriptEventsEventClickTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventClickValidate',
    'BrowserMonitorScriptEventsEventClickValidateValidation',
    'BrowserMonitorScriptEventsEventClickValidateValidationTarget',
    'BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventClickWait',
    'BrowserMonitorScriptEventsEventClickWaitValidation',
    'BrowserMonitorScriptEventsEventClickWaitValidationTarget',
    'BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventCookie',
    'BrowserMonitorScriptEventsEventCookieCookies',
    'BrowserMonitorScriptEventsEventCookieCookiesCookie',
    'BrowserMonitorScriptEventsEventJavascript',
    'BrowserMonitorScriptEventsEventJavascriptTarget',
    'BrowserMonitorScriptEventsEventJavascriptTargetLocator',
    'BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventJavascriptWait',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidation',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokes',
    'BrowserMonitorScriptEventsEventKeystrokesCredential',
    'BrowserMonitorScriptEventsEventKeystrokesTarget',
    'BrowserMonitorScriptEventsEventKeystrokesTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokesValidate',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidation',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventKeystrokesWait',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidation',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigate',
    'BrowserMonitorScriptEventsEventNavigateAuthentication',
    'BrowserMonitorScriptEventsEventNavigateTarget',
    'BrowserMonitorScriptEventsEventNavigateTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigateValidate',
    'BrowserMonitorScriptEventsEventNavigateValidateValidation',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTarget',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventNavigateWait',
    'BrowserMonitorScriptEventsEventNavigateWaitValidation',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTarget',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelect',
    'BrowserMonitorScriptEventsEventSelectSelections',
    'BrowserMonitorScriptEventsEventSelectSelectionsOption',
    'BrowserMonitorScriptEventsEventSelectTarget',
    'BrowserMonitorScriptEventsEventSelectTargetLocator',
    'BrowserMonitorScriptEventsEventSelectTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelectValidate',
    'BrowserMonitorScriptEventsEventSelectValidateValidation',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTarget',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventSelectWait',
    'BrowserMonitorScriptEventsEventSelectWaitValidation',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTarget',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTap',
    'BrowserMonitorScriptEventsEventTapTarget',
    'BrowserMonitorScriptEventsEventTapTargetLocator',
    'BrowserMonitorScriptEventsEventTapTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTapValidate',
    'BrowserMonitorScriptEventsEventTapValidateValidation',
    'BrowserMonitorScriptEventsEventTapValidateValidationTarget',
    'BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator',
    'BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator',
    'BrowserMonitorScriptEventsEventTapWait',
    'BrowserMonitorScriptEventsEventTapWaitValidation',
    'BrowserMonitorScriptEventsEventTapWaitValidationTarget',
    'BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator',
    'BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator',
    'BrowserMonitorTag',
    'BrowserMonitorTagTag',
    'CalculatedServiceMetricCondition',
    'CalculatedServiceMetricConditionCondition',
    'CalculatedServiceMetricConditionConditionComparison',
    'CalculatedServiceMetricConditionConditionComparisonBoolean',
    'CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType',
    'CalculatedServiceMetricConditionConditionComparisonFailedState',
    'CalculatedServiceMetricConditionConditionComparisonFailureReason',
    'CalculatedServiceMetricConditionConditionComparisonFastString',
    'CalculatedServiceMetricConditionConditionComparisonFlawState',
    'CalculatedServiceMetricConditionConditionComparisonGeneric',
    'CalculatedServiceMetricConditionConditionComparisonHttpMethod',
    'CalculatedServiceMetricConditionConditionComparisonHttpStatusClass',
    'CalculatedServiceMetricConditionConditionComparisonIibInputNodeType',
    'CalculatedServiceMetricConditionConditionComparisonNumber',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag',
    'CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey',
    'CalculatedServiceMetricConditionConditionComparisonServiceType',
    'CalculatedServiceMetricConditionConditionComparisonString',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag',
    'CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey',
    'CalculatedServiceMetricConditionConditionComparisonTag',
    'CalculatedServiceMetricConditionConditionComparisonTagValue',
    'CalculatedServiceMetricConditionConditionComparisonTagValues',
    'CalculatedServiceMetricConditionConditionComparisonTagValuesValue',
    'CalculatedServiceMetricConditionConditionComparisonZosCallType',
    'CalculatedServiceMetricDimensionDefinition',
    'CalculatedServiceMetricDimensionDefinitionPlaceholders',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag',
    'CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey',
    'CalculatedServiceMetricMetricDefinition',
    'CustomAnomaliesDimension',
    'CustomAnomaliesDimensionDimension',
    'CustomAnomaliesDimensionEntity',
    'CustomAnomaliesDimensionEntityFilter',
    'CustomAnomaliesDimensionString',
    'CustomAnomaliesDimensionStringFilter',
    'CustomAnomaliesScope',
    'CustomAnomaliesScopeCustomDeviceGroupName',
    'CustomAnomaliesScopeCustomDeviceGroupNameFilter',
    'CustomAnomaliesScopeEntity',
    'CustomAnomaliesScopeHostGroupName',
    'CustomAnomaliesScopeHostGroupNameFilter',
    'CustomAnomaliesScopeHostName',
    'CustomAnomaliesScopeHostNameFilter',
    'CustomAnomaliesScopeManagementZone',
    'CustomAnomaliesScopeName',
    'CustomAnomaliesScopeNameFilter',
    'CustomAnomaliesScopeProcessGroupId',
    'CustomAnomaliesScopeProcessGroupName',
    'CustomAnomaliesScopeProcessGroupNameFilter',
    'CustomAnomaliesScopeScope',
    'CustomAnomaliesScopeTag',
    'CustomAnomaliesScopeTagFilter',
    'CustomAnomaliesStrategy',
    'CustomAnomaliesStrategyAuto',
    'CustomAnomaliesStrategyGeneric',
    'CustomAnomaliesStrategyStatic',
    'CustomServiceRule',
    'CustomServiceRuleClass',
    'CustomServiceRuleFile',
    'CustomServiceRuleMethod',
    'DashboardDashboardMetadata',
    'DashboardDashboardMetadataDynamicFilters',
    'DashboardDashboardMetadataFilter',
    'DashboardDashboardMetadataFilterManagementZone',
    'DashboardDashboardMetadataSharingDetails',
    'DashboardMetadata',
    'DashboardSharingPermissions',
    'DashboardSharingPermissionsPermission',
    'DashboardSharingPublic',
    'DashboardTile',
    'DashboardTileBounds',
    'DashboardTileFilter',
    'DashboardTileFilterConfig',
    'DashboardTileFilterConfigChartConfig',
    'DashboardTileFilterConfigChartConfigResultMetadata',
    'DashboardTileFilterConfigChartConfigResultMetadataConfig',
    'DashboardTileFilterConfigChartConfigSeries',
    'DashboardTileFilterConfigChartConfigSeriesDimension',
    'DashboardTileFilterConfigFilters',
    'DashboardTileFilterConfigFiltersFilter',
    'DashboardTileFilterConfigFiltersFilterMatch',
    'DashboardTileFilterManagementZone',
    'DashboardTileVisualizationConfig',
    'DatabaseAnomaliesDbConnectFailures',
    'DatabaseAnomaliesFailureRate',
    'DatabaseAnomaliesFailureRateAuto',
    'DatabaseAnomaliesFailureRateThresholds',
    'DatabaseAnomaliesLoad',
    'DatabaseAnomaliesLoadDrops',
    'DatabaseAnomaliesLoadSpikes',
    'DatabaseAnomaliesResponseTime',
    'DatabaseAnomaliesResponseTimeAuto',
    'DatabaseAnomaliesResponseTimeThresholds',
    'DiskAnomaliesDiskName',
    'DiskAnomaliesTags',
    'DiskAnomaliesTagsFilter',
    'EnvironmentQuotas',
    'EnvironmentQuotasDdus',
    'EnvironmentQuotasDemUnits',
    'EnvironmentQuotasLogs',
    'EnvironmentQuotasSynthetic',
    'EnvironmentQuotasUserSessions',
    'EnvironmentStorage',
    'EnvironmentStorageLimits',
    'EnvironmentStorageRetention',
    'HostAnomaliesConnections',
    'HostAnomaliesCpu',
    'HostAnomaliesCpuThresholds',
    'HostAnomaliesDisks',
    'HostAnomaliesDisksInodes',
    'HostAnomaliesDisksInodesThresholds',
    'HostAnomaliesDisksSpace',
    'HostAnomaliesDisksSpaceThresholds',
    'HostAnomaliesDisksSpeed',
    'HostAnomaliesDisksSpeedThresholds',
    'HostAnomaliesGc',
    'HostAnomaliesGcThresholds',
    'HostAnomaliesJava',
    'HostAnomaliesJavaOutOfMemory',
    'HostAnomaliesJavaOutOfMemoryThresholds',
    'HostAnomaliesJavaOutOfThreads',
    'HostAnomaliesJavaOutOfThreadsThresholds',
    'HostAnomaliesMemory',
    'HostAnomaliesMemoryThresholds',
    'HostAnomaliesMemoryThresholdsLinux',
    'HostAnomaliesMemoryThresholdsWindows',
    'HostAnomaliesNetwork',
    'HostAnomaliesNetworkConnectivity',
    'HostAnomaliesNetworkConnectivityThresholds',
    'HostAnomaliesNetworkDroppedPackets',
    'HostAnomaliesNetworkDroppedPacketsThresholds',
    'HostAnomaliesNetworkErrors',
    'HostAnomaliesNetworkErrorsThresholds',
    'HostAnomaliesNetworkRetransmission',
    'HostAnomaliesNetworkRetransmissionThresholds',
    'HostAnomaliesNetworkUtilization',
    'HostAnomaliesNetworkUtilizationThresholds',
    'HostNamingCondition',
    'HostNamingConditionCondition',
    'HostNamingConditionConditionApplicationType',
    'HostNamingConditionConditionApplicationTypeComparison',
    'HostNamingConditionConditionAzureComputeMode',
    'HostNamingConditionConditionAzureComputeModeComparison',
    'HostNamingConditionConditionAzureSkuComparision',
    'HostNamingConditionConditionAzureSkus',
    'HostNamingConditionConditionBaseComparisonBasic',
    'HostNamingConditionConditionBaseConditionKey',
    'HostNamingConditionConditionBitness',
    'HostNamingConditionConditionBitnessComparision',
    'HostNamingConditionConditionCloudType',
    'HostNamingConditionConditionCloudTypeComparison',
    'HostNamingConditionConditionComparison',
    'HostNamingConditionConditionCustomApplicationType',
    'HostNamingConditionConditionCustomApplicationTypeComparison',
    'HostNamingConditionConditionCustomHostMetadata',
    'HostNamingConditionConditionCustomHostMetadataConditionKey',
    'HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'HostNamingConditionConditionCustomHostMetadataDynamicKey',
    'HostNamingConditionConditionCustomProcessMetadata',
    'HostNamingConditionConditionCustomProcessMetadataConditionKey',
    'HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'HostNamingConditionConditionCustomProcessMetadataDynamicKey',
    'HostNamingConditionConditionDatabaseTopology',
    'HostNamingConditionConditionDatabaseTopologyComparison',
    'HostNamingConditionConditionDcrumDecoder',
    'HostNamingConditionConditionDcrumDecoderComparison',
    'HostNamingConditionConditionEntity',
    'HostNamingConditionConditionEntityIdComparison',
    'HostNamingConditionConditionHostTech',
    'HostNamingConditionConditionHostTechValue',
    'HostNamingConditionConditionHypervisor',
    'HostNamingConditionConditionHypervisorTypeComparision',
    'HostNamingConditionConditionIndexedName',
    'HostNamingConditionConditionIndexedNameComparison',
    'HostNamingConditionConditionIndexedString',
    'HostNamingConditionConditionIndexedStringComparison',
    'HostNamingConditionConditionIndexedTag',
    'HostNamingConditionConditionIndexedTagComparison',
    'HostNamingConditionConditionIndexedTagComparisonValue',
    'HostNamingConditionConditionIndexedTagValue',
    'HostNamingConditionConditionInteger',
    'HostNamingConditionConditionIntegerComparison',
    'HostNamingConditionConditionIpaddress',
    'HostNamingConditionConditionIpaddressComparison',
    'HostNamingConditionConditionKey',
    'HostNamingConditionConditionMobilePlatform',
    'HostNamingConditionConditionMobilePlatformComparison',
    'HostNamingConditionConditionOsArch',
    'HostNamingConditionConditionOsType',
    'HostNamingConditionConditionOsarchitectureComparison',
    'HostNamingConditionConditionOstypeComparison',
    'HostNamingConditionConditionPaasType',
    'HostNamingConditionConditionPaasTypeComparison',
    'HostNamingConditionConditionProcessMetadata',
    'HostNamingConditionConditionProcessMetadataConditionKey',
    'HostNamingConditionConditionServiceTopology',
    'HostNamingConditionConditionServiceTopologyComparison',
    'HostNamingConditionConditionServiceType',
    'HostNamingConditionConditionServiceTypeComparison',
    'HostNamingConditionConditionSimpleHostTechComparison',
    'HostNamingConditionConditionSimpleHostTechComparisonValue',
    'HostNamingConditionConditionSimpleTechComparison',
    'HostNamingConditionConditionSimpleTechComparisonValue',
    'HostNamingConditionConditionString',
    'HostNamingConditionConditionStringComparison',
    'HostNamingConditionConditionStringConditionKey',
    'HostNamingConditionConditionStringKey',
    'HostNamingConditionConditionSyntheticEngine',
    'HostNamingConditionConditionSyntheticEngineTypeComparison',
    'HostNamingConditionConditionTag',
    'HostNamingConditionConditionTagComparison',
    'HostNamingConditionConditionTagComparisonValue',
    'HostNamingConditionConditionTagValue',
    'HostNamingConditionConditionTech',
    'HostNamingConditionConditionTechValue',
    'HttpMonitorAnomalyDetection',
    'HttpMonitorAnomalyDetectionLoadingTimeThreshold',
    'HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold',
    'HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold',
    'HttpMonitorAnomalyDetectionOutageHandling',
    'HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy',
    'HttpMonitorScript',
    'HttpMonitorScriptRequest',
    'HttpMonitorScriptRequestAuthentication',
    'HttpMonitorScriptRequestConfiguration',
    'HttpMonitorScriptRequestConfigurationHeaders',
    'HttpMonitorScriptRequestConfigurationHeadersHeader',
    'HttpMonitorScriptRequestValidation',
    'HttpMonitorScriptRequestValidationRule',
    'HttpMonitorTag',
    'HttpMonitorTagTag',
    'ImsBridgesQueueManager',
    'ImsBridgesQueueManagerQueueManager',
    'K8sCredentialsEventsFieldSelector',
    'MaintenanceFilter',
    'MaintenanceFilterFilter',
    'MaintenanceGeneralProperties',
    'MaintenanceSchedule',
    'MaintenanceScheduleDailyRecurrence',
    'MaintenanceScheduleDailyRecurrenceRecurrenceRange',
    'MaintenanceScheduleDailyRecurrenceTimeWindow',
    'MaintenanceScheduleMonthlyRecurrence',
    'MaintenanceScheduleMonthlyRecurrenceRecurrenceRange',
    'MaintenanceScheduleMonthlyRecurrenceTimeWindow',
    'MaintenanceScheduleOnceRecurrence',
    'MaintenanceScheduleWeeklyRecurrence',
    'MaintenanceScheduleWeeklyRecurrenceRecurrenceRange',
    'MaintenanceScheduleWeeklyRecurrenceTimeWindow',
    'MaintenanceWindowMetadata',
    'MaintenanceWindowSchedule',
    'MaintenanceWindowScheduleRecurrence',
    'MaintenanceWindowScope',
    'MaintenanceWindowScopeMatch',
    'MaintenanceWindowScopeMatchTag',
    'ManagementZoneDimensionalRule',
    'ManagementZoneDimensionalRuleCondition',
    'ManagementZoneEntitySelectorBasedRule',
    'ManagementZoneMetadata',
    'ManagementZoneRule',
    'ManagementZoneRuleCondition',
    'ManagementZoneRuleConditionApplicationType',
    'ManagementZoneRuleConditionApplicationTypeComparison',
    'ManagementZoneRuleConditionAzureComputeMode',
    'ManagementZoneRuleConditionAzureComputeModeComparison',
    'ManagementZoneRuleConditionAzureSkuComparision',
    'ManagementZoneRuleConditionAzureSkus',
    'ManagementZoneRuleConditionBaseComparisonBasic',
    'ManagementZoneRuleConditionBaseConditionKey',
    'ManagementZoneRuleConditionBitness',
    'ManagementZoneRuleConditionBitnessComparision',
    'ManagementZoneRuleConditionCloudType',
    'ManagementZoneRuleConditionCloudTypeComparison',
    'ManagementZoneRuleConditionComparison',
    'ManagementZoneRuleConditionCustomApplicationType',
    'ManagementZoneRuleConditionCustomApplicationTypeComparison',
    'ManagementZoneRuleConditionCustomHostMetadata',
    'ManagementZoneRuleConditionCustomHostMetadataConditionKey',
    'ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey',
    'ManagementZoneRuleConditionCustomHostMetadataDynamicKey',
    'ManagementZoneRuleConditionCustomProcessMetadata',
    'ManagementZoneRuleConditionCustomProcessMetadataConditionKey',
    'ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ManagementZoneRuleConditionCustomProcessMetadataDynamicKey',
    'ManagementZoneRuleConditionDatabaseTopology',
    'ManagementZoneRuleConditionDatabaseTopologyComparison',
    'ManagementZoneRuleConditionDcrumDecoder',
    'ManagementZoneRuleConditionDcrumDecoderComparison',
    'ManagementZoneRuleConditionEntity',
    'ManagementZoneRuleConditionEntityIdComparison',
    'ManagementZoneRuleConditionHostTech',
    'ManagementZoneRuleConditionHostTechValue',
    'ManagementZoneRuleConditionHypervisor',
    'ManagementZoneRuleConditionHypervisorTypeComparision',
    'ManagementZoneRuleConditionIndexedName',
    'ManagementZoneRuleConditionIndexedNameComparison',
    'ManagementZoneRuleConditionIndexedString',
    'ManagementZoneRuleConditionIndexedStringComparison',
    'ManagementZoneRuleConditionIndexedTag',
    'ManagementZoneRuleConditionIndexedTagComparison',
    'ManagementZoneRuleConditionIndexedTagComparisonValue',
    'ManagementZoneRuleConditionIndexedTagValue',
    'ManagementZoneRuleConditionInteger',
    'ManagementZoneRuleConditionIntegerComparison',
    'ManagementZoneRuleConditionIpaddress',
    'ManagementZoneRuleConditionIpaddressComparison',
    'ManagementZoneRuleConditionKey',
    'ManagementZoneRuleConditionMobilePlatform',
    'ManagementZoneRuleConditionMobilePlatformComparison',
    'ManagementZoneRuleConditionOsArch',
    'ManagementZoneRuleConditionOsType',
    'ManagementZoneRuleConditionOsarchitectureComparison',
    'ManagementZoneRuleConditionOstypeComparison',
    'ManagementZoneRuleConditionPaasType',
    'ManagementZoneRuleConditionPaasTypeComparison',
    'ManagementZoneRuleConditionProcessMetadata',
    'ManagementZoneRuleConditionProcessMetadataConditionKey',
    'ManagementZoneRuleConditionServiceTopology',
    'ManagementZoneRuleConditionServiceTopologyComparison',
    'ManagementZoneRuleConditionServiceType',
    'ManagementZoneRuleConditionServiceTypeComparison',
    'ManagementZoneRuleConditionSimpleHostTechComparison',
    'ManagementZoneRuleConditionSimpleHostTechComparisonValue',
    'ManagementZoneRuleConditionSimpleTechComparison',
    'ManagementZoneRuleConditionSimpleTechComparisonValue',
    'ManagementZoneRuleConditionString',
    'ManagementZoneRuleConditionStringComparison',
    'ManagementZoneRuleConditionStringConditionKey',
    'ManagementZoneRuleConditionStringKey',
    'ManagementZoneRuleConditionSyntheticEngine',
    'ManagementZoneRuleConditionSyntheticEngineTypeComparison',
    'ManagementZoneRuleConditionTag',
    'ManagementZoneRuleConditionTagComparison',
    'ManagementZoneRuleConditionTagComparisonValue',
    'ManagementZoneRuleConditionTagValue',
    'ManagementZoneRuleConditionTech',
    'ManagementZoneRuleConditionTechValue',
    'MobileApplicationApdex',
    'MobileApplicationProperties',
    'MobileApplicationPropertiesApiValue',
    'MobileApplicationPropertiesRequestAttribute',
    'NotificationAnsibleTower',
    'NotificationConfig',
    'NotificationEmail',
    'NotificationHipchat',
    'NotificationJira',
    'NotificationOpsGenie',
    'NotificationPagerDuty',
    'NotificationServiceNow',
    'NotificationSlack',
    'NotificationTrello',
    'NotificationVictorOps',
    'NotificationWebHook',
    'NotificationWebHookHeader',
    'NotificationXmatters',
    'NotificationXmattersHeader',
    'ProcessgroupNamingCondition',
    'ProcessgroupNamingConditionCondition',
    'ProcessgroupNamingConditionConditionApplicationType',
    'ProcessgroupNamingConditionConditionApplicationTypeComparison',
    'ProcessgroupNamingConditionConditionAzureComputeMode',
    'ProcessgroupNamingConditionConditionAzureComputeModeComparison',
    'ProcessgroupNamingConditionConditionAzureSkuComparision',
    'ProcessgroupNamingConditionConditionAzureSkus',
    'ProcessgroupNamingConditionConditionBaseComparisonBasic',
    'ProcessgroupNamingConditionConditionBaseConditionKey',
    'ProcessgroupNamingConditionConditionBitness',
    'ProcessgroupNamingConditionConditionBitnessComparision',
    'ProcessgroupNamingConditionConditionCloudType',
    'ProcessgroupNamingConditionConditionCloudTypeComparison',
    'ProcessgroupNamingConditionConditionComparison',
    'ProcessgroupNamingConditionConditionCustomApplicationType',
    'ProcessgroupNamingConditionConditionCustomApplicationTypeComparison',
    'ProcessgroupNamingConditionConditionCustomHostMetadata',
    'ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey',
    'ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadata',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey',
    'ProcessgroupNamingConditionConditionDatabaseTopology',
    'ProcessgroupNamingConditionConditionDatabaseTopologyComparison',
    'ProcessgroupNamingConditionConditionDcrumDecoder',
    'ProcessgroupNamingConditionConditionDcrumDecoderComparison',
    'ProcessgroupNamingConditionConditionEntity',
    'ProcessgroupNamingConditionConditionEntityIdComparison',
    'ProcessgroupNamingConditionConditionHostTech',
    'ProcessgroupNamingConditionConditionHostTechValue',
    'ProcessgroupNamingConditionConditionHypervisor',
    'ProcessgroupNamingConditionConditionHypervisorTypeComparision',
    'ProcessgroupNamingConditionConditionIndexedName',
    'ProcessgroupNamingConditionConditionIndexedNameComparison',
    'ProcessgroupNamingConditionConditionIndexedString',
    'ProcessgroupNamingConditionConditionIndexedStringComparison',
    'ProcessgroupNamingConditionConditionIndexedTag',
    'ProcessgroupNamingConditionConditionIndexedTagComparison',
    'ProcessgroupNamingConditionConditionIndexedTagComparisonValue',
    'ProcessgroupNamingConditionConditionIndexedTagValue',
    'ProcessgroupNamingConditionConditionInteger',
    'ProcessgroupNamingConditionConditionIntegerComparison',
    'ProcessgroupNamingConditionConditionIpaddress',
    'ProcessgroupNamingConditionConditionIpaddressComparison',
    'ProcessgroupNamingConditionConditionKey',
    'ProcessgroupNamingConditionConditionMobilePlatform',
    'ProcessgroupNamingConditionConditionMobilePlatformComparison',
    'ProcessgroupNamingConditionConditionOsArch',
    'ProcessgroupNamingConditionConditionOsType',
    'ProcessgroupNamingConditionConditionOsarchitectureComparison',
    'ProcessgroupNamingConditionConditionOstypeComparison',
    'ProcessgroupNamingConditionConditionPaasType',
    'ProcessgroupNamingConditionConditionPaasTypeComparison',
    'ProcessgroupNamingConditionConditionProcessMetadata',
    'ProcessgroupNamingConditionConditionProcessMetadataConditionKey',
    'ProcessgroupNamingConditionConditionServiceTopology',
    'ProcessgroupNamingConditionConditionServiceTopologyComparison',
    'ProcessgroupNamingConditionConditionServiceType',
    'ProcessgroupNamingConditionConditionServiceTypeComparison',
    'ProcessgroupNamingConditionConditionSimpleHostTechComparison',
    'ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue',
    'ProcessgroupNamingConditionConditionSimpleTechComparison',
    'ProcessgroupNamingConditionConditionSimpleTechComparisonValue',
    'ProcessgroupNamingConditionConditionString',
    'ProcessgroupNamingConditionConditionStringComparison',
    'ProcessgroupNamingConditionConditionStringConditionKey',
    'ProcessgroupNamingConditionConditionStringKey',
    'ProcessgroupNamingConditionConditionSyntheticEngine',
    'ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison',
    'ProcessgroupNamingConditionConditionTag',
    'ProcessgroupNamingConditionConditionTagComparison',
    'ProcessgroupNamingConditionConditionTagComparisonValue',
    'ProcessgroupNamingConditionConditionTagValue',
    'ProcessgroupNamingConditionConditionTech',
    'ProcessgroupNamingConditionConditionTechValue',
    'QueueManagerAliasQueue',
    'QueueManagerAliasQueueAliasQueue',
    'QueueManagerClusterQueue',
    'QueueManagerClusterQueueClusterQueue',
    'QueueManagerRemoteQueue',
    'QueueManagerRemoteQueueRemoteQueue',
    'RequestAttributeDataSource',
    'RequestAttributeDataSourceCicsSdkMethodNodeCondition',
    'RequestAttributeDataSourceIibLabelMethodNodeCondition',
    'RequestAttributeDataSourceIibMethodNodeCondition',
    'RequestAttributeDataSourceMethod',
    'RequestAttributeDataSourceMethodMethod',
    'RequestAttributeDataSourceScope',
    'RequestAttributeDataSourceValueProcessing',
    'RequestAttributeDataSourceValueProcessingExtractSubstring',
    'RequestAttributeDataSourceValueProcessingValueCondition',
    'RequestNamingConditions',
    'RequestNamingConditionsCondition',
    'RequestNamingConditionsConditionComparison',
    'RequestNamingConditionsConditionComparisonBoolean',
    'RequestNamingConditionsConditionComparisonEsbInputNodeType',
    'RequestNamingConditionsConditionComparisonFailedState',
    'RequestNamingConditionsConditionComparisonFailureReason',
    'RequestNamingConditionsConditionComparisonFastString',
    'RequestNamingConditionsConditionComparisonFlawState',
    'RequestNamingConditionsConditionComparisonGeneric',
    'RequestNamingConditionsConditionComparisonHttpMethod',
    'RequestNamingConditionsConditionComparisonHttpStatusClass',
    'RequestNamingConditionsConditionComparisonIibInputNodeType',
    'RequestNamingConditionsConditionComparisonNumber',
    'RequestNamingConditionsConditionComparisonNumberRequestAttribute',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSource',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag',
    'RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey',
    'RequestNamingConditionsConditionComparisonServiceType',
    'RequestNamingConditionsConditionComparisonString',
    'RequestNamingConditionsConditionComparisonStringRequestAttribute',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSource',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag',
    'RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey',
    'RequestNamingConditionsConditionComparisonTag',
    'RequestNamingConditionsConditionComparisonTagValue',
    'RequestNamingConditionsConditionComparisonTagValues',
    'RequestNamingConditionsConditionComparisonTagValuesValue',
    'RequestNamingConditionsConditionComparisonZosCallType',
    'RequestNamingPlaceholders',
    'RequestNamingPlaceholdersPlaceholder',
    'RequestNamingPlaceholdersPlaceholderSource',
    'RequestNamingPlaceholdersPlaceholderSourceServiceTag',
    'RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey',
    'ServiceAnomaliesFailureRates',
    'ServiceAnomaliesFailureRatesAuto',
    'ServiceAnomaliesFailureRatesThresholds',
    'ServiceAnomaliesLoad',
    'ServiceAnomaliesLoadDrops',
    'ServiceAnomaliesLoadSpikes',
    'ServiceAnomaliesResponseTimes',
    'ServiceAnomaliesResponseTimesAuto',
    'ServiceAnomaliesResponseTimesThresholds',
    'ServiceNamingCondition',
    'ServiceNamingConditionCondition',
    'ServiceNamingConditionConditionApplicationType',
    'ServiceNamingConditionConditionApplicationTypeComparison',
    'ServiceNamingConditionConditionAzureComputeMode',
    'ServiceNamingConditionConditionAzureComputeModeComparison',
    'ServiceNamingConditionConditionAzureSkuComparision',
    'ServiceNamingConditionConditionAzureSkus',
    'ServiceNamingConditionConditionBaseComparisonBasic',
    'ServiceNamingConditionConditionBaseConditionKey',
    'ServiceNamingConditionConditionBitness',
    'ServiceNamingConditionConditionBitnessComparision',
    'ServiceNamingConditionConditionCloudType',
    'ServiceNamingConditionConditionCloudTypeComparison',
    'ServiceNamingConditionConditionComparison',
    'ServiceNamingConditionConditionCustomApplicationType',
    'ServiceNamingConditionConditionCustomApplicationTypeComparison',
    'ServiceNamingConditionConditionCustomHostMetadata',
    'ServiceNamingConditionConditionCustomHostMetadataConditionKey',
    'ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
    'ServiceNamingConditionConditionCustomHostMetadataDynamicKey',
    'ServiceNamingConditionConditionCustomProcessMetadata',
    'ServiceNamingConditionConditionCustomProcessMetadataConditionKey',
    'ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
    'ServiceNamingConditionConditionCustomProcessMetadataDynamicKey',
    'ServiceNamingConditionConditionDatabaseTopology',
    'ServiceNamingConditionConditionDatabaseTopologyComparison',
    'ServiceNamingConditionConditionDcrumDecoder',
    'ServiceNamingConditionConditionDcrumDecoderComparison',
    'ServiceNamingConditionConditionEntity',
    'ServiceNamingConditionConditionEntityIdComparison',
    'ServiceNamingConditionConditionHostTech',
    'ServiceNamingConditionConditionHostTechValue',
    'ServiceNamingConditionConditionHypervisor',
    'ServiceNamingConditionConditionHypervisorTypeComparision',
    'ServiceNamingConditionConditionIndexedName',
    'ServiceNamingConditionConditionIndexedNameComparison',
    'ServiceNamingConditionConditionIndexedString',
    'ServiceNamingConditionConditionIndexedStringComparison',
    'ServiceNamingConditionConditionIndexedTag',
    'ServiceNamingConditionConditionIndexedTagComparison',
    'ServiceNamingConditionConditionIndexedTagComparisonValue',
    'ServiceNamingConditionConditionIndexedTagValue',
    'ServiceNamingConditionConditionInteger',
    'ServiceNamingConditionConditionIntegerComparison',
    'ServiceNamingConditionConditionIpaddress',
    'ServiceNamingConditionConditionIpaddressComparison',
    'ServiceNamingConditionConditionKey',
    'ServiceNamingConditionConditionMobilePlatform',
    'ServiceNamingConditionConditionMobilePlatformComparison',
    'ServiceNamingConditionConditionOsArch',
    'ServiceNamingConditionConditionOsType',
    'ServiceNamingConditionConditionOsarchitectureComparison',
    'ServiceNamingConditionConditionOstypeComparison',
    'ServiceNamingConditionConditionPaasType',
    'ServiceNamingConditionConditionPaasTypeComparison',
    'ServiceNamingConditionConditionProcessMetadata',
    'ServiceNamingConditionConditionProcessMetadataConditionKey',
    'ServiceNamingConditionConditionServiceTopology',
    'ServiceNamingConditionConditionServiceTopologyComparison',
    'ServiceNamingConditionConditionServiceType',
    'ServiceNamingConditionConditionServiceTypeComparison',
    'ServiceNamingConditionConditionSimpleHostTechComparison',
    'ServiceNamingConditionConditionSimpleHostTechComparisonValue',
    'ServiceNamingConditionConditionSimpleTechComparison',
    'ServiceNamingConditionConditionSimpleTechComparisonValue',
    'ServiceNamingConditionConditionString',
    'ServiceNamingConditionConditionStringComparison',
    'ServiceNamingConditionConditionStringConditionKey',
    'ServiceNamingConditionConditionStringKey',
    'ServiceNamingConditionConditionSyntheticEngine',
    'ServiceNamingConditionConditionSyntheticEngineTypeComparison',
    'ServiceNamingConditionConditionTag',
    'ServiceNamingConditionConditionTagComparison',
    'ServiceNamingConditionConditionTagComparisonValue',
    'ServiceNamingConditionConditionTagValue',
    'ServiceNamingConditionConditionTech',
    'ServiceNamingConditionConditionTechValue',
    'SpanCaptureRuleMatches',
    'SpanCaptureRuleMatchesMatch',
    'SpanContextPropagationMatches',
    'SpanContextPropagationMatchesMatch',
    'SpanEntryPointMatches',
    'SpanEntryPointMatchesMatch',
    'UserGroupPermissions',
    'UserGroupPermissionsGrant',
    'WebApplicationConversionGoals',
    'WebApplicationConversionGoalsGoal',
    'WebApplicationConversionGoalsGoalDestination',
    'WebApplicationConversionGoalsGoalUserAction',
    'WebApplicationConversionGoalsGoalVisitDuration',
    'WebApplicationConversionGoalsGoalVisitNumAction',
    'WebApplicationCustomActionApdexSettings',
    'WebApplicationKeyUserAction',
    'WebApplicationKeyUserActionAction',
    'WebApplicationLoadActionApdexSettings',
    'WebApplicationMetaDataCaptureSettings',
    'WebApplicationMetaDataCaptureSettingsCapture',
    'WebApplicationMonitoringSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings',
    'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettings',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions',
    'WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction',
    'WebApplicationMonitoringSettingsContentCapture',
    'WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings',
    'WebApplicationMonitoringSettingsContentCaptureTimeoutSettings',
    'WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettings',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions',
    'WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange',
    'WebApplicationMonitoringSettingsJavascriptFrameworkSupport',
    'WebApplicationMonitoringSettingsJavascriptInjectionRules',
    'WebApplicationMonitoringSettingsJavascriptInjectionRulesRule',
    'WebApplicationSessionReplayConfig',
    'WebApplicationUserActionAndSessionProperties',
    'WebApplicationUserActionAndSessionPropertiesProperty',
    'WebApplicationUserActionNamingSettings',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRules',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRules',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserActionNamingSettingsPlaceholders',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps',
    'WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRules',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions',
    'WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition',
    'WebApplicationUserTags',
    'WebApplicationUserTagsTag',
    'WebApplicationWaterfallSettings',
    'WebApplicationXhrActionApdexSettings',
    'WebhookNotificationHeaders',
    'WebhookNotificationHeadersHeader',
    'XmattersNotificationHeaders',
    'XmattersNotificationHeadersHeader',
    'GetSyntheticLocationsLocationsResult',
    'GetSyntheticLocationsLocationsLocationResult',
]

@pulumi.output_type
class AlertingFilters(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.AlertingFiltersFilter']] = None):
        """
        :param Sequence['AlertingFiltersFilterArgs'] filters: A conditions for the metric usage
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.AlertingFiltersFilter']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class AlertingFiltersFilter(dict):
    def __init__(__self__, *,
                 custom: Optional['outputs.AlertingFiltersFilterCustom'] = None,
                 predefined: Optional['outputs.AlertingFiltersFilterPredefined'] = None):
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if predefined is not None:
            pulumi.set(__self__, "predefined", predefined)

    @property
    @pulumi.getter
    def custom(self) -> Optional['outputs.AlertingFiltersFilterCustom']:
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter
    def predefined(self) -> Optional['outputs.AlertingFiltersFilterPredefined']:
        return pulumi.get(self, "predefined")


@pulumi.output_type
class AlertingFiltersFilterCustom(dict):
    def __init__(__self__, *,
                 description: Optional['outputs.AlertingFiltersFilterCustomDescription'] = None,
                 title: Optional['outputs.AlertingFiltersFilterCustomTitle'] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional['outputs.AlertingFiltersFilterCustomDescription']:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def title(self) -> Optional['outputs.AlertingFiltersFilterCustomTitle']:
        return pulumi.get(self, "title")


@pulumi.output_type
class AlertingFiltersFilterCustomDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingFiltersFilterCustomDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingFiltersFilterCustomDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingFiltersFilterCustomDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingFiltersFilterCustomTitle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingFiltersFilterCustomTitle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingFiltersFilterCustomTitle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingFiltersFilterCustomTitle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingFiltersFilterPredefined(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")


@pulumi.output_type
class AlertingProfileEventTypeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customEventFilters":
            suggest = "custom_event_filters"
        elif key == "predefinedEventFilters":
            suggest = "predefined_event_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_event_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilter']] = None,
                 predefined_event_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterPredefinedEventFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AlertingProfileEventTypeFilterCustomEventFilterArgs'] custom_event_filters: Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        :param Sequence['AlertingProfileEventTypeFilterPredefinedEventFilterArgs'] predefined_event_filters: Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_event_filters is not None:
            pulumi.set(__self__, "custom_event_filters", custom_event_filters)
        if predefined_event_filters is not None:
            pulumi.set(__self__, "predefined_event_filters", predefined_event_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customEventFilters")
    def custom_event_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilter']]:
        """
        Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        return pulumi.get(self, "custom_event_filters")

    @property
    @pulumi.getter(name="predefinedEventFilters")
    def predefined_event_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterPredefinedEventFilter']]:
        """
        Configuration of a custom event filter. Filters custom events by title or description. If both specified, the AND logic applies
        """
        return pulumi.get(self, "predefined_event_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDescriptionFilters":
            suggest = "custom_description_filters"
        elif key == "customTitleFilters":
            suggest = "custom_title_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_description_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter']] = None,
                 custom_title_filters: Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_description_filters is not None:
            pulumi.set(__self__, "custom_description_filters", custom_description_filters)
        if custom_title_filters is not None:
            pulumi.set(__self__, "custom_title_filters", custom_title_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customDescriptionFilters")
    def custom_description_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter']]:
        return pulumi.get(self, "custom_description_filters")

    @property
    @pulumi.getter(name="customTitleFilters")
    def custom_title_filters(self) -> Optional[Sequence['outputs.AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter']]:
        return pulumi.get(self, "custom_title_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseInsensitive":
            suggest = "case_insensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomDescriptionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_insensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_insensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseInsensitive":
            suggest = "case_insensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterCustomEventFilterCustomTitleFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 case_insensitive: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_insensitive")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileEventTypeFilterPredefinedEventFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileEventTypeFilterPredefinedEventFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileEventTypeFilterPredefinedEventFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileEventTypeFilterPredefinedEventFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "event_type", event_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        """
        :param str cluster_version: Dynatrace server version
        :param Sequence[int] configuration_versions: A Sorted list of the version numbers of the configuration
        :param Sequence[str] current_configuration_versions: A Sorted list of the version numbers of the configuration
        """
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        Dynatrace server version
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class AlertingProfileRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"
        elif key == "severityLevel":
            suggest = "severity_level"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: int,
                 severity_level: str,
                 tag_filters: Sequence['outputs.AlertingProfileRuleTagFilter'],
                 unknowns: Optional[str] = None):
        """
        :param int delay_in_minutes: Send a notification if a problem remains open longer than *X* minutes
        :param str severity_level: The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERROR`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
        :param Sequence['AlertingProfileRuleTagFilterArgs'] tag_filters: Configuration of the tag filtering of the alerting profile
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        pulumi.set(__self__, "severity_level", severity_level)
        pulumi.set(__self__, "tag_filters", tag_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> int:
        """
        Send a notification if a problem remains open longer than *X* minutes
        """
        return pulumi.get(self, "delay_in_minutes")

    @property
    @pulumi.getter(name="severityLevel")
    def severity_level(self) -> str:
        """
        The severity level to trigger the alert. Possible values are `AVAILABILITY`,	`CUSTOM_ALERT`,	`ERROR`,`MONITORING_UNAVAILABLE`,`PERFORMANCE` and `RESOURCE_CONTENTION`.
        """
        return pulumi.get(self, "severity_level")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Sequence['outputs.AlertingProfileRuleTagFilter']:
        """
        Configuration of the tag filtering of the alerting profile
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileRuleTagFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeMode":
            suggest = "include_mode"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingProfileRuleTagFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingProfileRuleTagFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingProfileRuleTagFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_mode: str,
                 tag_filters: Optional[Sequence['outputs.AlertingProfileRuleTagFilterTagFilter']] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "include_mode", include_mode)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="includeMode")
    def include_mode(self) -> str:
        return pulumi.get(self, "include_mode")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AlertingProfileRuleTagFilterTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AlertingProfileRuleTagFilterTagFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertingRules(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.AlertingRulesRule']] = None):
        """
        :param Sequence['AlertingRulesRuleArgs'] rules: A conditions for the metric usage
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AlertingRulesRule']]:
        """
        A conditions for the metric usage
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AlertingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"
        elif key == "includeMode":
            suggest = "include_mode"
        elif key == "severityLevel":
            suggest = "severity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: int,
                 include_mode: str,
                 severity_level: str,
                 tags: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        pulumi.set(__self__, "include_mode", include_mode)
        pulumi.set(__self__, "severity_level", severity_level)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> int:
        return pulumi.get(self, "delay_in_minutes")

    @property
    @pulumi.getter(name="includeMode")
    def include_mode(self) -> str:
        return pulumi.get(self, "include_mode")

    @property
    @pulumi.getter(name="severityLevel")
    def severity_level(self) -> str:
        return pulumi.get(self, "severity_level")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class ApplicationAnomaliesFailureRate(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ApplicationAnomaliesFailureRateAuto'] = None,
                 thresholds: Optional['outputs.ApplicationAnomaliesFailureRateThresholds'] = None):
        """
        :param 'ApplicationAnomaliesFailureRateAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'ApplicationAnomaliesFailureRateThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ApplicationAnomaliesFailureRateAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ApplicationAnomaliesFailureRateThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ApplicationAnomaliesFailureRateAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesFailureRateThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesResponseTime(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ApplicationAnomaliesResponseTimeAuto'] = None,
                 thresholds: Optional['outputs.ApplicationAnomaliesResponseTimeThresholds'] = None):
        """
        :param 'ApplicationAnomaliesResponseTimeAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'ApplicationAnomaliesResponseTimeThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ApplicationAnomaliesResponseTimeAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ApplicationAnomaliesResponseTimeThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ApplicationAnomaliesResponseTimeAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAnomaliesResponseTimeAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAnomaliesResponseTimeAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAnomaliesResponseTimeAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesResponseTimeThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAnomaliesResponseTimeThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ApplicationAnomaliesTraffic(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.ApplicationAnomaliesTrafficDrops'] = None,
                 spikes: Optional['outputs.ApplicationAnomaliesTrafficSpikes'] = None):
        """
        :param 'ApplicationAnomaliesTrafficDropsArgs' drops: The configuration of traffic drops detection
        :param 'ApplicationAnomaliesTrafficSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.ApplicationAnomaliesTrafficDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.ApplicationAnomaliesTrafficSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class ApplicationAnomaliesTrafficDrops(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 percent: Optional[int] = None):
        pulumi.set(__self__, "enabled", enabled)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")


@pulumi.output_type
class ApplicationAnomaliesTrafficSpikes(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 percent: Optional[int] = None):
        pulumi.set(__self__, "enabled", enabled)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentMaskingSettings":
            suggest = "content_masking_settings"
        elif key == "optIn":
            suggest = "opt_in"
        elif key == "urlExclusionRules":
            suggest = "url_exclusion_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_masking_settings: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings',
                 opt_in: Optional[bool] = None,
                 url_exclusion_rules: Optional[Sequence[str]] = None):
        """
        :param 'ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsArgs' content_masking_settings: Content masking settings for Session Replay.
        """
        pulumi.set(__self__, "content_masking_settings", content_masking_settings)
        if opt_in is not None:
            pulumi.set(__self__, "opt_in", opt_in)
        if url_exclusion_rules is not None:
            pulumi.set(__self__, "url_exclusion_rules", url_exclusion_rules)

    @property
    @pulumi.getter(name="contentMaskingSettings")
    def content_masking_settings(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings':
        """
        Content masking settings for Session Replay.
        """
        return pulumi.get(self, "content_masking_settings")

    @property
    @pulumi.getter(name="optIn")
    def opt_in(self) -> Optional[bool]:
        return pulumi.get(self, "opt_in")

    @property
    @pulumi.getter(name="urlExclusionRules")
    def url_exclusion_rules(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "url_exclusion_rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettings(dict):
    def __init__(__self__, *,
                 playback: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback',
                 recording: 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording'):
        pulumi.set(__self__, "playback", playback)
        pulumi.set(__self__, "recording", recording)

    @property
    @pulumi.getter
    def playback(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback':
        return pulumi.get(self, "playback")

    @property
    @pulumi.getter
    def recording(self) -> 'outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording':
        return pulumi.get(self, "recording")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlayback(dict):
    def __init__(__self__, *,
                 preset: str,
                 rules: Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules'] = None):
        pulumi.set(__self__, "preset", preset)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def preset(self) -> str:
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userInteractionHidden":
            suggest = "user_interaction_hidden"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsPlaybackRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selector: str,
                 type: str,
                 user_interaction_hidden: Optional[bool] = None):
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "type", type)
        if user_interaction_hidden is not None:
            pulumi.set(__self__, "user_interaction_hidden", user_interaction_hidden)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userInteractionHidden")
    def user_interaction_hidden(self) -> Optional[bool]:
        return pulumi.get(self, "user_interaction_hidden")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecording(dict):
    def __init__(__self__, *,
                 preset: str,
                 rules: Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules'] = None):
        pulumi.set(__self__, "preset", preset)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def preset(self) -> str:
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def rules(self) -> Optional['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userInteractionHidden":
            suggest = "user_interaction_hidden"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDataPrivacySessionReplayDataPrivacyContentMaskingSettingsRecordingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selector: str,
                 type: str,
                 user_interaction_hidden: Optional[bool] = None):
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "type", type)
        if user_interaction_hidden is not None:
            pulumi.set(__self__, "user_interaction_hidden", user_interaction_hidden)

    @property
    @pulumi.getter
    def selector(self) -> str:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userInteractionHidden")
    def user_interaction_hidden(self) -> Optional[bool]:
        return pulumi.get(self, "user_interaction_hidden")


@pulumi.output_type
class ApplicationDetectionRuleFilterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationMatchTarget":
            suggest = "application_match_target"
        elif key == "applicationMatchType":
            suggest = "application_match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationDetectionRuleFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationDetectionRuleFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationDetectionRuleFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_match_target: str,
                 application_match_type: str,
                 pattern: str):
        """
        :param str application_match_target: Where to look for the pattern value, possible values are `DOMAIN` or `URL`
        :param str application_match_type: The operator used for matching the application detection rule, possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `MATCHES`
        :param str pattern: The value to look for with the application detection rule
        """
        pulumi.set(__self__, "application_match_target", application_match_target)
        pulumi.set(__self__, "application_match_type", application_match_type)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter(name="applicationMatchTarget")
    def application_match_target(self) -> str:
        """
        Where to look for the pattern value, possible values are `DOMAIN` or `URL`
        """
        return pulumi.get(self, "application_match_target")

    @property
    @pulumi.getter(name="applicationMatchType")
    def application_match_type(self) -> str:
        """
        The operator used for matching the application detection rule, possible values are `BEGINS_WITH`, `CONTAINS`, `ENDS_WITH`, `EQUALS`, `MATCHES`
        """
        return pulumi.get(self, "application_match_type")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        The value to look for with the application detection rule
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ApplicationErrorRulesCustomErrors(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationErrorRulesCustomErrorsRule']):
        """
        :param Sequence['ApplicationErrorRulesCustomErrorsRuleArgs'] rules: Configuration of the custom error in the web application
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationErrorRulesCustomErrorsRule']:
        """
        Configuration of the custom error in the web application
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationErrorRulesCustomErrorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customAlerting":
            suggest = "custom_alerting"
        elif key == "impactApdex":
            suggest = "impact_apdex"
        elif key == "keyMatcher":
            suggest = "key_matcher"
        elif key == "keyPattern":
            suggest = "key_pattern"
        elif key == "valueMatcher":
            suggest = "value_matcher"
        elif key == "valuePattern":
            suggest = "value_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationErrorRulesCustomErrorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationErrorRulesCustomErrorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationErrorRulesCustomErrorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: Optional[bool] = None,
                 custom_alerting: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None,
                 key_matcher: Optional[str] = None,
                 key_pattern: Optional[str] = None,
                 value_matcher: Optional[str] = None,
                 value_pattern: Optional[str] = None):
        if capture is not None:
            pulumi.set(__self__, "capture", capture)
        if custom_alerting is not None:
            pulumi.set(__self__, "custom_alerting", custom_alerting)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)
        if key_matcher is not None:
            pulumi.set(__self__, "key_matcher", key_matcher)
        if key_pattern is not None:
            pulumi.set(__self__, "key_pattern", key_pattern)
        if value_matcher is not None:
            pulumi.set(__self__, "value_matcher", value_matcher)
        if value_pattern is not None:
            pulumi.set(__self__, "value_pattern", value_pattern)

    @property
    @pulumi.getter
    def capture(self) -> Optional[bool]:
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="customAlerting")
    def custom_alerting(self) -> Optional[bool]:
        return pulumi.get(self, "custom_alerting")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        return pulumi.get(self, "impact_apdex")

    @property
    @pulumi.getter(name="keyMatcher")
    def key_matcher(self) -> Optional[str]:
        return pulumi.get(self, "key_matcher")

    @property
    @pulumi.getter(name="keyPattern")
    def key_pattern(self) -> Optional[str]:
        return pulumi.get(self, "key_pattern")

    @property
    @pulumi.getter(name="valueMatcher")
    def value_matcher(self) -> Optional[str]:
        return pulumi.get(self, "value_matcher")

    @property
    @pulumi.getter(name="valuePattern")
    def value_pattern(self) -> Optional[str]:
        return pulumi.get(self, "value_pattern")


@pulumi.output_type
class ApplicationErrorRulesHttpErrors(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ApplicationErrorRulesHttpErrorsRule']):
        """
        :param Sequence['ApplicationErrorRulesHttpErrorsRuleArgs'] rules: Configuration of the HTTP error in the web application
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ApplicationErrorRulesHttpErrorsRule']:
        """
        Configuration of the HTTP error in the web application
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ApplicationErrorRulesHttpErrorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "considerBlockedRequests":
            suggest = "consider_blocked_requests"
        elif key == "considerForAi":
            suggest = "consider_for_ai"
        elif key == "considerUnknownErrorCode":
            suggest = "consider_unknown_error_code"
        elif key == "errorCodes":
            suggest = "error_codes"
        elif key == "filterByUrl":
            suggest = "filter_by_url"
        elif key == "impactApdex":
            suggest = "impact_apdex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationErrorRulesHttpErrorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationErrorRulesHttpErrorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationErrorRulesHttpErrorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: Optional[bool] = None,
                 consider_blocked_requests: Optional[bool] = None,
                 consider_for_ai: Optional[bool] = None,
                 consider_unknown_error_code: Optional[bool] = None,
                 error_codes: Optional[str] = None,
                 filter: Optional[str] = None,
                 filter_by_url: Optional[bool] = None,
                 impact_apdex: Optional[bool] = None,
                 url: Optional[str] = None):
        if capture is not None:
            pulumi.set(__self__, "capture", capture)
        if consider_blocked_requests is not None:
            pulumi.set(__self__, "consider_blocked_requests", consider_blocked_requests)
        if consider_for_ai is not None:
            pulumi.set(__self__, "consider_for_ai", consider_for_ai)
        if consider_unknown_error_code is not None:
            pulumi.set(__self__, "consider_unknown_error_code", consider_unknown_error_code)
        if error_codes is not None:
            pulumi.set(__self__, "error_codes", error_codes)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if filter_by_url is not None:
            pulumi.set(__self__, "filter_by_url", filter_by_url)
        if impact_apdex is not None:
            pulumi.set(__self__, "impact_apdex", impact_apdex)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def capture(self) -> Optional[bool]:
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="considerBlockedRequests")
    def consider_blocked_requests(self) -> Optional[bool]:
        return pulumi.get(self, "consider_blocked_requests")

    @property
    @pulumi.getter(name="considerForAi")
    def consider_for_ai(self) -> Optional[bool]:
        return pulumi.get(self, "consider_for_ai")

    @property
    @pulumi.getter(name="considerUnknownErrorCode")
    def consider_unknown_error_code(self) -> Optional[bool]:
        return pulumi.get(self, "consider_unknown_error_code")

    @property
    @pulumi.getter(name="errorCodes")
    def error_codes(self) -> Optional[str]:
        return pulumi.get(self, "error_codes")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="filterByUrl")
    def filter_by_url(self) -> Optional[bool]:
        return pulumi.get(self, "filter_by_url")

    @property
    @pulumi.getter(name="impactApdex")
    def impact_apdex(self) -> Optional[bool]:
        return pulumi.get(self, "impact_apdex")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class AutotagEntitySelectorBasedRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagEntitySelectorBasedRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagEntitySelectorBasedRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagEntitySelectorBasedRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 normalization: Optional[str] = None,
                 selector: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value_format: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class AutotagRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagationTypes":
            suggest = "propagation_types"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.AutotagRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 normalization: Optional[str] = None,
                 propagation_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None,
                 value_format: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if propagation_types is not None:
            pulumi.set(__self__, "propagation_types", propagation_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.AutotagRuleCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="propagationTypes")
    def propagation_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "propagation_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[str]:
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AutotagRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.AutotagRuleConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.AutotagRuleConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.AutotagRuleConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.AutotagRuleConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.AutotagRuleConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.AutotagRuleConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.AutotagRuleConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.AutotagRuleConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.AutotagRuleConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.AutotagRuleConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.AutotagRuleConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.AutotagRuleConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.AutotagRuleConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.AutotagRuleConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.AutotagRuleConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.AutotagRuleConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.AutotagRuleConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.AutotagRuleConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.AutotagRuleConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.AutotagRuleConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.AutotagRuleConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.AutotagRuleConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.AutotagRuleConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.AutotagRuleConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.AutotagRuleConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.AutotagRuleConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.AutotagRuleConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.AutotagRuleConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.AutotagRuleConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.AutotagRuleConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.AutotagRuleConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.AutotagRuleConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.AutotagRuleConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.AutotagRuleConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.AutotagRuleConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.AutotagRuleConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.AutotagRuleConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.AutotagRuleConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.AutotagRuleConditionTag']] = None,
                 teches: Optional[Sequence['outputs.AutotagRuleConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.AutotagRuleConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.AutotagRuleConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.AutotagRuleConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.AutotagRuleConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.AutotagRuleConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.AutotagRuleConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.AutotagRuleConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.AutotagRuleConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.AutotagRuleConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.AutotagRuleConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.AutotagRuleConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.AutotagRuleConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.AutotagRuleConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.AutotagRuleConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.AutotagRuleConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.AutotagRuleConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.AutotagRuleConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.AutotagRuleConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AutotagRuleConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.AutotagRuleConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AutotagRuleConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AutotagRuleConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.AutotagRuleConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.AutotagRuleConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutotagRuleConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutotagRuleConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutotagRuleConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutotagRuleConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class AwsCredentialsAuthenticationData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountId":
            suggest = "account_id"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "iamRole":
            suggest = "iam_role"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCredentialsAuthenticationData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCredentialsAuthenticationData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCredentialsAuthenticationData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 account_id: Optional[str] = None,
                 external_id: Optional[str] = None,
                 iam_role: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str access_key: the access key
        :param str account_id: the ID of the Amazon account
        :param str external_id: the external ID token for setting an IAM role. You can obtain it with the `GET /aws/iamExternalId` request
        :param str iam_role: the IAM role to be used by Dynatrace to get monitoring data
        :param str secret_key: the secret access key
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        the access key
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        the ID of the Amazon account
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        the external ID token for setting an IAM role. You can obtain it with the `GET /aws/iamExternalId` request
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional[str]:
        """
        the IAM role to be used by Dynatrace to get monitoring data
        """
        return pulumi.get(self, "iam_role")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        the secret access key
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsSupportingServicesToMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoredMetrics":
            suggest = "monitored_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCredentialsSupportingServicesToMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCredentialsSupportingServicesToMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCredentialsSupportingServicesToMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitored_metrics: Optional[Sequence['outputs.AwsCredentialsSupportingServicesToMonitorMonitoredMetric']] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AwsCredentialsSupportingServicesToMonitorMonitoredMetricArgs'] monitored_metrics: a list of metrics to be monitored for this service
        :param str name: the name of the supporting service
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if monitored_metrics is not None:
            pulumi.set(__self__, "monitored_metrics", monitored_metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="monitoredMetrics")
    def monitored_metrics(self) -> Optional[Sequence['outputs.AwsCredentialsSupportingServicesToMonitorMonitoredMetric']]:
        """
        a list of metrics to be monitored for this service
        """
        return pulumi.get(self, "monitored_metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the supporting service
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsSupportingServicesToMonitorMonitoredMetric(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 statistic: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AwsCredentialsTagsToMonitor(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: the key of the AWS tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: the value of the AWS tag
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the key of the AWS tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        the value of the AWS tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureCredentialsMonitorOnlyExcludingTagPair(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureCredentialsMonitorOnlyTagPair(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the tag.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        :param str value: The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.   If set to `null`, then resources with any value of the tag are monitored.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureCredentialsSupportingService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoredMetrics":
            suggest = "monitored_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCredentialsSupportingService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCredentialsSupportingService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCredentialsSupportingService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitored_metrics: Optional[Sequence['outputs.AzureCredentialsSupportingServiceMonitoredMetric']] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence['AzureCredentialsSupportingServiceMonitoredMetricArgs'] monitored_metrics: A list of Azure tags to be monitored.  You can specify up to 10 tags. A resource tagged with *any* of the specified tags is monitored.  Only applicable when the **monitorOnlyTaggedEntities** parameter is set to `true`
        :param str name: The name of the supporting service.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if monitored_metrics is not None:
            pulumi.set(__self__, "monitored_metrics", monitored_metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="monitoredMetrics")
    def monitored_metrics(self) -> Optional[Sequence['outputs.AzureCredentialsSupportingServiceMonitoredMetric']]:
        """
        A list of Azure tags to be monitored.  You can specify up to 10 tags. A resource tagged with *any* of the specified tags is monitored.  Only applicable when the **monitorOnlyTaggedEntities** parameter is set to `true`
        """
        return pulumi.get(self, "monitored_metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the supporting service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class AzureCredentialsSupportingServiceMonitoredMetric(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class BrowserMonitorAnomalyDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadingTimeThresholds":
            suggest = "loading_time_thresholds"
        elif key == "outageHandlings":
            suggest = "outage_handlings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loading_time_thresholds: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThreshold']] = None,
                 outage_handlings: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandling']] = None):
        """
        :param Sequence['BrowserMonitorAnomalyDetectionLoadingTimeThresholdArgs'] loading_time_thresholds: Thresholds for loading times
        :param Sequence['BrowserMonitorAnomalyDetectionOutageHandlingArgs'] outage_handlings: Outage handling configuration
        """
        if loading_time_thresholds is not None:
            pulumi.set(__self__, "loading_time_thresholds", loading_time_thresholds)
        if outage_handlings is not None:
            pulumi.set(__self__, "outage_handlings", outage_handlings)

    @property
    @pulumi.getter(name="loadingTimeThresholds")
    def loading_time_thresholds(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThreshold']]:
        """
        Thresholds for loading times
        """
        return pulumi.get(self, "loading_time_thresholds")

    @property
    @pulumi.getter(name="outageHandlings")
    def outage_handlings(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandling']]:
        """
        Outage handling configuration
        """
        return pulumi.get(self, "outage_handlings")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 thresholds: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold']]:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThresholdThreshold(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']):
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueMs":
            suggest = "value_ms"
        elif key == "eventIndex":
            suggest = "event_index"
        elif key == "requestIndex":
            suggest = "request_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_ms: int,
                 event_index: Optional[int] = None,
                 request_index: Optional[int] = None,
                 type: Optional[str] = None):
        pulumi.set(__self__, "value_ms", value_ms)
        if event_index is not None:
            pulumi.set(__self__, "event_index", event_index)
        if request_index is not None:
            pulumi.set(__self__, "request_index", request_index)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="valueMs")
    def value_ms(self) -> int:
        return pulumi.get(self, "value_ms")

    @property
    @pulumi.getter(name="eventIndex")
    def event_index(self) -> Optional[int]:
        return pulumi.get(self, "event_index")

    @property
    @pulumi.getter(name="requestIndex")
    def request_index(self) -> Optional[int]:
        return pulumi.get(self, "request_index")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionOutageHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalOutage":
            suggest = "global_outage"
        elif key == "localOutage":
            suggest = "local_outage"
        elif key == "localOutagePolicies":
            suggest = "local_outage_policies"
        elif key == "retryOnError":
            suggest = "retry_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionOutageHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_outage: Optional[bool] = None,
                 local_outage: Optional[bool] = None,
                 local_outage_policies: Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']] = None,
                 retry_on_error: Optional[bool] = None):
        if global_outage is not None:
            pulumi.set(__self__, "global_outage", global_outage)
        if local_outage is not None:
            pulumi.set(__self__, "local_outage", local_outage)
        if local_outage_policies is not None:
            pulumi.set(__self__, "local_outage_policies", local_outage_policies)
        if retry_on_error is not None:
            pulumi.set(__self__, "retry_on_error", retry_on_error)

    @property
    @pulumi.getter(name="globalOutage")
    def global_outage(self) -> Optional[bool]:
        return pulumi.get(self, "global_outage")

    @property
    @pulumi.getter(name="localOutage")
    def local_outage(self) -> Optional[bool]:
        return pulumi.get(self, "local_outage")

    @property
    @pulumi.getter(name="localOutagePolicies")
    def local_outage_policies(self) -> Optional[Sequence['outputs.BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']]:
        return pulumi.get(self, "local_outage_policies")

    @property
    @pulumi.getter(name="retryOnError")
    def retry_on_error(self) -> Optional[bool]:
        return pulumi.get(self, "retry_on_error")


@pulumi.output_type
class BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedLocations":
            suggest = "affected_locations"
        elif key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affected_locations: int,
                 consecutive_runs: int):
        pulumi.set(__self__, "affected_locations", affected_locations)
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> int:
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class BrowserMonitorKeyPerformanceMetrics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadActionKpm":
            suggest = "load_action_kpm"
        elif key == "xhrActionKpm":
            suggest = "xhr_action_kpm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorKeyPerformanceMetrics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorKeyPerformanceMetrics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorKeyPerformanceMetrics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_action_kpm: str,
                 xhr_action_kpm: str):
        """
        :param str load_action_kpm: Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
        :param str xhr_action_kpm: Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
        """
        pulumi.set(__self__, "load_action_kpm", load_action_kpm)
        pulumi.set(__self__, "xhr_action_kpm", xhr_action_kpm)

    @property
    @pulumi.getter(name="loadActionKpm")
    def load_action_kpm(self) -> str:
        """
        Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
        """
        return pulumi.get(self, "load_action_kpm")

    @property
    @pulumi.getter(name="xhrActionKpm")
    def xhr_action_kpm(self) -> str:
        """
        Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
        """
        return pulumi.get(self, "xhr_action_kpm")


@pulumi.output_type
class BrowserMonitorScript(dict):
    def __init__(__self__, *,
                 type: str,
                 configuration: Optional['outputs.BrowserMonitorScriptConfiguration'] = None,
                 events: Optional['outputs.BrowserMonitorScriptEvents'] = None):
        """
        :param str type: The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
        :param 'BrowserMonitorScriptConfigurationArgs' configuration: The setup of the monitor
        :param 'BrowserMonitorScriptEventsArgs' events: Steps of the clickpath—the first step must always be of the `navigate` type
        """
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if events is not None:
            pulumi.set(__self__, "events", events)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.BrowserMonitorScriptConfiguration']:
        """
        The setup of the monitor
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def events(self) -> Optional['outputs.BrowserMonitorScriptEvents']:
        """
        Steps of the clickpath—the first step must always be of the `navigate` type
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class BrowserMonitorScriptConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassCsp":
            suggest = "bypass_csp"
        elif key == "disableWebSecurity":
            suggest = "disable_web_security"
        elif key == "ignoredErrorCodes":
            suggest = "ignored_error_codes"
        elif key == "javascriptSetttings":
            suggest = "javascript_setttings"
        elif key == "monitorFrames":
            suggest = "monitor_frames"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: Optional['outputs.BrowserMonitorScriptConfigurationBandwidth'] = None,
                 blocks: Optional[Sequence[str]] = None,
                 bypass_csp: Optional[bool] = None,
                 cookies: Optional['outputs.BrowserMonitorScriptConfigurationCookies'] = None,
                 device: Optional['outputs.BrowserMonitorScriptConfigurationDevice'] = None,
                 disable_web_security: Optional[bool] = None,
                 headers: Optional['outputs.BrowserMonitorScriptConfigurationHeaders'] = None,
                 ignored_error_codes: Optional['outputs.BrowserMonitorScriptConfigurationIgnoredErrorCodes'] = None,
                 javascript_setttings: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttings'] = None,
                 monitor_frames: Optional[bool] = None,
                 user_agent: Optional[str] = None):
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)
        if bypass_csp is not None:
            pulumi.set(__self__, "bypass_csp", bypass_csp)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if disable_web_security is not None:
            pulumi.set(__self__, "disable_web_security", disable_web_security)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ignored_error_codes is not None:
            pulumi.set(__self__, "ignored_error_codes", ignored_error_codes)
        if javascript_setttings is not None:
            pulumi.set(__self__, "javascript_setttings", javascript_setttings)
        if monitor_frames is not None:
            pulumi.set(__self__, "monitor_frames", monitor_frames)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional['outputs.BrowserMonitorScriptConfigurationBandwidth']:
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter
    def blocks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "blocks")

    @property
    @pulumi.getter(name="bypassCsp")
    def bypass_csp(self) -> Optional[bool]:
        return pulumi.get(self, "bypass_csp")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.BrowserMonitorScriptConfigurationCookies']:
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def device(self) -> Optional['outputs.BrowserMonitorScriptConfigurationDevice']:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="disableWebSecurity")
    def disable_web_security(self) -> Optional[bool]:
        return pulumi.get(self, "disable_web_security")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.BrowserMonitorScriptConfigurationHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ignoredErrorCodes")
    def ignored_error_codes(self) -> Optional['outputs.BrowserMonitorScriptConfigurationIgnoredErrorCodes']:
        return pulumi.get(self, "ignored_error_codes")

    @property
    @pulumi.getter(name="javascriptSetttings")
    def javascript_setttings(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttings']:
        return pulumi.get(self, "javascript_setttings")

    @property
    @pulumi.getter(name="monitorFrames")
    def monitor_frames(self) -> Optional[bool]:
        return pulumi.get(self, "monitor_frames")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class BrowserMonitorScriptConfigurationBandwidth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkType":
            suggest = "network_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationBandwidth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationBandwidth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationBandwidth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 download: Optional[int] = None,
                 latency: Optional[int] = None,
                 network_type: Optional[str] = None,
                 upload: Optional[int] = None):
        if download is not None:
            pulumi.set(__self__, "download", download)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)

    @property
    @pulumi.getter
    def download(self) -> Optional[int]:
        return pulumi.get(self, "download")

    @property
    @pulumi.getter
    def latency(self) -> Optional[int]:
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[str]:
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def upload(self) -> Optional[int]:
        return pulumi.get(self, "upload")


@pulumi.output_type
class BrowserMonitorScriptConfigurationCookies(dict):
    def __init__(__self__, *,
                 cookies: Sequence['outputs.BrowserMonitorScriptConfigurationCookiesCookie']):
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.BrowserMonitorScriptConfigurationCookiesCookie']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptConfigurationCookiesCookie(dict):
    def __init__(__self__, *,
                 domain: str,
                 name: str,
                 value: str,
                 path: Optional[str] = None):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class BrowserMonitorScriptConfigurationDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "touchEnabled":
            suggest = "touch_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: Optional[int] = None,
                 mobile: Optional[bool] = None,
                 name: Optional[str] = None,
                 orientation: Optional[str] = None,
                 scale_factor: Optional[int] = None,
                 touch_enabled: Optional[bool] = None,
                 width: Optional[int] = None):
        if height is not None:
            pulumi.set(__self__, "height", height)
        if mobile is not None:
            pulumi.set(__self__, "mobile", mobile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if orientation is not None:
            pulumi.set(__self__, "orientation", orientation)
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if touch_enabled is not None:
            pulumi.set(__self__, "touch_enabled", touch_enabled)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def mobile(self) -> Optional[bool]:
        return pulumi.get(self, "mobile")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def orientation(self) -> Optional[str]:
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter(name="scaleFactor")
    def scale_factor(self) -> Optional[int]:
        return pulumi.get(self, "scale_factor")

    @property
    @pulumi.getter(name="touchEnabled")
    def touch_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "touch_enabled")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        return pulumi.get(self, "width")


@pulumi.output_type
class BrowserMonitorScriptConfigurationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.BrowserMonitorScriptConfigurationHeadersHeader'],
                 restrictions: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "headers", headers)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.BrowserMonitorScriptConfigurationHeadersHeader']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class BrowserMonitorScriptConfigurationHeadersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptConfigurationIgnoredErrorCodes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"
        elif key == "matchingDocumentRequests":
            suggest = "matching_document_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationIgnoredErrorCodes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationIgnoredErrorCodes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationIgnoredErrorCodes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_codes: str,
                 matching_document_requests: Optional[str] = None):
        pulumi.set(__self__, "status_codes", status_codes)
        if matching_document_requests is not None:
            pulumi.set(__self__, "matching_document_requests", matching_document_requests)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> str:
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter(name="matchingDocumentRequests")
    def matching_document_requests(self) -> Optional[str]:
        return pulumi.get(self, "matching_document_requests")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProperties":
            suggest = "custom_properties"
        elif key == "timeoutSettings":
            suggest = "timeout_settings"
        elif key == "visuallyCompleteOptions":
            suggest = "visually_complete_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_properties: Optional[str] = None,
                 timeout_settings: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings'] = None,
                 visually_complete_options: Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions'] = None):
        if custom_properties is not None:
            pulumi.set(__self__, "custom_properties", custom_properties)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if visually_complete_options is not None:
            pulumi.set(__self__, "visually_complete_options", visually_complete_options)

    @property
    @pulumi.getter(name="customProperties")
    def custom_properties(self) -> Optional[str]:
        return pulumi.get(self, "custom_properties")

    @property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings']:
        return pulumi.get(self, "timeout_settings")

    @property
    @pulumi.getter(name="visuallyCompleteOptions")
    def visually_complete_options(self) -> Optional['outputs.BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions']:
        return pulumi.get(self, "visually_complete_options")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionLimit":
            suggest = "action_limit"
        elif key == "totalTimeout":
            suggest = "total_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_limit: int,
                 total_timeout: int):
        pulumi.set(__self__, "action_limit", action_limit)
        pulumi.set(__self__, "total_timeout", total_timeout)

    @property
    @pulumi.getter(name="actionLimit")
    def action_limit(self) -> int:
        return pulumi.get(self, "action_limit")

    @property
    @pulumi.getter(name="totalTimeout")
    def total_timeout(self) -> int:
        return pulumi.get(self, "total_timeout")


@pulumi.output_type
class BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageSizeThreshold":
            suggest = "image_size_threshold"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "mutationTimeout":
            suggest = "mutation_timeout"
        elif key == "excludedElements":
            suggest = "excluded_elements"
        elif key == "excludedUrls":
            suggest = "excluded_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_size_threshold: int,
                 inactivity_timeout: int,
                 mutation_timeout: int,
                 excluded_elements: Optional[Sequence[str]] = None,
                 excluded_urls: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "image_size_threshold", image_size_threshold)
        pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        pulumi.set(__self__, "mutation_timeout", mutation_timeout)
        if excluded_elements is not None:
            pulumi.set(__self__, "excluded_elements", excluded_elements)
        if excluded_urls is not None:
            pulumi.set(__self__, "excluded_urls", excluded_urls)

    @property
    @pulumi.getter(name="imageSizeThreshold")
    def image_size_threshold(self) -> int:
        return pulumi.get(self, "image_size_threshold")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> int:
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="mutationTimeout")
    def mutation_timeout(self) -> int:
        return pulumi.get(self, "mutation_timeout")

    @property
    @pulumi.getter(name="excludedElements")
    def excluded_elements(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_elements")

    @property
    @pulumi.getter(name="excludedUrls")
    def excluded_urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_urls")


@pulumi.output_type
class BrowserMonitorScriptEvents(dict):
    def __init__(__self__, *,
                 events: Optional[Sequence['outputs.BrowserMonitorScriptEventsEvent']] = None):
        if events is not None:
            pulumi.set(__self__, "events", events)

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEvent']]:
        return pulumi.get(self, "events")


@pulumi.output_type
class BrowserMonitorScriptEventsEvent(dict):
    def __init__(__self__, *,
                 description: str,
                 click: Optional['outputs.BrowserMonitorScriptEventsEventClick'] = None,
                 cookie: Optional['outputs.BrowserMonitorScriptEventsEventCookie'] = None,
                 javascript: Optional['outputs.BrowserMonitorScriptEventsEventJavascript'] = None,
                 keystrokes: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokes'] = None,
                 navigate: Optional['outputs.BrowserMonitorScriptEventsEventNavigate'] = None,
                 select: Optional['outputs.BrowserMonitorScriptEventsEventSelect'] = None,
                 tap: Optional['outputs.BrowserMonitorScriptEventsEventTap'] = None):
        pulumi.set(__self__, "description", description)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if javascript is not None:
            pulumi.set(__self__, "javascript", javascript)
        if keystrokes is not None:
            pulumi.set(__self__, "keystrokes", keystrokes)
        if navigate is not None:
            pulumi.set(__self__, "navigate", navigate)
        if select is not None:
            pulumi.set(__self__, "select", select)
        if tap is not None:
            pulumi.set(__self__, "tap", tap)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def click(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClick']:
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.BrowserMonitorScriptEventsEventCookie']:
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter
    def javascript(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascript']:
        return pulumi.get(self, "javascript")

    @property
    @pulumi.getter
    def keystrokes(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokes']:
        return pulumi.get(self, "keystrokes")

    @property
    @pulumi.getter
    def navigate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigate']:
        return pulumi.get(self, "navigate")

    @property
    @pulumi.getter
    def select(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelect']:
        return pulumi.get(self, "select")

    @property
    @pulumi.getter
    def tap(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTap']:
        return pulumi.get(self, "tap")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClick(dict):
    def __init__(__self__, *,
                 button: int,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventClickValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventClickWait'] = None):
        pulumi.set(__self__, "button", button)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def button(self) -> int:
        return pulumi.get(self, "button")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventClickWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventClickWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventClickWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventClickWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookie(dict):
    def __init__(__self__, *,
                 cookies: 'outputs.BrowserMonitorScriptEventsEventCookieCookies'):
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> 'outputs.BrowserMonitorScriptEventsEventCookieCookies':
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookieCookies(dict):
    def __init__(__self__, *,
                 cookies: Sequence['outputs.BrowserMonitorScriptEventsEventCookieCookiesCookie']):
        pulumi.set(__self__, "cookies", cookies)

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventCookieCookiesCookie']:
        return pulumi.get(self, "cookies")


@pulumi.output_type
class BrowserMonitorScriptEventsEventCookieCookiesCookie(dict):
    def __init__(__self__, *,
                 domain: str,
                 name: str,
                 value: str,
                 path: Optional[str] = None):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascript(dict):
    def __init__(__self__, *,
                 code: str,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptTarget'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWait'] = None):
        pulumi.set(__self__, "code", code)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def code(self) -> str:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventJavascriptWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventJavascriptWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventJavascriptWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventJavascriptWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simulateBlurEvent":
            suggest = "simulate_blur_event"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesCredential'] = None,
                 masked: Optional[bool] = None,
                 simulate_blur_event: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesTarget'] = None,
                 text: Optional[str] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWait'] = None):
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if masked is not None:
            pulumi.set(__self__, "masked", masked)
        if simulate_blur_event is not None:
            pulumi.set(__self__, "simulate_blur_event", simulate_blur_event)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def credential(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesCredential']:
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter
    def masked(self) -> Optional[bool]:
        return pulumi.get(self, "masked")

    @property
    @pulumi.getter(name="simulateBlurEvent")
    def simulate_blur_event(self) -> Optional[bool]:
        return pulumi.get(self, "simulate_blur_event")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: str,
                 vault_id: str):
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventKeystrokesWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventKeystrokesWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventKeystrokesWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigate(dict):
    def __init__(__self__, *,
                 url: str,
                 authentication: Optional['outputs.BrowserMonitorScriptEventsEventNavigateAuthentication'] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWait'] = None):
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateAuthentication']:
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateAuthentication(dict):
    def __init__(__self__, *,
                 creds: str,
                 type: str):
        pulumi.set(__self__, "creds", creds)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def creds(self) -> str:
        return pulumi.get(self, "creds")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventNavigateWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventNavigateWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventNavigateWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventNavigateWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelect(dict):
    def __init__(__self__, *,
                 selections: 'outputs.BrowserMonitorScriptEventsEventSelectSelections',
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventSelectValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventSelectWait'] = None):
        pulumi.set(__self__, "selections", selections)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def selections(self) -> 'outputs.BrowserMonitorScriptEventsEventSelectSelections':
        return pulumi.get(self, "selections")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectSelections(dict):
    def __init__(__self__, *,
                 options: Sequence['outputs.BrowserMonitorScriptEventsEventSelectSelectionsOption']):
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def options(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectSelectionsOption']:
        return pulumi.get(self, "options")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectSelectionsOption(dict):
    def __init__(__self__, *,
                 index: int,
                 value: str):
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def index(self) -> int:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventSelectWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventSelectWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventSelectWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventSelectWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTap(dict):
    def __init__(__self__, *,
                 button: int,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapTarget'] = None,
                 validate: Optional['outputs.BrowserMonitorScriptEventsEventTapValidate'] = None,
                 wait: Optional['outputs.BrowserMonitorScriptEventsEventTapWait'] = None):
        pulumi.set(__self__, "button", button)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if validate is not None:
            pulumi.set(__self__, "validate", validate)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def button(self) -> int:
        return pulumi.get(self, "button")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapTarget']:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def validate(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapValidate']:
        return pulumi.get(self, "validate")

    @property
    @pulumi.getter
    def wait(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWait']:
        return pulumi.get(self, "wait")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidate(dict):
    def __init__(__self__, *,
                 validations: Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidation']):
        pulumi.set(__self__, "validations", validations)

    @property
    @pulumi.getter
    def validations(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidation']:
        return pulumi.get(self, "validations")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapValidateValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapValidateValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapValidateValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapValidateValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWait(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitFor":
            suggest = "wait_for"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapWait. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapWait.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapWait.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_for: str,
                 milliseconds: Optional[int] = None,
                 timeout: Optional[int] = None,
                 validation: Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidation'] = None):
        pulumi.set(__self__, "wait_for", wait_for)
        if milliseconds is not None:
            pulumi.set(__self__, "milliseconds", milliseconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter(name="waitFor")
    def wait_for(self) -> str:
        return pulumi.get(self, "wait_for")

    @property
    @pulumi.getter
    def milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failIfFound":
            suggest = "fail_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserMonitorScriptEventsEventTapWaitValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserMonitorScriptEventsEventTapWaitValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserMonitorScriptEventsEventTapWaitValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fail_if_found: Optional[bool] = None,
                 match: Optional[str] = None,
                 regex: Optional[bool] = None,
                 target: Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTarget'] = None):
        pulumi.set(__self__, "type", type)
        if fail_if_found is not None:
            pulumi.set(__self__, "fail_if_found", fail_if_found)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failIfFound")
    def fail_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "fail_if_found")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTarget']:
        return pulumi.get(self, "target")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTarget(dict):
    def __init__(__self__, *,
                 locators: Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator']] = None,
                 window: Optional[str] = None):
        if locators is not None:
            pulumi.set(__self__, "locators", locators)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def locators(self) -> Optional[Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator']]:
        return pulumi.get(self, "locators")

    @property
    @pulumi.getter
    def window(self) -> Optional[str]:
        return pulumi.get(self, "window")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTargetLocator(dict):
    def __init__(__self__, *,
                 locators: Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator']):
        pulumi.set(__self__, "locators", locators)

    @property
    @pulumi.getter
    def locators(self) -> Sequence['outputs.BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator']:
        return pulumi.get(self, "locators")


@pulumi.output_type
class BrowserMonitorScriptEventsEventTapWaitValidationTargetLocatorLocator(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BrowserMonitorTag(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.BrowserMonitorTagTag']] = None):
        """
        :param Sequence['BrowserMonitorTagTagArgs'] tags: Tag with source of a Dynatrace entity.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.BrowserMonitorTagTag']]:
        """
        Tag with source of a Dynatrace entity.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BrowserMonitorTagTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 source: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.CalculatedServiceMetricConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.CalculatedServiceMetricConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class CalculatedServiceMetricConditionCondition(dict):
    def __init__(__self__, *,
                 attribute: str,
                 comparison: 'outputs.CalculatedServiceMetricConditionConditionComparison'):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "comparison", comparison)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def comparison(self) -> 'outputs.CalculatedServiceMetricConditionConditionComparison':
        return pulumi.get(self, "comparison")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "esbInputNodeType":
            suggest = "esb_input_node_type"
        elif key == "failedState":
            suggest = "failed_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "fastString":
            suggest = "fast_string"
        elif key == "flawState":
            suggest = "flaw_state"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "httpStatusClass":
            suggest = "http_status_class"
        elif key == "iibInputNodeType":
            suggest = "iib_input_node_type"
        elif key == "numberRequestAttribute":
            suggest = "number_request_attribute"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "stringRequestAttribute":
            suggest = "string_request_attribute"
        elif key == "zosCallType":
            suggest = "zos_call_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonBoolean'] = None,
                 esb_input_node_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType'] = None,
                 failed_state: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailedState'] = None,
                 failure_reason: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailureReason'] = None,
                 fast_string: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFastString'] = None,
                 flaw_state: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFlawState'] = None,
                 generic: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonGeneric'] = None,
                 http_method: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpMethod'] = None,
                 http_status_class: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpStatusClass'] = None,
                 iib_input_node_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonIibInputNodeType'] = None,
                 negate: Optional[bool] = None,
                 number: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumber'] = None,
                 number_request_attribute: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute'] = None,
                 service_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonServiceType'] = None,
                 string: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonString'] = None,
                 string_request_attribute: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute'] = None,
                 tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTag'] = None,
                 zos_call_type: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonZosCallType'] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if esb_input_node_type is not None:
            pulumi.set(__self__, "esb_input_node_type", esb_input_node_type)
        if failed_state is not None:
            pulumi.set(__self__, "failed_state", failed_state)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if fast_string is not None:
            pulumi.set(__self__, "fast_string", fast_string)
        if flaw_state is not None:
            pulumi.set(__self__, "flaw_state", flaw_state)
        if generic is not None:
            pulumi.set(__self__, "generic", generic)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_status_class is not None:
            pulumi.set(__self__, "http_status_class", http_status_class)
        if iib_input_node_type is not None:
            pulumi.set(__self__, "iib_input_node_type", iib_input_node_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if number_request_attribute is not None:
            pulumi.set(__self__, "number_request_attribute", number_request_attribute)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_request_attribute is not None:
            pulumi.set(__self__, "string_request_attribute", string_request_attribute)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if zos_call_type is not None:
            pulumi.set(__self__, "zos_call_type", zos_call_type)

    @property
    @pulumi.getter
    def boolean(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonBoolean']:
        return pulumi.get(self, "boolean")

    @property
    @pulumi.getter(name="esbInputNodeType")
    def esb_input_node_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType']:
        return pulumi.get(self, "esb_input_node_type")

    @property
    @pulumi.getter(name="failedState")
    def failed_state(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailedState']:
        return pulumi.get(self, "failed_state")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFailureReason']:
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="fastString")
    def fast_string(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFastString']:
        return pulumi.get(self, "fast_string")

    @property
    @pulumi.getter(name="flawState")
    def flaw_state(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonFlawState']:
        return pulumi.get(self, "flaw_state")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonGeneric']:
        return pulumi.get(self, "generic")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpMethod']:
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="httpStatusClass")
    def http_status_class(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonHttpStatusClass']:
        return pulumi.get(self, "http_status_class")

    @property
    @pulumi.getter(name="iibInputNodeType")
    def iib_input_node_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonIibInputNodeType']:
        return pulumi.get(self, "iib_input_node_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def number(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumber']:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="numberRequestAttribute")
    def number_request_attribute(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute']:
        return pulumi.get(self, "number_request_attribute")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonServiceType']:
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def string(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonString']:
        return pulumi.get(self, "string")

    @property
    @pulumi.getter(name="stringRequestAttribute")
    def string_request_attribute(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute']:
        return pulumi.get(self, "string_request_attribute")

    @property
    @pulumi.getter
    def tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTag']:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="zosCallType")
    def zos_call_type(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonZosCallType']:
        return pulumi.get(self, "zos_call_type")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonBoolean(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[bool] = None,
                 values: Optional[Sequence[bool]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[bool]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonEsbInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFailedState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFailureReason(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFastString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonFastString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonFastString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonFastString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonFlawState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonHttpMethod(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonHttpStatusClass(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonIibInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumber(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        pulumi.set(__self__, "request_attribute", request_attribute)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonNumberRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonServiceType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 case_sensitive: Optional[bool] = None,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "request_attribute", request_attribute)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonStringRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTag(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValue'] = None,
                 values: Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValues'] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValue']:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional['outputs.CalculatedServiceMetricConditionConditionComparisonTagValues']:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.CalculatedServiceMetricConditionConditionComparisonTagValuesValue']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.CalculatedServiceMetricConditionConditionComparisonTagValuesValue']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonTagValuesValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricConditionConditionComparisonZosCallType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topX":
            suggest = "top_x"
        elif key == "topXAggregation":
            suggest = "top_x_aggregation"
        elif key == "topXDirection":
            suggest = "top_x_direction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 name: str,
                 top_x: int,
                 top_x_aggregation: str,
                 top_x_direction: str,
                 placeholders: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholders'] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "top_x", top_x)
        pulumi.set(__self__, "top_x_aggregation", top_x_aggregation)
        pulumi.set(__self__, "top_x_direction", top_x_direction)
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="topX")
    def top_x(self) -> int:
        return pulumi.get(self, "top_x")

    @property
    @pulumi.getter(name="topXAggregation")
    def top_x_aggregation(self) -> str:
        return pulumi.get(self, "top_x_aggregation")

    @property
    @pulumi.getter(name="topXDirection")
    def top_x_direction(self) -> str:
        return pulumi.get(self, "top_x_direction")

    @property
    @pulumi.getter
    def placeholders(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholders']:
        return pulumi.get(self, "placeholders")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Optional[Sequence['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder']] = None):
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Optional[Sequence['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder']]:
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimiterOrRegex":
            suggest = "delimiter_or_regex"
        elif key == "endDelimiter":
            suggest = "end_delimiter"
        elif key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "useFromChildCalls":
            suggest = "use_from_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 kind: str,
                 name: str,
                 aggregation: Optional[str] = None,
                 delimiter_or_regex: Optional[str] = None,
                 end_delimiter: Optional[str] = None,
                 normalization: Optional[str] = None,
                 request_attribute: Optional[str] = None,
                 source: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource'] = None,
                 unknowns: Optional[str] = None,
                 use_from_child_calls: Optional[bool] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if delimiter_or_regex is not None:
            pulumi.set(__self__, "delimiter_or_regex", delimiter_or_regex)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if use_from_child_calls is not None:
            pulumi.set(__self__, "use_from_child_calls", use_from_child_calls)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="delimiterOrRegex")
    def delimiter_or_regex(self) -> Optional[str]:
        return pulumi.get(self, "delimiter_or_regex")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="useFromChildCalls")
    def use_from_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "use_from_child_calls")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedServiceMetricDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class CalculatedServiceMetricMetricDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedServiceMetricMetricDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedServiceMetricMetricDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedServiceMetricMetricDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 request_attribute: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "request_attribute")


@pulumi.output_type
class CustomAnomaliesDimension(dict):
    def __init__(__self__, *,
                 dimensions: Optional[Sequence['outputs.CustomAnomaliesDimensionDimension']] = None,
                 entities: Optional[Sequence['outputs.CustomAnomaliesDimensionEntity']] = None,
                 strings: Optional[Sequence['outputs.CustomAnomaliesDimensionString']] = None):
        """
        :param Sequence['CustomAnomaliesDimensionDimensionArgs'] dimensions: A generic definition for a filter
        :param Sequence['CustomAnomaliesDimensionEntityArgs'] entities: A filter for the metrics entity dimensions
        :param Sequence['CustomAnomaliesDimensionStringArgs'] strings: A filter for the metrics string dimensions
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionDimension']]:
        """
        A generic definition for a filter
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionEntity']]:
        """
        A filter for the metrics entity dimensions
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.CustomAnomaliesDimensionString']]:
        """
        A filter for the metrics string dimensions
        """
        return pulumi.get(self, "strings")


@pulumi.output_type
class CustomAnomaliesDimensionDimension(dict):
    def __init__(__self__, *,
                 type: str,
                 key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionEntity(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesDimensionEntityFilter',
                 key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesDimensionEntityFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionEntityFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesDimensionString(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesDimensionStringFilter',
                 key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesDimensionStringFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesDimensionStringFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDeviceGroupNames":
            suggest = "custom_device_group_names"
        elif key == "hostGroupNames":
            suggest = "host_group_names"
        elif key == "hostNames":
            suggest = "host_names"
        elif key == "managementZones":
            suggest = "management_zones"
        elif key == "processGroupIds":
            suggest = "process_group_ids"
        elif key == "processGroupNames":
            suggest = "process_group_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_device_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeCustomDeviceGroupName']] = None,
                 entities: Optional[Sequence['outputs.CustomAnomaliesScopeEntity']] = None,
                 host_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeHostGroupName']] = None,
                 host_names: Optional[Sequence['outputs.CustomAnomaliesScopeHostName']] = None,
                 management_zones: Optional[Sequence['outputs.CustomAnomaliesScopeManagementZone']] = None,
                 names: Optional[Sequence['outputs.CustomAnomaliesScopeName']] = None,
                 process_group_ids: Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupId']] = None,
                 process_group_names: Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupName']] = None,
                 scopes: Optional[Sequence['outputs.CustomAnomaliesScopeScope']] = None,
                 tags: Optional[Sequence['outputs.CustomAnomaliesScopeTag']] = None):
        """
        :param Sequence['CustomAnomaliesScopeCustomDeviceGroupNameArgs'] custom_device_group_names: A scope filter for the related custom device group name
        :param Sequence['CustomAnomaliesScopeEntityArgs'] entities: A scope filter for a monitored entity identifier
        :param Sequence['CustomAnomaliesScopeHostGroupNameArgs'] host_group_names: A scope filter for the related host group name
        :param Sequence['CustomAnomaliesScopeHostNameArgs'] host_names: A scope filter for the related host name
        :param Sequence['CustomAnomaliesScopeManagementZoneArgs'] management_zones: A scope filter for a management zone identifier
        :param Sequence['CustomAnomaliesScopeNameArgs'] names: A scope filter for a monitored entity name
        :param Sequence['CustomAnomaliesScopeProcessGroupIdArgs'] process_group_ids: A scope filter for a process group identifier
        :param Sequence['CustomAnomaliesScopeProcessGroupNameArgs'] process_group_names: A scope filter for the related process group name
        :param Sequence['CustomAnomaliesScopeScopeArgs'] scopes: A generic scope filter
        :param Sequence['CustomAnomaliesScopeTagArgs'] tags: A scope filter for tags on entities
        """
        if custom_device_group_names is not None:
            pulumi.set(__self__, "custom_device_group_names", custom_device_group_names)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if host_group_names is not None:
            pulumi.set(__self__, "host_group_names", host_group_names)
        if host_names is not None:
            pulumi.set(__self__, "host_names", host_names)
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if process_group_ids is not None:
            pulumi.set(__self__, "process_group_ids", process_group_ids)
        if process_group_names is not None:
            pulumi.set(__self__, "process_group_names", process_group_names)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="customDeviceGroupNames")
    def custom_device_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeCustomDeviceGroupName']]:
        """
        A scope filter for the related custom device group name
        """
        return pulumi.get(self, "custom_device_group_names")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeEntity']]:
        """
        A scope filter for a monitored entity identifier
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="hostGroupNames")
    def host_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeHostGroupName']]:
        """
        A scope filter for the related host group name
        """
        return pulumi.get(self, "host_group_names")

    @property
    @pulumi.getter(name="hostNames")
    def host_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeHostName']]:
        """
        A scope filter for the related host name
        """
        return pulumi.get(self, "host_names")

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeManagementZone']]:
        """
        A scope filter for a management zone identifier
        """
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeName']]:
        """
        A scope filter for a monitored entity name
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter(name="processGroupIds")
    def process_group_ids(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupId']]:
        """
        A scope filter for a process group identifier
        """
        return pulumi.get(self, "process_group_ids")

    @property
    @pulumi.getter(name="processGroupNames")
    def process_group_names(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeProcessGroupName']]:
        """
        A scope filter for the related process group name
        """
        return pulumi.get(self, "process_group_names")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeScope']]:
        """
        A generic scope filter
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CustomAnomaliesScopeTag']]:
        """
        A scope filter for tags on entities
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CustomAnomaliesScopeCustomDeviceGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeCustomDeviceGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeCustomDeviceGroupNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeCustomDeviceGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeEntity(dict):
    def __init__(__self__, *,
                 id: str,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeHostGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeHostGroupNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeHostName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeHostNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeHostNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeHostNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeManagementZone(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupId(dict):
    def __init__(__self__, *,
                 id: str,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupName(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeProcessGroupNameFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeProcessGroupNameFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeProcessGroupNameFilter(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesScopeScope(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeTag(dict):
    def __init__(__self__, *,
                 filter: 'outputs.CustomAnomaliesScopeTagFilter',
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filter", filter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.CustomAnomaliesScopeTagFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesScopeTagFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomAnomaliesStrategy(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.CustomAnomaliesStrategyAuto'] = None,
                 generics: Optional[Sequence['outputs.CustomAnomaliesStrategyGeneric']] = None,
                 static: Optional['outputs.CustomAnomaliesStrategyStatic'] = None):
        """
        :param 'CustomAnomaliesStrategyAutoArgs' auto: An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
        :param Sequence['CustomAnomaliesStrategyGenericArgs'] generics: A generic monitoring strategy
        :param 'CustomAnomaliesStrategyStaticArgs' static: A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if generics is not None:
            pulumi.set(__self__, "generics", generics)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.CustomAnomaliesStrategyAuto']:
        """
        An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def generics(self) -> Optional[Sequence['outputs.CustomAnomaliesStrategyGeneric']]:
        """
        A generic monitoring strategy
        """
        return pulumi.get(self, "generics")

    @property
    @pulumi.getter
    def static(self) -> Optional['outputs.CustomAnomaliesStrategyStatic']:
        """
        A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class CustomAnomaliesStrategyAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "signalFluctuations":
            suggest = "signal_fluctuations"
        elif key == "violatingSamples":
            suggest = "violating_samples"
        elif key == "alertingOnMissingData":
            suggest = "alerting_on_missing_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesStrategyAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesStrategyAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesStrategyAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: str,
                 dealerting_samples: int,
                 samples: int,
                 signal_fluctuations: float,
                 violating_samples: int,
                 alerting_on_missing_data: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "alert_condition", alert_condition)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "signal_fluctuations", signal_fluctuations)
        pulumi.set(__self__, "violating_samples", violating_samples)
        if alerting_on_missing_data is not None:
            pulumi.set(__self__, "alerting_on_missing_data", alerting_on_missing_data)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> str:
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> int:
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter(name="signalFluctuations")
    def signal_fluctuations(self) -> float:
        return pulumi.get(self, "signal_fluctuations")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")

    @property
    @pulumi.getter(name="alertingOnMissingData")
    def alerting_on_missing_data(self) -> Optional[bool]:
        return pulumi.get(self, "alerting_on_missing_data")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesStrategyGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomAnomaliesStrategyStatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertCondition":
            suggest = "alert_condition"
        elif key == "dealertingSamples":
            suggest = "dealerting_samples"
        elif key == "violatingSamples":
            suggest = "violating_samples"
        elif key == "alertingOnMissingData":
            suggest = "alerting_on_missing_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAnomaliesStrategyStatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAnomaliesStrategyStatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAnomaliesStrategyStatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_condition: str,
                 dealerting_samples: int,
                 samples: int,
                 threshold: float,
                 unit: str,
                 violating_samples: int,
                 alerting_on_missing_data: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "alert_condition", alert_condition)
        pulumi.set(__self__, "dealerting_samples", dealerting_samples)
        pulumi.set(__self__, "samples", samples)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "violating_samples", violating_samples)
        if alerting_on_missing_data is not None:
            pulumi.set(__self__, "alerting_on_missing_data", alerting_on_missing_data)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="alertCondition")
    def alert_condition(self) -> str:
        return pulumi.get(self, "alert_condition")

    @property
    @pulumi.getter(name="dealertingSamples")
    def dealerting_samples(self) -> int:
        return pulumi.get(self, "dealerting_samples")

    @property
    @pulumi.getter
    def samples(self) -> int:
        return pulumi.get(self, "samples")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="violatingSamples")
    def violating_samples(self) -> int:
        return pulumi.get(self, "violating_samples")

    @property
    @pulumi.getter(name="alertingOnMissingData")
    def alerting_on_missing_data(self) -> Optional[bool]:
        return pulumi.get(self, "alerting_on_missing_data")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomServiceRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomServiceRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomServiceRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomServiceRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 methods: Sequence['outputs.CustomServiceRuleMethod'],
                 annotations: Optional[Sequence[str]] = None,
                 class_: Optional['outputs.CustomServiceRuleClass'] = None,
                 file: Optional['outputs.CustomServiceRuleFile'] = None,
                 id: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool enabled: Rule enabled/disabled
        :param Sequence['CustomServiceRuleMethodArgs'] methods: methods to instrument
        :param Sequence[str] annotations: Additional annotations filter of the rule. Only classes where all listed annotations are available in the class itself or any of its superclasses are instrumented. Not applicable to PHP
        :param 'CustomServiceRuleClassArgs' class_: The fully qualified class or interface to instrument (or a substring if matching to a string). Required for Java and .NET custom services. Not applicable to PHP
        :param 'CustomServiceRuleFileArgs' file: The PHP file containing the class or methods to instrument. Required for PHP custom service. Not applicable to Java and .NET
        :param str id: The ID of the detection rule
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "methods", methods)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Rule enabled/disabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def methods(self) -> Sequence['outputs.CustomServiceRuleMethod']:
        """
        methods to instrument
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[str]]:
        """
        Additional annotations filter of the rule. Only classes where all listed annotations are available in the class itself or any of its superclasses are instrumented. Not applicable to PHP
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional['outputs.CustomServiceRuleClass']:
        """
        The fully qualified class or interface to instrument (or a substring if matching to a string). Required for Java and .NET custom services. Not applicable to PHP
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.CustomServiceRuleFile']:
        """
        The PHP file containing the class or methods to instrument. Required for PHP custom service. Not applicable to Java and .NET
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the detection rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class CustomServiceRuleClass(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional[str] = None):
        """
        :param str name: The name of the custom service, displayed in the UI
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom service, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")


@pulumi.output_type
class CustomServiceRuleFile(dict):
    def __init__(__self__, *,
                 name: str,
                 match: Optional[str] = None):
        """
        :param str name: The name of the custom service, displayed in the UI
        """
        pulumi.set(__self__, "name", name)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom service, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")


@pulumi.output_type
class CustomServiceRuleMethod(dict):
    def __init__(__self__, *,
                 name: str,
                 arguments: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 returns: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 visibility: Optional[str] = None):
        """
        :param str name: The name of the custom service, displayed in the UI
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "name", name)
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if returns is not None:
            pulumi.set(__self__, "returns", returns)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom service, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def arguments(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter
    def returns(self) -> Optional[str]:
        return pulumi.get(self, "returns")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def visibility(self) -> Optional[str]:
        return pulumi.get(self, "visibility")


@pulumi.output_type
class DashboardDashboardMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consistentColors":
            suggest = "consistent_colors"
        elif key == "dynamicFilters":
            suggest = "dynamic_filters"
        elif key == "sharingDetails":
            suggest = "sharing_details"
        elif key == "validFilterKeys":
            suggest = "valid_filter_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 owner: str,
                 consistent_colors: Optional[bool] = None,
                 dynamic_filters: Optional['outputs.DashboardDashboardMetadataDynamicFilters'] = None,
                 filter: Optional['outputs.DashboardDashboardMetadataFilter'] = None,
                 preset: Optional[bool] = None,
                 shared: Optional[bool] = None,
                 sharing_details: Optional['outputs.DashboardDashboardMetadataSharingDetails'] = None,
                 tags: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None,
                 valid_filter_keys: Optional[Sequence[str]] = None):
        """
        :param str name: the name of the dashboard
        :param str owner: the owner of the dashboard
        :param bool consistent_colors: The tile uses consistent colors when rendering its content
        :param 'DashboardDashboardMetadataDynamicFiltersArgs' dynamic_filters: Dashboard filter configuration of a dashboard
        :param 'DashboardDashboardMetadataFilterArgs' filter: Global filter Settings for the Dashboard
        :param bool preset: the dashboard is a preset (`true`) or not (`false`). Default is `false`.
        :param bool shared: the dashboard is shared (`true`) or private (`false`)
        :param 'DashboardDashboardMetadataSharingDetailsArgs' sharing_details: represents sharing configuration of a dashboard
        :param Sequence[str] tags: a set of tags assigned to the dashboard
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param Sequence[str] valid_filter_keys: a set of all possible global dashboard filters that can be applied to dashboard
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        if consistent_colors is not None:
            pulumi.set(__self__, "consistent_colors", consistent_colors)
        if dynamic_filters is not None:
            pulumi.set(__self__, "dynamic_filters", dynamic_filters)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)
        if shared is not None:
            pulumi.set(__self__, "shared", shared)
        if sharing_details is not None:
            pulumi.set(__self__, "sharing_details", sharing_details)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if valid_filter_keys is not None:
            pulumi.set(__self__, "valid_filter_keys", valid_filter_keys)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name of the dashboard
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        the owner of the dashboard
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="consistentColors")
    def consistent_colors(self) -> Optional[bool]:
        """
        The tile uses consistent colors when rendering its content
        """
        return pulumi.get(self, "consistent_colors")

    @property
    @pulumi.getter(name="dynamicFilters")
    def dynamic_filters(self) -> Optional['outputs.DashboardDashboardMetadataDynamicFilters']:
        """
        Dashboard filter configuration of a dashboard
        """
        return pulumi.get(self, "dynamic_filters")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.DashboardDashboardMetadataFilter']:
        """
        Global filter Settings for the Dashboard
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def preset(self) -> Optional[bool]:
        """
        the dashboard is a preset (`true`) or not (`false`). Default is `false`.
        """
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter
    def shared(self) -> Optional[bool]:
        """
        the dashboard is shared (`true`) or private (`false`)
        """
        return pulumi.get(self, "shared")

    @property
    @pulumi.getter(name="sharingDetails")
    def sharing_details(self) -> Optional['outputs.DashboardDashboardMetadataSharingDetails']:
        """
        represents sharing configuration of a dashboard
        """
        return pulumi.get(self, "sharing_details")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        a set of tags assigned to the dashboard
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="validFilterKeys")
    def valid_filter_keys(self) -> Optional[Sequence[str]]:
        """
        a set of all possible global dashboard filters that can be applied to dashboard
        """
        return pulumi.get(self, "valid_filter_keys")


@pulumi.output_type
class DashboardDashboardMetadataDynamicFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagSuggestionTypes":
            suggest = "tag_suggestion_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataDynamicFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataDynamicFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataDynamicFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 tag_suggestion_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "filters", filters)
        if tag_suggestion_types is not None:
            pulumi.set(__self__, "tag_suggestion_types", tag_suggestion_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="tagSuggestionTypes")
    def tag_suggestion_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_suggestion_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Optional[Sequence['outputs.DashboardDashboardMetadataFilterManagementZone']] = None,
                 timeframe: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.DashboardDashboardMetadataFilterManagementZone']]:
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataFilterManagementZone(dict):
    def __init__(__self__, *,
                 id: str,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardDashboardMetadataSharingDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkShared":
            suggest = "link_shared"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardMetadataSharingDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardMetadataSharingDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardMetadataSharingDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_shared: Optional[bool] = None,
                 published: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if link_shared is not None:
            pulumi.set(__self__, "link_shared", link_shared)
        if published is not None:
            pulumi.set(__self__, "published", published)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="linkShared")
    def link_shared(self) -> Optional[bool]:
        return pulumi.get(self, "link_shared")

    @property
    @pulumi.getter
    def published(self) -> Optional[bool]:
        return pulumi.get(self, "published")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        """
        :param str cluster_version: Dynatrace server version
        :param Sequence[int] configuration_versions: A Sorted list of the version numbers of the configuration
        :param Sequence[str] current_configuration_versions: A Sorted list of the version numbers of the configuration
        """
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        Dynatrace server version
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class DashboardSharingPermissions(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence['outputs.DashboardSharingPermissionsPermission']] = None):
        """
        :param Sequence['DashboardSharingPermissionsPermissionArgs'] permissions: Access permissions of the dashboard
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.DashboardSharingPermissionsPermission']]:
        """
        Access permissions of the dashboard
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class DashboardSharingPermissionsPermission(dict):
    def __init__(__self__, *,
                 level: str,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def level(self) -> str:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DashboardSharingPublic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSharingPublic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSharingPublic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSharingPublic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Sequence[str]):
        """
        :param Sequence[str] management_zones: A list of management zones that can display data on the publicly shared dashboard.
        """
        pulumi.set(__self__, "management_zones", management_zones)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Sequence[str]:
        """
        A list of management zones that can display data on the publicly shared dashboard.
        """
        return pulumi.get(self, "management_zones")


@pulumi.output_type
class DashboardTile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tileType":
            suggest = "tile_type"
        elif key == "assignedEntities":
            suggest = "assigned_entities"
        elif key == "chartVisible":
            suggest = "chart_visible"
        elif key == "customName":
            suggest = "custom_name"
        elif key == "excludeMaintenanceWindows":
            suggest = "exclude_maintenance_windows"
        elif key == "filterConfig":
            suggest = "filter_config"
        elif key == "nameSize":
            suggest = "name_size"
        elif key == "timeFrameShift":
            suggest = "time_frame_shift"
        elif key == "visualizationConfig":
            suggest = "visualization_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 tile_type: str,
                 assigned_entities: Optional[Sequence[str]] = None,
                 bounds: Optional['outputs.DashboardTileBounds'] = None,
                 chart_visible: Optional[bool] = None,
                 configured: Optional[bool] = None,
                 custom_name: Optional[str] = None,
                 exclude_maintenance_windows: Optional[bool] = None,
                 filter: Optional['outputs.DashboardTileFilter'] = None,
                 filter_config: Optional['outputs.DashboardTileFilterConfig'] = None,
                 limit: Optional[int] = None,
                 markdown: Optional[str] = None,
                 metric: Optional[str] = None,
                 name_size: Optional[str] = None,
                 query: Optional[str] = None,
                 time_frame_shift: Optional[str] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 visualization: Optional[str] = None,
                 visualization_config: Optional['outputs.DashboardTileVisualizationConfig'] = None):
        """
        :param str name: the name of the tile
        :param str tile_type: the type of the tile. Must be either `APPLICATION_WORLDMAP`, `RESOURCES`, `THIRD_PARTY_MOST_ACTIVE`, `UEM_CONVERSIONS_PER_GOAL`, `PROCESS_GROUPS_ONE` or `HOST` .
        :param Sequence[str] assigned_entities: The list of Dynatrace entities, assigned to the tile
        :param 'DashboardTileBoundsArgs' bounds: the position and size of a tile
        :param bool configured: The tile is configured and ready to use (`true`) or just placed on the dashboard (`false`)
        :param str custom_name: The name of the tile, set by user
        :param bool exclude_maintenance_windows: Include (`false') or exclude (`true`) maintenance windows from availability calculations
        :param 'DashboardTileFilterArgs' filter: is filter applied to a tile. It overrides dashboard's filter
        :param 'DashboardTileFilterConfigArgs' filter_config: the position and size of a tile
        :param int limit: The limit of the results, if not set will use the default value of the system
        :param str markdown: The markdown-formatted content of the tile
        :param str metric: The metric assigned to the tile
        :param str name_size: The size of the tile name. Possible values are `small`, `medium` and `large`.
        :param str query: A [user session query](https://www.dynatrace.com/support/help/shortlink/usql-info) executed by the tile
        :param str time_frame_shift: The comparison timeframe of the query. If specified, you additionally get the results of the same query with the specified time shift
        :param str type: The attribute `type` exists for backwards compatibilty. Usage is discouraged. You should use `visualization` instead.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str visualization: The visualization of the tile. Possible values are: `COLUMN_CHART`, `FUNNEL`, `LINE_CHART`, `PIE_CHART`, `SINGLE_VALUE`, `TABLE`
        :param 'DashboardTileVisualizationConfigArgs' visualization_config: Configuration of a User session query visualization tile
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tile_type", tile_type)
        if assigned_entities is not None:
            pulumi.set(__self__, "assigned_entities", assigned_entities)
        if bounds is not None:
            pulumi.set(__self__, "bounds", bounds)
        if chart_visible is not None:
            pulumi.set(__self__, "chart_visible", chart_visible)
        if configured is not None:
            pulumi.set(__self__, "configured", configured)
        if custom_name is not None:
            pulumi.set(__self__, "custom_name", custom_name)
        if exclude_maintenance_windows is not None:
            pulumi.set(__self__, "exclude_maintenance_windows", exclude_maintenance_windows)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if filter_config is not None:
            pulumi.set(__self__, "filter_config", filter_config)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if markdown is not None:
            pulumi.set(__self__, "markdown", markdown)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name_size is not None:
            pulumi.set(__self__, "name_size", name_size)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if time_frame_shift is not None:
            pulumi.set(__self__, "time_frame_shift", time_frame_shift)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if visualization is not None:
            pulumi.set(__self__, "visualization", visualization)
        if visualization_config is not None:
            pulumi.set(__self__, "visualization_config", visualization_config)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name of the tile
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tileType")
    def tile_type(self) -> str:
        """
        the type of the tile. Must be either `APPLICATION_WORLDMAP`, `RESOURCES`, `THIRD_PARTY_MOST_ACTIVE`, `UEM_CONVERSIONS_PER_GOAL`, `PROCESS_GROUPS_ONE` or `HOST` .
        """
        return pulumi.get(self, "tile_type")

    @property
    @pulumi.getter(name="assignedEntities")
    def assigned_entities(self) -> Optional[Sequence[str]]:
        """
        The list of Dynatrace entities, assigned to the tile
        """
        return pulumi.get(self, "assigned_entities")

    @property
    @pulumi.getter
    def bounds(self) -> Optional['outputs.DashboardTileBounds']:
        """
        the position and size of a tile
        """
        return pulumi.get(self, "bounds")

    @property
    @pulumi.getter(name="chartVisible")
    def chart_visible(self) -> Optional[bool]:
        return pulumi.get(self, "chart_visible")

    @property
    @pulumi.getter
    def configured(self) -> Optional[bool]:
        """
        The tile is configured and ready to use (`true`) or just placed on the dashboard (`false`)
        """
        return pulumi.get(self, "configured")

    @property
    @pulumi.getter(name="customName")
    def custom_name(self) -> Optional[str]:
        """
        The name of the tile, set by user
        """
        return pulumi.get(self, "custom_name")

    @property
    @pulumi.getter(name="excludeMaintenanceWindows")
    def exclude_maintenance_windows(self) -> Optional[bool]:
        """
        Include (`false') or exclude (`true`) maintenance windows from availability calculations
        """
        return pulumi.get(self, "exclude_maintenance_windows")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.DashboardTileFilter']:
        """
        is filter applied to a tile. It overrides dashboard's filter
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="filterConfig")
    def filter_config(self) -> Optional['outputs.DashboardTileFilterConfig']:
        """
        the position and size of a tile
        """
        return pulumi.get(self, "filter_config")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The limit of the results, if not set will use the default value of the system
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def markdown(self) -> Optional[str]:
        """
        The markdown-formatted content of the tile
        """
        return pulumi.get(self, "markdown")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric assigned to the tile
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="nameSize")
    def name_size(self) -> Optional[str]:
        """
        The size of the tile name. Possible values are `small`, `medium` and `large`.
        """
        return pulumi.get(self, "name_size")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        A [user session query](https://www.dynatrace.com/support/help/shortlink/usql-info) executed by the tile
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="timeFrameShift")
    def time_frame_shift(self) -> Optional[str]:
        """
        The comparison timeframe of the query. If specified, you additionally get the results of the same query with the specified time shift
        """
        return pulumi.get(self, "time_frame_shift")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The attribute `type` exists for backwards compatibilty. Usage is discouraged. You should use `visualization` instead.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def visualization(self) -> Optional[str]:
        """
        The visualization of the tile. Possible values are: `COLUMN_CHART`, `FUNNEL`, `LINE_CHART`, `PIE_CHART`, `SINGLE_VALUE`, `TABLE`
        """
        return pulumi.get(self, "visualization")

    @property
    @pulumi.getter(name="visualizationConfig")
    def visualization_config(self) -> Optional['outputs.DashboardTileVisualizationConfig']:
        """
        Configuration of a User session query visualization tile
        """
        return pulumi.get(self, "visualization_config")


@pulumi.output_type
class DashboardTileBounds(dict):
    def __init__(__self__, *,
                 height: int,
                 left: int,
                 top: int,
                 width: int,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "top", top)
        pulumi.set(__self__, "width", width)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def left(self) -> int:
        return pulumi.get(self, "left")

    @property
    @pulumi.getter
    def top(self) -> int:
        return pulumi.get(self, "top")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zones: Optional[Sequence['outputs.DashboardTileFilterManagementZone']] = None,
                 timeframe: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence['outputs.DashboardTileFilterManagementZone']]:
        return pulumi.get(self, "management_zones")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customName":
            suggest = "custom_name"
        elif key == "defaultName":
            suggest = "default_name"
        elif key == "chartConfig":
            suggest = "chart_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_name: str,
                 default_name: str,
                 type: str,
                 chart_config: Optional['outputs.DashboardTileFilterConfigChartConfig'] = None,
                 filters: Optional['outputs.DashboardTileFilterConfigFilters'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "custom_name", custom_name)
        pulumi.set(__self__, "default_name", default_name)
        pulumi.set(__self__, "type", type)
        if chart_config is not None:
            pulumi.set(__self__, "chart_config", chart_config)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customName")
    def custom_name(self) -> str:
        return pulumi.get(self, "custom_name")

    @property
    @pulumi.getter(name="defaultName")
    def default_name(self) -> str:
        return pulumi.get(self, "default_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="chartConfig")
    def chart_config(self) -> Optional['outputs.DashboardTileFilterConfigChartConfig']:
        return pulumi.get(self, "chart_config")

    @property
    @pulumi.getter
    def filters(self) -> Optional['outputs.DashboardTileFilterConfigFilters']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "axisLimits":
            suggest = "axis_limits"
        elif key == "leftAxisCustomUnit":
            suggest = "left_axis_custom_unit"
        elif key == "resultMetadatas":
            suggest = "result_metadatas"
        elif key == "rightAxisCustomUnit":
            suggest = "right_axis_custom_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 axis_limits: Optional[Mapping[str, float]] = None,
                 left_axis_custom_unit: Optional[str] = None,
                 legend: Optional[bool] = None,
                 result_metadatas: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadata']] = None,
                 right_axis_custom_unit: Optional[str] = None,
                 series: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeries']] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "type", type)
        if axis_limits is not None:
            pulumi.set(__self__, "axis_limits", axis_limits)
        if left_axis_custom_unit is not None:
            pulumi.set(__self__, "left_axis_custom_unit", left_axis_custom_unit)
        if legend is not None:
            pulumi.set(__self__, "legend", legend)
        if result_metadatas is not None:
            pulumi.set(__self__, "result_metadatas", result_metadatas)
        if right_axis_custom_unit is not None:
            pulumi.set(__self__, "right_axis_custom_unit", right_axis_custom_unit)
        if series is not None:
            pulumi.set(__self__, "series", series)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="axisLimits")
    def axis_limits(self) -> Optional[Mapping[str, float]]:
        return pulumi.get(self, "axis_limits")

    @property
    @pulumi.getter(name="leftAxisCustomUnit")
    def left_axis_custom_unit(self) -> Optional[str]:
        return pulumi.get(self, "left_axis_custom_unit")

    @property
    @pulumi.getter
    def legend(self) -> Optional[bool]:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="resultMetadatas")
    def result_metadatas(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadata']]:
        return pulumi.get(self, "result_metadatas")

    @property
    @pulumi.getter(name="rightAxisCustomUnit")
    def right_axis_custom_unit(self) -> Optional[str]:
        return pulumi.get(self, "right_axis_custom_unit")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeries']]:
        return pulumi.get(self, "series")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigResultMetadata(dict):
    def __init__(__self__, *,
                 configs: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadataConfig']] = None):
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigResultMetadataConfig']]:
        return pulumi.get(self, "configs")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigResultMetadataConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customColor":
            suggest = "custom_color"
        elif key == "lastModified":
            suggest = "last_modified"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigResultMetadataConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigResultMetadataConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigResultMetadataConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_color: Optional[str] = None,
                 key: Optional[str] = None,
                 last_modified: Optional[int] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if custom_color is not None:
            pulumi.set(__self__, "custom_color", custom_color)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if last_modified is not None:
            pulumi.set(__self__, "last_modified", last_modified)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="customColor")
    def custom_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_color")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> Optional[int]:
        return pulumi.get(self, "last_modified")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigSeries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "aggregationRate":
            suggest = "aggregation_rate"
        elif key == "sortAscending":
            suggest = "sort_ascending"
        elif key == "sortColumn":
            suggest = "sort_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigSeries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigSeries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigSeries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: str,
                 entity_type: str,
                 metric: str,
                 type: str,
                 aggregation_rate: Optional[str] = None,
                 dimensions: Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeriesDimension']] = None,
                 percentile: Optional[int] = None,
                 sort_ascending: Optional[bool] = None,
                 sort_column: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "type", type)
        if aggregation_rate is not None:
            pulumi.set(__self__, "aggregation_rate", aggregation_rate)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if sort_ascending is not None:
            pulumi.set(__self__, "sort_ascending", sort_ascending)
        if sort_column is not None:
            pulumi.set(__self__, "sort_column", sort_column)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="aggregationRate")
    def aggregation_rate(self) -> Optional[str]:
        return pulumi.get(self, "aggregation_rate")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigChartConfigSeriesDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[int]:
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="sortAscending")
    def sort_ascending(self) -> Optional[bool]:
        return pulumi.get(self, "sort_ascending")

    @property
    @pulumi.getter(name="sortColumn")
    def sort_column(self) -> Optional[bool]:
        return pulumi.get(self, "sort_column")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileFilterConfigChartConfigSeriesDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityDimension":
            suggest = "entity_dimension"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigChartConfigSeriesDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigChartConfigSeriesDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigChartConfigSeriesDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 entity_dimension: Optional[bool] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if entity_dimension is not None:
            pulumi.set(__self__, "entity_dimension", entity_dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="entityDimension")
    def entity_dimension(self) -> Optional[bool]:
        return pulumi.get(self, "entity_dimension")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardTileFilterConfigFilters(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilter']] = None):
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilter']]:
        return pulumi.get(self, "filters")


@pulumi.output_type
class DashboardTileFilterConfigFiltersFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileFilterConfigFiltersFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileFilterConfigFiltersFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileFilterConfigFiltersFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 matches: Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilterMatch']] = None):
        pulumi.set(__self__, "entity_type", entity_type)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.DashboardTileFilterConfigFiltersFilterMatch']]:
        return pulumi.get(self, "matches")


@pulumi.output_type
class DashboardTileFilterConfigFiltersFilterMatch(dict):
    def __init__(__self__, *,
                 key: str,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardTileFilterManagementZone(dict):
    def __init__(__self__, *,
                 id: str,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "id", id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DashboardTileVisualizationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasAxisBucketing":
            suggest = "has_axis_bucketing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTileVisualizationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTileVisualizationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTileVisualizationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 has_axis_bucketing: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if has_axis_bucketing is not None:
            pulumi.set(__self__, "has_axis_bucketing", has_axis_bucketing)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="hasAxisBucketing")
    def has_axis_bucketing(self) -> Optional[bool]:
        return pulumi.get(self, "has_axis_bucketing")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesDbConnectFailures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionFailsCount":
            suggest = "connection_fails_count"
        elif key == "evalPeriod":
            suggest = "eval_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesDbConnectFailures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesDbConnectFailures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesDbConnectFailures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_fails_count: Optional[int] = None,
                 eval_period: Optional[int] = None):
        """
        :param int connection_fails_count: Number of failed database connections during any **eval_period** minutes period to trigger an alert
        :param int eval_period: The *X* minutes time period during which the **connection*fails*count** is evaluated
        """
        if connection_fails_count is not None:
            pulumi.set(__self__, "connection_fails_count", connection_fails_count)
        if eval_period is not None:
            pulumi.set(__self__, "eval_period", eval_period)

    @property
    @pulumi.getter(name="connectionFailsCount")
    def connection_fails_count(self) -> Optional[int]:
        """
        Number of failed database connections during any **eval_period** minutes period to trigger an alert
        """
        return pulumi.get(self, "connection_fails_count")

    @property
    @pulumi.getter(name="evalPeriod")
    def eval_period(self) -> Optional[int]:
        """
        The *X* minutes time period during which the **connection*fails*count** is evaluated
        """
        return pulumi.get(self, "eval_period")


@pulumi.output_type
class DatabaseAnomaliesFailureRate(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.DatabaseAnomaliesFailureRateAuto'] = None,
                 thresholds: Optional['outputs.DatabaseAnomaliesFailureRateThresholds'] = None):
        """
        :param 'DatabaseAnomaliesFailureRateAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'DatabaseAnomaliesFailureRateThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.DatabaseAnomaliesFailureRateAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.DatabaseAnomaliesFailureRateThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class DatabaseAnomaliesFailureRateAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesFailureRateThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesLoad(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.DatabaseAnomaliesLoadDrops'] = None,
                 spikes: Optional['outputs.DatabaseAnomaliesLoadSpikes'] = None):
        """
        :param 'DatabaseAnomaliesLoadDropsArgs' drops: The configuration of traffic drops detection
        :param 'DatabaseAnomaliesLoadSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.DatabaseAnomaliesLoadDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.DatabaseAnomaliesLoadSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class DatabaseAnomaliesLoadDrops(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None):
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")


@pulumi.output_type
class DatabaseAnomaliesLoadSpikes(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None,
                 unknowns: Optional[str] = None):
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesResponseTime(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.DatabaseAnomaliesResponseTimeAuto'] = None,
                 thresholds: Optional['outputs.DatabaseAnomaliesResponseTimeThresholds'] = None):
        """
        :param 'DatabaseAnomaliesResponseTimeAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'DatabaseAnomaliesResponseTimeThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.DatabaseAnomaliesResponseTimeAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.DatabaseAnomaliesResponseTimeThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class DatabaseAnomaliesResponseTimeAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesResponseTimeAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesResponseTimeAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesResponseTimeAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Configuration for anomalies regarding load drops and spikes
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Configuration for anomalies regarding load drops and spikes
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DatabaseAnomaliesResponseTimeThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseAnomaliesResponseTimeThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseAnomaliesResponseTimeThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: Configuration for anomalies regarding load drops and spikes
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        Configuration for anomalies regarding load drops and spikes
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class DiskAnomaliesDiskName(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str):
        """
        :param str operator: Possible values are: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS` and `STARTS_WITH`
        :param str value: Value to compare to
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Possible values are: `CONTAINS`, `DOES_NOT_CONTAIN`, `DOES_NOT_EQUAL`, `DOES_NOT_START_WITH`, `EQUALS` and `STARTS_WITH`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to compare to
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DiskAnomaliesTags(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.DiskAnomaliesTagsFilter']] = None):
        """
        :param Sequence['DiskAnomaliesTagsFilterArgs'] filters: A Tag Filter
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.DiskAnomaliesTagsFilter']]:
        """
        A Tag Filter
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class DiskAnomaliesTagsFilter(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentQuotas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "demUnits":
            suggest = "dem_units"
        elif key == "hostUnits":
            suggest = "host_units"
        elif key == "userSessions":
            suggest = "user_sessions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentQuotas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentQuotas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentQuotas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ddus: Optional['outputs.EnvironmentQuotasDdus'] = None,
                 dem_units: Optional['outputs.EnvironmentQuotasDemUnits'] = None,
                 host_units: Optional[int] = None,
                 logs: Optional['outputs.EnvironmentQuotasLogs'] = None,
                 synthetic: Optional['outputs.EnvironmentQuotasSynthetic'] = None,
                 user_sessions: Optional['outputs.EnvironmentQuotasUserSessions'] = None):
        """
        :param 'EnvironmentQuotasDdusArgs' ddus: Davis Data Units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled
        :param 'EnvironmentQuotasDemUnitsArgs' dem_units: DEM units consumption and quota information on environment level
        :param int host_units: Host units consumption and quota information on environment level
        :param 'EnvironmentQuotasLogsArgs' logs: Log Monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level
        :param 'EnvironmentQuotasSyntheticArgs' synthetic: Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled
        :param 'EnvironmentQuotasUserSessionsArgs' user_sessions: User sessions consumption and quota information on environment level
        """
        if ddus is not None:
            pulumi.set(__self__, "ddus", ddus)
        if dem_units is not None:
            pulumi.set(__self__, "dem_units", dem_units)
        if host_units is not None:
            pulumi.set(__self__, "host_units", host_units)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if synthetic is not None:
            pulumi.set(__self__, "synthetic", synthetic)
        if user_sessions is not None:
            pulumi.set(__self__, "user_sessions", user_sessions)

    @property
    @pulumi.getter
    def ddus(self) -> Optional['outputs.EnvironmentQuotasDdus']:
        """
        Davis Data Units consumption and quota information on environment level. Not set (and not editable) if Davis data units is not enabled
        """
        return pulumi.get(self, "ddus")

    @property
    @pulumi.getter(name="demUnits")
    def dem_units(self) -> Optional['outputs.EnvironmentQuotasDemUnits']:
        """
        DEM units consumption and quota information on environment level
        """
        return pulumi.get(self, "dem_units")

    @property
    @pulumi.getter(name="hostUnits")
    def host_units(self) -> Optional[int]:
        """
        Host units consumption and quota information on environment level
        """
        return pulumi.get(self, "host_units")

    @property
    @pulumi.getter
    def logs(self) -> Optional['outputs.EnvironmentQuotasLogs']:
        """
        Log Monitoring consumption and quota information on environment level. Not set (and not editable) if Log monitoring is not enabled. Not set (and not editable) if Log monitoring is migrated to Davis data on license level
        """
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def synthetic(self) -> Optional['outputs.EnvironmentQuotasSynthetic']:
        """
        Synthetic monitors consumption and quota information on environment level. Not set (and not editable) if neither Synthetic nor DEM units is enabled
        """
        return pulumi.get(self, "synthetic")

    @property
    @pulumi.getter(name="userSessions")
    def user_sessions(self) -> Optional['outputs.EnvironmentQuotasUserSessions']:
        """
        User sessions consumption and quota information on environment level
        """
        return pulumi.get(self, "user_sessions")


@pulumi.output_type
class EnvironmentQuotasDdus(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasDemUnits(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasLogs(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasSynthetic(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentQuotasUserSessions(dict):
    def __init__(__self__, *,
                 annual: Optional[int] = None,
                 monthly: Optional[int] = None):
        if annual is not None:
            pulumi.set(__self__, "annual", annual)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)

    @property
    @pulumi.getter
    def annual(self) -> Optional[int]:
        return pulumi.get(self, "annual")

    @property
    @pulumi.getter
    def monthly(self) -> Optional[int]:
        return pulumi.get(self, "monthly")


@pulumi.output_type
class EnvironmentStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userActions":
            suggest = "user_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transactions: int,
                 limits: Optional['outputs.EnvironmentStorageLimits'] = None,
                 retention: Optional['outputs.EnvironmentStorageRetention'] = None,
                 user_actions: Optional[int] = None):
        """
        :param int transactions: Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000
        :param int user_actions: Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited by omitting this property
        """
        pulumi.set(__self__, "transactions", transactions)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if user_actions is not None:
            pulumi.set(__self__, "user_actions", user_actions)

    @property
    @pulumi.getter
    def transactions(self) -> int:
        """
        Maximum number of newly monitored entry point PurePaths captured per process/minute on environment level. Can be set to any value from 100 to 100000
        """
        return pulumi.get(self, "transactions")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.EnvironmentStorageLimits']:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def retention(self) -> Optional['outputs.EnvironmentStorageRetention']:
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter(name="userActions")
    def user_actions(self) -> Optional[int]:
        """
        Maximum number of user actions generated per minute on environment level. Can be set to any value from 1 to 2147483646 or left unlimited by omitting this property
        """
        return pulumi.get(self, "user_actions")


@pulumi.output_type
class EnvironmentStorageLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sessionReplay":
            suggest = "session_replay"
        elif key == "symbolFiles":
            suggest = "symbol_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorageLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorageLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorageLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs: Optional[int] = None,
                 session_replay: Optional[int] = None,
                 symbol_files: Optional[int] = None,
                 transactions: Optional[int] = None):
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if session_replay is not None:
            pulumi.set(__self__, "session_replay", session_replay)
        if symbol_files is not None:
            pulumi.set(__self__, "symbol_files", symbol_files)
        if transactions is not None:
            pulumi.set(__self__, "transactions", transactions)

    @property
    @pulumi.getter
    def logs(self) -> Optional[int]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter(name="sessionReplay")
    def session_replay(self) -> Optional[int]:
        return pulumi.get(self, "session_replay")

    @property
    @pulumi.getter(name="symbolFiles")
    def symbol_files(self) -> Optional[int]:
        return pulumi.get(self, "symbol_files")

    @property
    @pulumi.getter
    def transactions(self) -> Optional[int]:
        return pulumi.get(self, "transactions")


@pulumi.output_type
class EnvironmentStorageRetention(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceCodeLevel":
            suggest = "service_code_level"
        elif key == "serviceRequestLevel":
            suggest = "service_request_level"
        elif key == "sessionReplay":
            suggest = "session_replay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentStorageRetention. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentStorageRetention.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentStorageRetention.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs: int,
                 rum: int,
                 service_code_level: int,
                 service_request_level: int,
                 session_replay: int,
                 synthetic: int):
        pulumi.set(__self__, "logs", logs)
        pulumi.set(__self__, "rum", rum)
        pulumi.set(__self__, "service_code_level", service_code_level)
        pulumi.set(__self__, "service_request_level", service_request_level)
        pulumi.set(__self__, "session_replay", session_replay)
        pulumi.set(__self__, "synthetic", synthetic)

    @property
    @pulumi.getter
    def logs(self) -> int:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def rum(self) -> int:
        return pulumi.get(self, "rum")

    @property
    @pulumi.getter(name="serviceCodeLevel")
    def service_code_level(self) -> int:
        return pulumi.get(self, "service_code_level")

    @property
    @pulumi.getter(name="serviceRequestLevel")
    def service_request_level(self) -> int:
        return pulumi.get(self, "service_request_level")

    @property
    @pulumi.getter(name="sessionReplay")
    def session_replay(self) -> int:
        return pulumi.get(self, "session_replay")

    @property
    @pulumi.getter
    def synthetic(self) -> int:
        return pulumi.get(self, "synthetic")


@pulumi.output_type
class HostAnomaliesConnections(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledOnGracefulShutdowns":
            suggest = "enabled_on_graceful_shutdowns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesConnections. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesConnections.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesConnections.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 enabled_on_graceful_shutdowns: bool):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param bool enabled_on_graceful_shutdowns: Alert (`true`) on graceful host shutdowns
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "enabled_on_graceful_shutdowns", enabled_on_graceful_shutdowns)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="enabledOnGracefulShutdowns")
    def enabled_on_graceful_shutdowns(self) -> bool:
        """
        Alert (`true`) on graceful host shutdowns
        """
        return pulumi.get(self, "enabled_on_graceful_shutdowns")


@pulumi.output_type
class HostAnomaliesCpu(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesCpuThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesCpuThresholdsArgs' thresholds: Custom thresholds for high CPU saturation. If not set then the automatic mode is used
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesCpuThresholds']:
        """
        Custom thresholds for high CPU saturation. If not set then the automatic mode is used
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesCpuThresholds(dict):
    def __init__(__self__, *,
                 saturation: int):
        pulumi.set(__self__, "saturation", saturation)

    @property
    @pulumi.getter
    def saturation(self) -> int:
        return pulumi.get(self, "saturation")


@pulumi.output_type
class HostAnomaliesDisks(dict):
    def __init__(__self__, *,
                 inodes: Optional['outputs.HostAnomaliesDisksInodes'] = None,
                 space: Optional['outputs.HostAnomaliesDisksSpace'] = None,
                 speed: Optional['outputs.HostAnomaliesDisksSpeed'] = None):
        """
        :param 'HostAnomaliesDisksInodesArgs' inodes: Configuration of low disk inodes number detection
        :param 'HostAnomaliesDisksSpaceArgs' space: Configuration of low disk space detection
        :param 'HostAnomaliesDisksSpeedArgs' speed: Configuration of slow running disks detection
        """
        if inodes is not None:
            pulumi.set(__self__, "inodes", inodes)
        if space is not None:
            pulumi.set(__self__, "space", space)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def inodes(self) -> Optional['outputs.HostAnomaliesDisksInodes']:
        """
        Configuration of low disk inodes number detection
        """
        return pulumi.get(self, "inodes")

    @property
    @pulumi.getter
    def space(self) -> Optional['outputs.HostAnomaliesDisksSpace']:
        """
        Configuration of low disk space detection
        """
        return pulumi.get(self, "space")

    @property
    @pulumi.getter
    def speed(self) -> Optional['outputs.HostAnomaliesDisksSpeed']:
        """
        Configuration of slow running disks detection
        """
        return pulumi.get(self, "speed")


@pulumi.output_type
class HostAnomaliesDisksInodes(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksInodesThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksInodesThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksInodesThresholds(dict):
    def __init__(__self__, *,
                 percentage: int):
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def percentage(self) -> int:
        return pulumi.get(self, "percentage")


@pulumi.output_type
class HostAnomaliesDisksSpace(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksSpaceThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksSpaceThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksSpaceThresholds(dict):
    def __init__(__self__, *,
                 percentage: int):
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def percentage(self) -> int:
        return pulumi.get(self, "percentage")


@pulumi.output_type
class HostAnomaliesDisksSpeed(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesDisksSpeedThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesDisksSpeedThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesDisksSpeedThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "writeAndReadTime":
            suggest = "write_and_read_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesDisksSpeedThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesDisksSpeedThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesDisksSpeedThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 write_and_read_time: int):
        pulumi.set(__self__, "write_and_read_time", write_and_read_time)

    @property
    @pulumi.getter(name="writeAndReadTime")
    def write_and_read_time(self) -> int:
        return pulumi.get(self, "write_and_read_time")


@pulumi.output_type
class HostAnomaliesGc(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesGcThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesGcThresholdsArgs' thresholds: Custom thresholds for high GC activity. If not set, automatic mode is used.   Meeting **any** of these conditions triggers an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesGcThresholds']:
        """
        Custom thresholds for high GC activity. If not set, automatic mode is used.   Meeting **any** of these conditions triggers an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesGcThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "suspensionPercentage":
            suggest = "suspension_percentage"
        elif key == "timePercentage":
            suggest = "time_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesGcThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesGcThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesGcThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 suspension_percentage: int,
                 time_percentage: int):
        pulumi.set(__self__, "suspension_percentage", suspension_percentage)
        pulumi.set(__self__, "time_percentage", time_percentage)

    @property
    @pulumi.getter(name="suspensionPercentage")
    def suspension_percentage(self) -> int:
        return pulumi.get(self, "suspension_percentage")

    @property
    @pulumi.getter(name="timePercentage")
    def time_percentage(self) -> int:
        return pulumi.get(self, "time_percentage")


@pulumi.output_type
class HostAnomaliesJava(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outOfMemory":
            suggest = "out_of_memory"
        elif key == "outOfThreads":
            suggest = "out_of_threads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJava. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJava.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJava.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 out_of_memory: Optional['outputs.HostAnomaliesJavaOutOfMemory'] = None,
                 out_of_threads: Optional['outputs.HostAnomaliesJavaOutOfThreads'] = None):
        """
        :param 'HostAnomaliesJavaOutOfMemoryArgs' out_of_memory: Configuration of Java out of memory problems detection
        :param 'HostAnomaliesJavaOutOfThreadsArgs' out_of_threads: Configuration of Java out of threads problems detection
        """
        if out_of_memory is not None:
            pulumi.set(__self__, "out_of_memory", out_of_memory)
        if out_of_threads is not None:
            pulumi.set(__self__, "out_of_threads", out_of_threads)

    @property
    @pulumi.getter(name="outOfMemory")
    def out_of_memory(self) -> Optional['outputs.HostAnomaliesJavaOutOfMemory']:
        """
        Configuration of Java out of memory problems detection
        """
        return pulumi.get(self, "out_of_memory")

    @property
    @pulumi.getter(name="outOfThreads")
    def out_of_threads(self) -> Optional['outputs.HostAnomaliesJavaOutOfThreads']:
        """
        Configuration of Java out of threads problems detection
        """
        return pulumi.get(self, "out_of_threads")


@pulumi.output_type
class HostAnomaliesJavaOutOfMemory(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesJavaOutOfMemoryThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesJavaOutOfMemoryThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesJavaOutOfMemoryThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceptionCount":
            suggest = "exception_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJavaOutOfMemoryThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJavaOutOfMemoryThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJavaOutOfMemoryThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exception_count: int):
        pulumi.set(__self__, "exception_count", exception_count)

    @property
    @pulumi.getter(name="exceptionCount")
    def exception_count(self) -> int:
        return pulumi.get(self, "exception_count")


@pulumi.output_type
class HostAnomaliesJavaOutOfThreads(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesJavaOutOfThreadsThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesJavaOutOfThreadsThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesJavaOutOfThreadsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceptionCount":
            suggest = "exception_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesJavaOutOfThreadsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesJavaOutOfThreadsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesJavaOutOfThreadsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exception_count: int):
        pulumi.set(__self__, "exception_count", exception_count)

    @property
    @pulumi.getter(name="exceptionCount")
    def exception_count(self) -> int:
        return pulumi.get(self, "exception_count")


@pulumi.output_type
class HostAnomaliesMemory(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesMemoryThresholds'] = None):
        """
        :param bool enabled: The detection is enabled (`true`) or disabled (`false`)
        :param 'HostAnomaliesMemoryThresholdsArgs' thresholds: Custom thresholds for high memory usage. If not set then the automatic mode is used. **Both** conditions must be met to trigger an alert
        """
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The detection is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesMemoryThresholds']:
        """
        Custom thresholds for high memory usage. If not set then the automatic mode is used. **Both** conditions must be met to trigger an alert
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesMemoryThresholds(dict):
    def __init__(__self__, *,
                 linux: 'outputs.HostAnomaliesMemoryThresholdsLinux',
                 windows: 'outputs.HostAnomaliesMemoryThresholdsWindows'):
        pulumi.set(__self__, "linux", linux)
        pulumi.set(__self__, "windows", windows)

    @property
    @pulumi.getter
    def linux(self) -> 'outputs.HostAnomaliesMemoryThresholdsLinux':
        return pulumi.get(self, "linux")

    @property
    @pulumi.getter
    def windows(self) -> 'outputs.HostAnomaliesMemoryThresholdsWindows':
        return pulumi.get(self, "windows")


@pulumi.output_type
class HostAnomaliesMemoryThresholdsLinux(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageFaults":
            suggest = "page_faults"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesMemoryThresholdsLinux. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesMemoryThresholdsLinux.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesMemoryThresholdsLinux.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_faults: int,
                 usage: int):
        pulumi.set(__self__, "page_faults", page_faults)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter(name="pageFaults")
    def page_faults(self) -> int:
        return pulumi.get(self, "page_faults")

    @property
    @pulumi.getter
    def usage(self) -> int:
        return pulumi.get(self, "usage")


@pulumi.output_type
class HostAnomaliesMemoryThresholdsWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageFaults":
            suggest = "page_faults"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesMemoryThresholdsWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesMemoryThresholdsWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesMemoryThresholdsWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 page_faults: int,
                 usage: int):
        pulumi.set(__self__, "page_faults", page_faults)
        pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter(name="pageFaults")
    def page_faults(self) -> int:
        return pulumi.get(self, "page_faults")

    @property
    @pulumi.getter
    def usage(self) -> int:
        return pulumi.get(self, "usage")


@pulumi.output_type
class HostAnomaliesNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPackets":
            suggest = "dropped_packets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connectivity: Optional['outputs.HostAnomaliesNetworkConnectivity'] = None,
                 dropped_packets: Optional['outputs.HostAnomaliesNetworkDroppedPackets'] = None,
                 errors: Optional['outputs.HostAnomaliesNetworkErrors'] = None,
                 retransmission: Optional['outputs.HostAnomaliesNetworkRetransmission'] = None,
                 utilization: Optional['outputs.HostAnomaliesNetworkUtilization'] = None):
        """
        :param 'HostAnomaliesNetworkConnectivityArgs' connectivity: Configuration of TCP connectivity problems detection
        :param 'HostAnomaliesNetworkDroppedPacketsArgs' dropped_packets: Configuration of high number of dropped packets detection
        :param 'HostAnomaliesNetworkErrorsArgs' errors: Configuration of high number of network errors detection
        :param 'HostAnomaliesNetworkRetransmissionArgs' retransmission: Configuration of high retransmission rate detection
        :param 'HostAnomaliesNetworkUtilizationArgs' utilization: Configuration of high network utilization detection
        """
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if dropped_packets is not None:
            pulumi.set(__self__, "dropped_packets", dropped_packets)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if retransmission is not None:
            pulumi.set(__self__, "retransmission", retransmission)
        if utilization is not None:
            pulumi.set(__self__, "utilization", utilization)

    @property
    @pulumi.getter
    def connectivity(self) -> Optional['outputs.HostAnomaliesNetworkConnectivity']:
        """
        Configuration of TCP connectivity problems detection
        """
        return pulumi.get(self, "connectivity")

    @property
    @pulumi.getter(name="droppedPackets")
    def dropped_packets(self) -> Optional['outputs.HostAnomaliesNetworkDroppedPackets']:
        """
        Configuration of high number of dropped packets detection
        """
        return pulumi.get(self, "dropped_packets")

    @property
    @pulumi.getter
    def errors(self) -> Optional['outputs.HostAnomaliesNetworkErrors']:
        """
        Configuration of high number of network errors detection
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def retransmission(self) -> Optional['outputs.HostAnomaliesNetworkRetransmission']:
        """
        Configuration of high retransmission rate detection
        """
        return pulumi.get(self, "retransmission")

    @property
    @pulumi.getter
    def utilization(self) -> Optional['outputs.HostAnomaliesNetworkUtilization']:
        """
        Configuration of high network utilization detection
        """
        return pulumi.get(self, "utilization")


@pulumi.output_type
class HostAnomaliesNetworkConnectivity(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkConnectivityThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkConnectivityThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkConnectivityThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedConnections":
            suggest = "failed_connections"
        elif key == "newConnectionFailures":
            suggest = "new_connection_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkConnectivityThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkConnectivityThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkConnectivityThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_connections: int,
                 new_connection_failures: int):
        pulumi.set(__self__, "failed_connections", failed_connections)
        pulumi.set(__self__, "new_connection_failures", new_connection_failures)

    @property
    @pulumi.getter(name="failedConnections")
    def failed_connections(self) -> int:
        return pulumi.get(self, "failed_connections")

    @property
    @pulumi.getter(name="newConnectionFailures")
    def new_connection_failures(self) -> int:
        return pulumi.get(self, "new_connection_failures")


@pulumi.output_type
class HostAnomaliesNetworkDroppedPackets(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkDroppedPacketsThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkDroppedPacketsThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkDroppedPacketsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "droppedPackets":
            suggest = "dropped_packets"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkDroppedPacketsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkDroppedPacketsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkDroppedPacketsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dropped_packets: int,
                 total_packets_rate: int):
        pulumi.set(__self__, "dropped_packets", dropped_packets)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="droppedPackets")
    def dropped_packets(self) -> int:
        return pulumi.get(self, "dropped_packets")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesNetworkErrors(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkErrorsThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkErrorsThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkErrorsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorsPercentage":
            suggest = "errors_percentage"
        elif key == "totalPacketsRate":
            suggest = "total_packets_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkErrorsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkErrorsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkErrorsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors_percentage: int,
                 total_packets_rate: int):
        pulumi.set(__self__, "errors_percentage", errors_percentage)
        pulumi.set(__self__, "total_packets_rate", total_packets_rate)

    @property
    @pulumi.getter(name="errorsPercentage")
    def errors_percentage(self) -> int:
        return pulumi.get(self, "errors_percentage")

    @property
    @pulumi.getter(name="totalPacketsRate")
    def total_packets_rate(self) -> int:
        return pulumi.get(self, "total_packets_rate")


@pulumi.output_type
class HostAnomaliesNetworkRetransmission(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkRetransmissionThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkRetransmissionThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkRetransmissionThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retransmissionRate":
            suggest = "retransmission_rate"
        elif key == "retransmittedPackets":
            suggest = "retransmitted_packets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAnomaliesNetworkRetransmissionThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAnomaliesNetworkRetransmissionThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAnomaliesNetworkRetransmissionThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retransmission_rate: int,
                 retransmitted_packets: int):
        pulumi.set(__self__, "retransmission_rate", retransmission_rate)
        pulumi.set(__self__, "retransmitted_packets", retransmitted_packets)

    @property
    @pulumi.getter(name="retransmissionRate")
    def retransmission_rate(self) -> int:
        return pulumi.get(self, "retransmission_rate")

    @property
    @pulumi.getter(name="retransmittedPackets")
    def retransmitted_packets(self) -> int:
        return pulumi.get(self, "retransmitted_packets")


@pulumi.output_type
class HostAnomaliesNetworkUtilization(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 thresholds: Optional['outputs.HostAnomaliesNetworkUtilizationThresholds'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.HostAnomaliesNetworkUtilizationThresholds']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HostAnomaliesNetworkUtilizationThresholds(dict):
    def __init__(__self__, *,
                 utilization: int):
        pulumi.set(__self__, "utilization", utilization)

    @property
    @pulumi.getter
    def utilization(self) -> int:
        return pulumi.get(self, "utilization")


@pulumi.output_type
class HostNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.HostNamingConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.HostNamingConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class HostNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.HostNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.HostNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.HostNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.HostNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.HostNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.HostNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.HostNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.HostNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.HostNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.HostNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.HostNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.HostNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.HostNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.HostNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.HostNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.HostNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.HostNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.HostNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.HostNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.HostNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.HostNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.HostNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.HostNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.HostNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.HostNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.HostNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.HostNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.HostNamingConditionConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.HostNamingConditionConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.HostNamingConditionConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.HostNamingConditionConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.HostNamingConditionConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.HostNamingConditionConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.HostNamingConditionConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.HostNamingConditionConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.HostNamingConditionConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.HostNamingConditionConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.HostNamingConditionConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.HostNamingConditionConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.HostNamingConditionConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.HostNamingConditionConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HostNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class HostNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.HostNamingConditionConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.HostNamingConditionConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class HostNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class HttpMonitorAnomalyDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadingTimeThresholds":
            suggest = "loading_time_thresholds"
        elif key == "outageHandlings":
            suggest = "outage_handlings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loading_time_thresholds: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThreshold']] = None,
                 outage_handlings: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandling']] = None):
        """
        :param Sequence['HttpMonitorAnomalyDetectionLoadingTimeThresholdArgs'] loading_time_thresholds: Thresholds for loading times
        :param Sequence['HttpMonitorAnomalyDetectionOutageHandlingArgs'] outage_handlings: Outage handling configuration
        """
        if loading_time_thresholds is not None:
            pulumi.set(__self__, "loading_time_thresholds", loading_time_thresholds)
        if outage_handlings is not None:
            pulumi.set(__self__, "outage_handlings", outage_handlings)

    @property
    @pulumi.getter(name="loadingTimeThresholds")
    def loading_time_thresholds(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThreshold']]:
        """
        Thresholds for loading times
        """
        return pulumi.get(self, "loading_time_thresholds")

    @property
    @pulumi.getter(name="outageHandlings")
    def outage_handlings(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandling']]:
        """
        Outage handling configuration
        """
        return pulumi.get(self, "outage_handlings")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThreshold(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 thresholds: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold']]:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThresholdThreshold(dict):
    def __init__(__self__, *,
                 thresholds: Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']):
        pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueMs":
            suggest = "value_ms"
        elif key == "eventIndex":
            suggest = "event_index"
        elif key == "requestIndex":
            suggest = "request_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionLoadingTimeThresholdThresholdThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_ms: int,
                 event_index: Optional[int] = None,
                 request_index: Optional[int] = None,
                 type: Optional[str] = None):
        pulumi.set(__self__, "value_ms", value_ms)
        if event_index is not None:
            pulumi.set(__self__, "event_index", event_index)
        if request_index is not None:
            pulumi.set(__self__, "request_index", request_index)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="valueMs")
    def value_ms(self) -> int:
        return pulumi.get(self, "value_ms")

    @property
    @pulumi.getter(name="eventIndex")
    def event_index(self) -> Optional[int]:
        return pulumi.get(self, "event_index")

    @property
    @pulumi.getter(name="requestIndex")
    def request_index(self) -> Optional[int]:
        return pulumi.get(self, "request_index")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class HttpMonitorAnomalyDetectionOutageHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "globalOutage":
            suggest = "global_outage"
        elif key == "localOutage":
            suggest = "local_outage"
        elif key == "localOutagePolicies":
            suggest = "local_outage_policies"
        elif key == "retryOnError":
            suggest = "retry_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionOutageHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionOutageHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_outage: Optional[bool] = None,
                 local_outage: Optional[bool] = None,
                 local_outage_policies: Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']] = None,
                 retry_on_error: Optional[bool] = None):
        if global_outage is not None:
            pulumi.set(__self__, "global_outage", global_outage)
        if local_outage is not None:
            pulumi.set(__self__, "local_outage", local_outage)
        if local_outage_policies is not None:
            pulumi.set(__self__, "local_outage_policies", local_outage_policies)
        if retry_on_error is not None:
            pulumi.set(__self__, "retry_on_error", retry_on_error)

    @property
    @pulumi.getter(name="globalOutage")
    def global_outage(self) -> Optional[bool]:
        return pulumi.get(self, "global_outage")

    @property
    @pulumi.getter(name="localOutage")
    def local_outage(self) -> Optional[bool]:
        return pulumi.get(self, "local_outage")

    @property
    @pulumi.getter(name="localOutagePolicies")
    def local_outage_policies(self) -> Optional[Sequence['outputs.HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy']]:
        return pulumi.get(self, "local_outage_policies")

    @property
    @pulumi.getter(name="retryOnError")
    def retry_on_error(self) -> Optional[bool]:
        return pulumi.get(self, "retry_on_error")


@pulumi.output_type
class HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "affectedLocations":
            suggest = "affected_locations"
        elif key == "consecutiveRuns":
            suggest = "consecutive_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorAnomalyDetectionOutageHandlingLocalOutagePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affected_locations: int,
                 consecutive_runs: int):
        pulumi.set(__self__, "affected_locations", affected_locations)
        pulumi.set(__self__, "consecutive_runs", consecutive_runs)

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> int:
        return pulumi.get(self, "affected_locations")

    @property
    @pulumi.getter(name="consecutiveRuns")
    def consecutive_runs(self) -> int:
        return pulumi.get(self, "consecutive_runs")


@pulumi.output_type
class HttpMonitorScript(dict):
    def __init__(__self__, *,
                 requests: Sequence['outputs.HttpMonitorScriptRequest']):
        """
        :param Sequence['HttpMonitorScriptRequestArgs'] requests: A HTTP request to be performed by the monitor.
        """
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.HttpMonitorScriptRequest']:
        """
        A HTTP request to be performed by the monitor.
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class HttpMonitorScriptRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postProcessing":
            suggest = "post_processing"
        elif key == "preProcessing":
            suggest = "pre_processing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 url: str,
                 authentication: Optional['outputs.HttpMonitorScriptRequestAuthentication'] = None,
                 body: Optional[str] = None,
                 configuration: Optional['outputs.HttpMonitorScriptRequestConfiguration'] = None,
                 description: Optional[str] = None,
                 post_processing: Optional[str] = None,
                 pre_processing: Optional[str] = None,
                 validation: Optional['outputs.HttpMonitorScriptRequestValidation'] = None):
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "url", url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if post_processing is not None:
            pulumi.set(__self__, "post_processing", post_processing)
        if pre_processing is not None:
            pulumi.set(__self__, "pre_processing", pre_processing)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.HttpMonitorScriptRequestAuthentication']:
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.HttpMonitorScriptRequestConfiguration']:
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="postProcessing")
    def post_processing(self) -> Optional[str]:
        return pulumi.get(self, "post_processing")

    @property
    @pulumi.getter(name="preProcessing")
    def pre_processing(self) -> Optional[str]:
        return pulumi.get(self, "pre_processing")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.HttpMonitorScriptRequestValidation']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class HttpMonitorScriptRequestAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kdcIp":
            suggest = "kdc_ip"
        elif key == "realmName":
            suggest = "realm_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 type: str,
                 kdc_ip: Optional[str] = None,
                 realm_name: Optional[str] = None):
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "type", type)
        if kdc_ip is not None:
            pulumi.set(__self__, "kdc_ip", kdc_ip)
        if realm_name is not None:
            pulumi.set(__self__, "realm_name", realm_name)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="kdcIp")
    def kdc_ip(self) -> Optional[str]:
        return pulumi.get(self, "kdc_ip")

    @property
    @pulumi.getter(name="realmName")
    def realm_name(self) -> Optional[str]:
        return pulumi.get(self, "realm_name")


@pulumi.output_type
class HttpMonitorScriptRequestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: Optional[bool] = None,
                 follow_redirects: Optional[bool] = None,
                 headers: Optional['outputs.HttpMonitorScriptRequestConfigurationHeaders'] = None,
                 user_agent: Optional[str] = None):
        if accept_any_certificate is not None:
            pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> Optional[bool]:
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.HttpMonitorScriptRequestConfigurationHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class HttpMonitorScriptRequestConfigurationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.HttpMonitorScriptRequestConfigurationHeadersHeader']):
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.HttpMonitorScriptRequestConfigurationHeadersHeader']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class HttpMonitorScriptRequestConfigurationHeadersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class HttpMonitorScriptRequestValidation(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.HttpMonitorScriptRequestValidationRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.HttpMonitorScriptRequestValidationRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class HttpMonitorScriptRequestValidationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passIfFound":
            suggest = "pass_if_found"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMonitorScriptRequestValidationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMonitorScriptRequestValidationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMonitorScriptRequestValidationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 value: str,
                 pass_if_found: Optional[bool] = None):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if pass_if_found is not None:
            pulumi.set(__self__, "pass_if_found", pass_if_found)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="passIfFound")
    def pass_if_found(self) -> Optional[bool]:
        return pulumi.get(self, "pass_if_found")


@pulumi.output_type
class HttpMonitorTag(dict):
    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.HttpMonitorTagTag']] = None):
        """
        :param Sequence['HttpMonitorTagTagArgs'] tags: Tag with source of a Dynatrace entity.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.HttpMonitorTagTag']]:
        """
        Tag with source of a Dynatrace entity.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class HttpMonitorTagTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 source: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ImsBridgesQueueManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueManagers":
            suggest = "queue_managers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImsBridgesQueueManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImsBridgesQueueManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImsBridgesQueueManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_managers: Optional[Sequence['outputs.ImsBridgesQueueManagerQueueManager']] = None):
        """
        :param Sequence['ImsBridgesQueueManagerQueueManagerArgs'] queue_managers: Queue manager definition for IMS bridge
        """
        if queue_managers is not None:
            pulumi.set(__self__, "queue_managers", queue_managers)

    @property
    @pulumi.getter(name="queueManagers")
    def queue_managers(self) -> Optional[Sequence['outputs.ImsBridgesQueueManagerQueueManager']]:
        """
        Queue manager definition for IMS bridge
        """
        return pulumi.get(self, "queue_managers")


@pulumi.output_type
class ImsBridgesQueueManagerQueueManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueManagerQueues":
            suggest = "queue_manager_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImsBridgesQueueManagerQueueManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImsBridgesQueueManagerQueueManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImsBridgesQueueManagerQueueManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 queue_manager_queues: Optional[Sequence[str]] = None):
        """
        :param str name: The name of the IMS bridge
        """
        pulumi.set(__self__, "name", name)
        if queue_manager_queues is not None:
            pulumi.set(__self__, "queue_manager_queues", queue_manager_queues)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the IMS bridge
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="queueManagerQueues")
    def queue_manager_queues(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "queue_manager_queues")


@pulumi.output_type
class K8sCredentialsEventsFieldSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSelector":
            suggest = "field_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCredentialsEventsFieldSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCredentialsEventsFieldSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCredentialsEventsFieldSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 field_selector: str,
                 label: str,
                 unknowns: Optional[str] = None):
        """
        :param bool active: Whether subscription to this events field selector is enabled (value set to `true`). If disabled (value set to `false`), Dynatrace will stop fetching events from the Kubernetes API for this events field selector
        :param str field_selector: The field selector string (url decoding is applied) when storing it.
        :param str label: A label of the events field selector.
        :param str unknowns: Any attributes that aren't yet supported by this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "field_selector", field_selector)
        pulumi.set(__self__, "label", label)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Whether subscription to this events field selector is enabled (value set to `true`). If disabled (value set to `false`), Dynatrace will stop fetching events from the Kubernetes API for this events field selector
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="fieldSelector")
    def field_selector(self) -> str:
        """
        The field selector string (url decoding is applied) when storing it.
        """
        return pulumi.get(self, "field_selector")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        A label of the events field selector.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        Any attributes that aren't yet supported by this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.MaintenanceFilterFilter']] = None):
        """
        :param Sequence['MaintenanceFilterFilterArgs'] filters: A list of matching rules for dynamic filter formation.  If several rules are set, the OR logic applies
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.MaintenanceFilterFilter']]:
        """
        A list of matching rules for dynamic filter formation.  If several rules are set, the OR logic applies
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class MaintenanceFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"
        elif key == "entityTags":
            suggest = "entity_tags"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "managementZones":
            suggest = "management_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: Optional[str] = None,
                 entity_tags: Optional[Sequence[str]] = None,
                 entity_type: Optional[str] = None,
                 management_zones: Optional[Sequence[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_tags is not None:
            pulumi.set(__self__, "entity_tags", entity_tags)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if management_zones is not None:
            pulumi.set(__self__, "management_zones", management_zones)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="entityTags")
    def entity_tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "entity_tags")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="managementZones")
    def management_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "management_zones")


@pulumi.output_type
class MaintenanceGeneralProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSynthetic":
            suggest = "disable_synthetic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceGeneralProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceGeneralProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceGeneralProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 suppression: str,
                 type: str,
                 description: Optional[str] = None,
                 disable_synthetic: Optional[bool] = None):
        """
        :param str name: The name of the maintenance window, displayed in the UI
        :param str suppression: The type of suppression of alerting and problem detection during the maintenance
        :param str type: The type of the maintenance: planned or unplanned
        :param str description: A short description of the maintenance purpose
        :param bool disable_synthetic: Suppress execution of synthetic monitors during the maintenance
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "suppression", suppression)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_synthetic is not None:
            pulumi.set(__self__, "disable_synthetic", disable_synthetic)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the maintenance window, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def suppression(self) -> str:
        """
        The type of suppression of alerting and problem detection during the maintenance
        """
        return pulumi.get(self, "suppression")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the maintenance: planned or unplanned
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A short description of the maintenance purpose
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableSynthetic")
    def disable_synthetic(self) -> Optional[bool]:
        """
        Suppress execution of synthetic monitors during the maintenance
        """
        return pulumi.get(self, "disable_synthetic")


@pulumi.output_type
class MaintenanceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dailyRecurrence":
            suggest = "daily_recurrence"
        elif key == "monthlyRecurrence":
            suggest = "monthly_recurrence"
        elif key == "onceRecurrence":
            suggest = "once_recurrence"
        elif key == "weeklyRecurrence":
            suggest = "weekly_recurrence"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 daily_recurrence: Optional['outputs.MaintenanceScheduleDailyRecurrence'] = None,
                 monthly_recurrence: Optional['outputs.MaintenanceScheduleMonthlyRecurrence'] = None,
                 once_recurrence: Optional['outputs.MaintenanceScheduleOnceRecurrence'] = None,
                 weekly_recurrence: Optional['outputs.MaintenanceScheduleWeeklyRecurrence'] = None):
        """
        :param str type: The time window of the maintenance window
        :param 'MaintenanceScheduleDailyRecurrenceArgs' daily_recurrence: The configuration for maintenance windows occuring daily
        :param 'MaintenanceScheduleMonthlyRecurrenceArgs' monthly_recurrence: The configuration for maintenance windows occuring monthly
        :param 'MaintenanceScheduleOnceRecurrenceArgs' once_recurrence: The configuration for maintenance windows occuring once
        :param 'MaintenanceScheduleWeeklyRecurrenceArgs' weekly_recurrence: The configuration for maintenance windows occuring weekly
        """
        pulumi.set(__self__, "type", type)
        if daily_recurrence is not None:
            pulumi.set(__self__, "daily_recurrence", daily_recurrence)
        if monthly_recurrence is not None:
            pulumi.set(__self__, "monthly_recurrence", monthly_recurrence)
        if once_recurrence is not None:
            pulumi.set(__self__, "once_recurrence", once_recurrence)
        if weekly_recurrence is not None:
            pulumi.set(__self__, "weekly_recurrence", weekly_recurrence)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The time window of the maintenance window
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dailyRecurrence")
    def daily_recurrence(self) -> Optional['outputs.MaintenanceScheduleDailyRecurrence']:
        """
        The configuration for maintenance windows occuring daily
        """
        return pulumi.get(self, "daily_recurrence")

    @property
    @pulumi.getter(name="monthlyRecurrence")
    def monthly_recurrence(self) -> Optional['outputs.MaintenanceScheduleMonthlyRecurrence']:
        """
        The configuration for maintenance windows occuring monthly
        """
        return pulumi.get(self, "monthly_recurrence")

    @property
    @pulumi.getter(name="onceRecurrence")
    def once_recurrence(self) -> Optional['outputs.MaintenanceScheduleOnceRecurrence']:
        """
        The configuration for maintenance windows occuring once
        """
        return pulumi.get(self, "once_recurrence")

    @property
    @pulumi.getter(name="weeklyRecurrence")
    def weekly_recurrence(self) -> Optional['outputs.MaintenanceScheduleWeeklyRecurrence']:
        """
        The configuration for maintenance windows occuring weekly
        """
        return pulumi.get(self, "weekly_recurrence")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence_range: 'outputs.MaintenanceScheduleDailyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleDailyRecurrenceTimeWindow'):
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleDailyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleDailyRecurrenceTimeWindow':
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleDailyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleDailyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleDailyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleDailyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_month: int,
                 recurrence_range: 'outputs.MaintenanceScheduleMonthlyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleMonthlyRecurrenceTimeWindow'):
        pulumi.set(__self__, "day_of_month", day_of_month)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> int:
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleMonthlyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleMonthlyRecurrenceTimeWindow':
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleMonthlyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleMonthlyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleMonthlyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleMonthlyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleOnceRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleOnceRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleOnceRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleOnceRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "recurrenceRange":
            suggest = "recurrence_range"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: str,
                 recurrence_range: 'outputs.MaintenanceScheduleWeeklyRecurrenceRecurrenceRange',
                 time_window: 'outputs.MaintenanceScheduleWeeklyRecurrenceTimeWindow'):
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "recurrence_range", recurrence_range)
        pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> str:
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="recurrenceRange")
    def recurrence_range(self) -> 'outputs.MaintenanceScheduleWeeklyRecurrenceRecurrenceRange':
        return pulumi.get(self, "recurrence_range")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.MaintenanceScheduleWeeklyRecurrenceTimeWindow':
        return pulumi.get(self, "time_window")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrenceRecurrenceRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrenceRecurrenceRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrenceRecurrenceRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrenceRecurrenceRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")


@pulumi.output_type
class MaintenanceScheduleWeeklyRecurrenceTimeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleWeeklyRecurrenceTimeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleWeeklyRecurrenceTimeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleWeeklyRecurrenceTimeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 time_zone: str):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MaintenanceWindowMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        """
        :param str cluster_version: Dynatrace server version
        :param Sequence[int] configuration_versions: A Sorted list of the version numbers of the configuration
        :param Sequence[str] current_configuration_versions: A Sorted list of the version numbers of the configuration
        """
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        Dynatrace server version
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        """
        A Sorted list of the version numbers of the configuration
        """
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class MaintenanceWindowSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end: str,
                 recurrence_type: str,
                 start: str,
                 zone_id: str,
                 recurrence: Optional['outputs.MaintenanceWindowScheduleRecurrence'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str end: The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        :param str recurrence_type: The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
        :param str start: The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        :param str zone_id: The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        :param 'MaintenanceWindowScheduleRecurrenceArgs' recurrence: The recurrence of the maintenance window
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "zone_id", zone_id)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> str:
        """
        The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.MaintenanceWindowScheduleRecurrence']:
        """
        The recurrence of the maintenance window
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScheduleRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationMinutes":
            suggest = "duration_minutes"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowScheduleRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowScheduleRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowScheduleRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_minutes: int,
                 start_time: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "duration_minutes", duration_minutes)
        pulumi.set(__self__, "start_time", start_time)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="durationMinutes")
    def duration_minutes(self) -> int:
        return pulumi.get(self, "duration_minutes")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScope(dict):
    def __init__(__self__, *,
                 entities: Optional[Sequence[str]] = None,
                 matches: Optional[Sequence['outputs.MaintenanceWindowScopeMatch']] = None,
                 unknowns: Optional[str] = None):
        """
        :param Sequence[str] entities: A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
        :param Sequence['MaintenanceWindowScopeMatchArgs'] matches: A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if matches is not None:
            pulumi.set(__self__, "matches", matches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence[str]]:
        """
        A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.MaintenanceWindowScopeMatch']]:
        """
        A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScopeMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mzId":
            suggest = "mz_id"
        elif key == "tagCombination":
            suggest = "tag_combination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowScopeMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowScopeMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowScopeMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mz_id: Optional[str] = None,
                 tag_combination: Optional[str] = None,
                 tags: Optional[Sequence['outputs.MaintenanceWindowScopeMatchTag']] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str type: The type of the maintenance: planned or unplanned
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if mz_id is not None:
            pulumi.set(__self__, "mz_id", mz_id)
        if tag_combination is not None:
            pulumi.set(__self__, "tag_combination", tag_combination)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="mzId")
    def mz_id(self) -> Optional[str]:
        return pulumi.get(self, "mz_id")

    @property
    @pulumi.getter(name="tagCombination")
    def tag_combination(self) -> Optional[str]:
        return pulumi.get(self, "tag_combination")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.MaintenanceWindowScopeMatchTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the maintenance: planned or unplanned
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class MaintenanceWindowScopeMatchTag(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneDimensionalRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliesTo":
            suggest = "applies_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneDimensionalRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneDimensionalRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneDimensionalRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applies_to: str,
                 conditions: Optional[Sequence['outputs.ManagementZoneDimensionalRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "applies_to", applies_to)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> str:
        return pulumi.get(self, "applies_to")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ManagementZoneDimensionalRuleCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneDimensionalRuleCondition(dict):
    def __init__(__self__, *,
                 key: str,
                 match: str,
                 type: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def match(self) -> str:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneEntitySelectorBasedRule(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 selector: Optional[str] = None,
                 unknowns: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "configurationVersions":
            suggest = "configuration_versions"
        elif key == "currentConfigurationVersions":
            suggest = "current_configuration_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_version: Optional[str] = None,
                 configuration_versions: Optional[Sequence[int]] = None,
                 current_configuration_versions: Optional[Sequence[str]] = None):
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if configuration_versions is not None:
            pulumi.set(__self__, "configuration_versions", configuration_versions)
        if current_configuration_versions is not None:
            pulumi.set(__self__, "current_configuration_versions", current_configuration_versions)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="configurationVersions")
    def configuration_versions(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "configuration_versions")

    @property
    @pulumi.getter(name="currentConfigurationVersions")
    def current_configuration_versions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "current_configuration_versions")


@pulumi.output_type
class ManagementZoneRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagationTypes":
            suggest = "propagation_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 conditions: Optional[Sequence['outputs.ManagementZoneRuleCondition']] = None,
                 enabled: Optional[bool] = None,
                 propagation_types: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if propagation_types is not None:
            pulumi.set(__self__, "propagation_types", propagation_types)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ManagementZoneRuleCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propagationTypes")
    def propagation_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "propagation_types")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ManagementZoneRuleConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ManagementZoneRuleConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ManagementZoneRuleConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ManagementZoneRuleConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ManagementZoneRuleConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ManagementZoneRuleConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ManagementZoneRuleConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ManagementZoneRuleConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ManagementZoneRuleConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ManagementZoneRuleConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ManagementZoneRuleConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ManagementZoneRuleConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ManagementZoneRuleConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ManagementZoneRuleConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ManagementZoneRuleConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ManagementZoneRuleConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ManagementZoneRuleConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ManagementZoneRuleConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ManagementZoneRuleConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ManagementZoneRuleConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ManagementZoneRuleConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ManagementZoneRuleConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementZoneRuleConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementZoneRuleConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementZoneRuleConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class MobileApplicationApdex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratedOnError":
            suggest = "frustrated_on_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationApdex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationApdex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationApdex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrated: int,
                 tolerable: int,
                 frustrated_on_error: Optional[bool] = None):
        """
        :param int frustrated: Apdex **frustrated** threshold, in milliseconds: a duration greater than or equal to this value is considered frustrated
        :param int tolerable: Apdex **tolerable** threshold, in milliseconds: a duration greater than or equal to this value is considered tolerable
        :param bool frustrated_on_error: Apdex error condition: if `true` the user session is considered frustrated when an error is reported
        """
        pulumi.set(__self__, "frustrated", frustrated)
        pulumi.set(__self__, "tolerable", tolerable)
        if frustrated_on_error is not None:
            pulumi.set(__self__, "frustrated_on_error", frustrated_on_error)

    @property
    @pulumi.getter
    def frustrated(self) -> int:
        """
        Apdex **frustrated** threshold, in milliseconds: a duration greater than or equal to this value is considered frustrated
        """
        return pulumi.get(self, "frustrated")

    @property
    @pulumi.getter
    def tolerable(self) -> int:
        """
        Apdex **tolerable** threshold, in milliseconds: a duration greater than or equal to this value is considered tolerable
        """
        return pulumi.get(self, "tolerable")

    @property
    @pulumi.getter(name="frustratedOnError")
    def frustrated_on_error(self) -> Optional[bool]:
        """
        Apdex error condition: if `true` the user session is considered frustrated when an error is reported
        """
        return pulumi.get(self, "frustrated_on_error")


@pulumi.output_type
class MobileApplicationProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiValues":
            suggest = "api_values"
        elif key == "requestAttributes":
            suggest = "request_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_values: Optional[Sequence['outputs.MobileApplicationPropertiesApiValue']] = None,
                 request_attributes: Optional[Sequence['outputs.MobileApplicationPropertiesRequestAttribute']] = None):
        """
        :param Sequence['MobileApplicationPropertiesApiValueArgs'] api_values: A User Action / Session Property based on a value reported by the API
        :param Sequence['MobileApplicationPropertiesRequestAttributeArgs'] request_attributes: A User Action / Session Property based on a Server Side Request Attribute
        """
        if api_values is not None:
            pulumi.set(__self__, "api_values", api_values)
        if request_attributes is not None:
            pulumi.set(__self__, "request_attributes", request_attributes)

    @property
    @pulumi.getter(name="apiValues")
    def api_values(self) -> Optional[Sequence['outputs.MobileApplicationPropertiesApiValue']]:
        """
        A User Action / Session Property based on a value reported by the API
        """
        return pulumi.get(self, "api_values")

    @property
    @pulumi.getter(name="requestAttributes")
    def request_attributes(self) -> Optional[Sequence['outputs.MobileApplicationPropertiesRequestAttribute']]:
        """
        A User Action / Session Property based on a Server Side Request Attribute
        """
        return pulumi.get(self, "request_attributes")


@pulumi.output_type
class MobileApplicationPropertiesApiValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationPropertiesApiValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationPropertiesApiValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationPropertiesApiValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 name: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        """
        :param str name: The name of the application
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the application
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class MobileApplicationPropertiesRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileApplicationPropertiesRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileApplicationPropertiesRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileApplicationPropertiesRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 key: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class NotificationAnsibleTower(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "customMessage":
            suggest = "custom_message"
        elif key == "jobTemplateId":
            suggest = "job_template_id"
        elif key == "jobTemplateUrl":
            suggest = "job_template_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationAnsibleTower. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationAnsibleTower.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationAnsibleTower.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 custom_message: str,
                 job_template_id: int,
                 job_template_url: str,
                 name: str,
                 username: str,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str custom_message: The custom message of the notification.   This message will be displayed in the extra variables **Message** field of your job template.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param int job_template_id: The ID of the target Ansible Tower job template
        :param str job_template_url: The URL of the target Ansible Tower job template
        :param str name: The name of the notification configuration
        :param str username: The username of the Ansible Tower account
        :param str password: The password for the Ansible Tower account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "custom_message", custom_message)
        pulumi.set(__self__, "job_template_id", job_template_id)
        pulumi.set(__self__, "job_template_url", job_template_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter(name="customMessage")
    def custom_message(self) -> str:
        """
        The custom message of the notification.   This message will be displayed in the extra variables **Message** field of your job template.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "custom_message")

    @property
    @pulumi.getter(name="jobTemplateId")
    def job_template_id(self) -> int:
        """
        The ID of the target Ansible Tower job template
        """
        return pulumi.get(self, "job_template_id")

    @property
    @pulumi.getter(name="jobTemplateUrl")
    def job_template_url(self) -> str:
        """
        The URL of the target Ansible Tower job template
        """
        return pulumi.get(self, "job_template_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the Ansible Tower account
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the Ansible Tower account
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 type: str,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str type: Defines the actual set of fields depending on the value. See one of the following objects:  * `EMAIL` > EmailNotificationConfig  * `PAGER_DUTY` > PagerDutyNotificationConfig  * `WEBHOOK` > WebHookNotificationConfig  * `SLACK` > SlackNotificationConfig  * `HIPCHAT` > HipChatNotificationConfig  * `VICTOROPS` > VictorOpsNotificationConfig  * `SERVICE_NOW` > ServiceNowNotificationConfig  * `XMATTERS` > XMattersNotificationConfig  * `ANSIBLETOWER` > AnsibleTowerNotificationConfig  * `OPS_GENIE` > OpsGenieNotificationConfig  * `JIRA` > JiraNotificationConfig  * `TRELLO` > TrelloNotificationConfig
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the actual set of fields depending on the value. See one of the following objects:  * `EMAIL` > EmailNotificationConfig  * `PAGER_DUTY` > PagerDutyNotificationConfig  * `WEBHOOK` > WebHookNotificationConfig  * `SLACK` > SlackNotificationConfig  * `HIPCHAT` > HipChatNotificationConfig  * `VICTOROPS` > VictorOpsNotificationConfig  * `SERVICE_NOW` > ServiceNowNotificationConfig  * `XMATTERS` > XMattersNotificationConfig  * `ANSIBLETOWER` > AnsibleTowerNotificationConfig  * `OPS_GENIE` > OpsGenieNotificationConfig  * `JIRA` > JiraNotificationConfig  * `TRELLO` > TrelloNotificationConfig
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationEmail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "bccReceivers":
            suggest = "bcc_receivers"
        elif key == "ccReceivers":
            suggest = "cc_receivers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationEmail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationEmail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationEmail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 body: str,
                 name: str,
                 subject: str,
                 bcc_receivers: Optional[Sequence[str]] = None,
                 cc_receivers: Optional[Sequence[str]] = None,
                 receivers: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str body: The template of the email notification.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str name: The name of the notification configuration
        :param str subject: The subject of the email notifications
        :param Sequence[str] bcc_receivers: The list of the email BCC-recipients
        :param Sequence[str] cc_receivers: The list of the email CC-recipients
        :param Sequence[str] receivers: The list of the email recipients
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if bcc_receivers is not None:
            pulumi.set(__self__, "bcc_receivers", bcc_receivers)
        if cc_receivers is not None:
            pulumi.set(__self__, "cc_receivers", cc_receivers)
        if receivers is not None:
            pulumi.set(__self__, "receivers", receivers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def body(self) -> str:
        """
        The template of the email notification.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject of the email notifications
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="bccReceivers")
    def bcc_receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email BCC-recipients
        """
        return pulumi.get(self, "bcc_receivers")

    @property
    @pulumi.getter(name="ccReceivers")
    def cc_receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email CC-recipients
        """
        return pulumi.get(self, "cc_receivers")

    @property
    @pulumi.getter
    def receivers(self) -> Optional[Sequence[str]]:
        """
        The list of the email recipients
        """
        return pulumi.get(self, "receivers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationHipchat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationHipchat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationHipchat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationHipchat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 message: str,
                 name: str,
                 unknowns: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str message: The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str name: The name of the notification configuration
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str url: The URL of the HipChat WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the HipChat WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class NotificationJira(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "issueType":
            suggest = "issue_type"
        elif key == "projectKey":
            suggest = "project_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationJira. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationJira.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationJira.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 description: str,
                 issue_type: str,
                 name: str,
                 project_key: str,
                 summary: str,
                 url: str,
                 username: str,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str description: The description of the Jira issue to be created by this notification.   You can use same placeholders as in issue summary
        :param str issue_type: The type of the Jira issue to be created by this notification
        :param str name: The name of the notification configuration
        :param str project_key: The project key of the Jira issue to be created by this notification
        :param str summary: The summary of the Jira issue to be created by this notification.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the Jira API endpoint
        :param str username: The username of the Jira profile
        :param str password: The password for the Jira profile
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "issue_type", issue_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_key", project_key)
        pulumi.set(__self__, "summary", summary)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Jira issue to be created by this notification.   You can use same placeholders as in issue summary
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> str:
        """
        The type of the Jira issue to be created by this notification
        """
        return pulumi.get(self, "issue_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> str:
        """
        The project key of the Jira issue to be created by this notification
        """
        return pulumi.get(self, "project_key")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        The summary of the Jira issue to be created by this notification.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the Jira API endpoint
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the Jira profile
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for the Jira profile
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationOpsGenie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationOpsGenie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationOpsGenie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationOpsGenie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 domain: str,
                 message: str,
                 name: str,
                 api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str domain: The region domain of the OpsGenie
        :param str message: The content of the message.  You can use the following placeholders:  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem
        :param str name: The name of the notification configuration
        :param str api_key: The API key to access OpsGenie
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The region domain of the OpsGenie
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        The API key to access OpsGenie
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationPagerDuty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceApiKey":
            suggest = "service_api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationPagerDuty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationPagerDuty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationPagerDuty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 service_name: str,
                 service_api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str account: The name of the PagerDuty account
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str service_name: The name of the service
        :param str service_api_key: The API key to access PagerDuty
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_name", service_name)
        if service_api_key is not None:
            pulumi.set(__self__, "service_api_key", service_api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        The name of the PagerDuty account
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        The name of the service
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceApiKey")
    def service_api_key(self) -> Optional[str]:
        """
        The API key to access PagerDuty
        """
        return pulumi.get(self, "service_api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationServiceNow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "sendEvents":
            suggest = "send_events"
        elif key == "sendIncidents":
            suggest = "send_incidents"
        elif key == "instanceName":
            suggest = "instance_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationServiceNow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationServiceNow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationServiceNow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 message: str,
                 name: str,
                 send_events: bool,
                 send_incidents: bool,
                 username: str,
                 instance_name: Optional[str] = None,
                 password: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str message: The content of the ServiceNow description.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str name: The name of the notification configuration
        :param bool send_events: Send events into ServiceNow ITOM (`true`)
        :param bool send_incidents: Send incidents into ServiceNow ITSM (`true`)
        :param str username: The username of the ServiceNow account.   Make sure that your user account has the `rest_service`, `web_request_admin`, and `x_dynat_ruxit.Integration` roles
        :param str instance_name: The ServiceNow instance identifier. It refers to the first part of your own ServiceNow URL.   This field is mutually exclusive with the **url** field. You can only use one of them
        :param str password: The username to the ServiceNow account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str url: The URL of the on-premise ServiceNow installation.   This field is mutually exclusive with the **instanceName** field. You can only use one of them
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "send_events", send_events)
        pulumi.set(__self__, "send_incidents", send_incidents)
        pulumi.set(__self__, "username", username)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the ServiceNow description.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sendEvents")
    def send_events(self) -> bool:
        """
        Send events into ServiceNow ITOM (`true`)
        """
        return pulumi.get(self, "send_events")

    @property
    @pulumi.getter(name="sendIncidents")
    def send_incidents(self) -> bool:
        """
        Send incidents into ServiceNow ITSM (`true`)
        """
        return pulumi.get(self, "send_incidents")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the ServiceNow account.   Make sure that your user account has the `rest_service`, `web_request_admin`, and `x_dynat_ruxit.Integration` roles
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[str]:
        """
        The ServiceNow instance identifier. It refers to the first part of your own ServiceNow URL.   This field is mutually exclusive with the **url** field. You can only use one of them
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The username to the ServiceNow account
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the on-premise ServiceNow installation.   This field is mutually exclusive with the **instanceName** field. You can only use one of them
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class NotificationSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 channel: str,
                 name: str,
                 title: str,
                 unknowns: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str channel: The channel (for example, `#general`) or the user (for example, `@john.smith`) to send the message to
        :param str name: The name of the notification configuration
        :param str title: The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        :param str url: The URL of the Slack WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "title", title)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def channel(self) -> str:
        """
        The channel (for example, `#general`) or the user (for example, `@john.smith`) to send the message to
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the Slack WebHook.  This is confidential information, therefore GET requests return this field with the `null` value, and it is optional for PUT requests
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class NotificationTrello(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "applicationKey":
            suggest = "application_key"
        elif key == "boardId":
            suggest = "board_id"
        elif key == "listId":
            suggest = "list_id"
        elif key == "resolvedListId":
            suggest = "resolved_list_id"
        elif key == "authorizationToken":
            suggest = "authorization_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationTrello. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationTrello.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationTrello.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 application_key: str,
                 board_id: str,
                 description: str,
                 list_id: str,
                 name: str,
                 resolved_list_id: str,
                 text: str,
                 authorization_token: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str application_key: The application key for the Trello account
        :param str board_id: The Trello board to which the card should be assigned
        :param str description: The description of the Trello card.   You can use same placeholders as in card text
        :param str list_id: The Trello list to which the card should be assigned
        :param str name: The name of the notification configuration
        :param str resolved_list_id: The Trello list to which the card of the resolved problem should be assigned
        :param str text: The text of the generated Trello card.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str authorization_token: The application token for the Trello account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "application_key", application_key)
        pulumi.set(__self__, "board_id", board_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "list_id", list_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resolved_list_id", resolved_list_id)
        pulumi.set(__self__, "text", text)
        if authorization_token is not None:
            pulumi.set(__self__, "authorization_token", authorization_token)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter(name="applicationKey")
    def application_key(self) -> str:
        """
        The application key for the Trello account
        """
        return pulumi.get(self, "application_key")

    @property
    @pulumi.getter(name="boardId")
    def board_id(self) -> str:
        """
        The Trello board to which the card should be assigned
        """
        return pulumi.get(self, "board_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Trello card.   You can use same placeholders as in card text
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="listId")
    def list_id(self) -> str:
        """
        The Trello list to which the card should be assigned
        """
        return pulumi.get(self, "list_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resolvedListId")
    def resolved_list_id(self) -> str:
        """
        The Trello list to which the card of the resolved problem should be assigned
        """
        return pulumi.get(self, "resolved_list_id")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text of the generated Trello card.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter(name="authorizationToken")
    def authorization_token(self) -> Optional[str]:
        """
        The application token for the Trello account
        """
        return pulumi.get(self, "authorization_token")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationVictorOps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "routingKey":
            suggest = "routing_key"
        elif key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationVictorOps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationVictorOps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationVictorOps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 alerting_profile: str,
                 message: str,
                 name: str,
                 routing_key: str,
                 api_key: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str message: The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`
        :param str name: The name of the notification configuration
        :param str routing_key: The routing key, defining the group to be notified
        :param str api_key: The API key for the target VictorOps account
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routing_key", routing_key)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The content of the message.  You can use the following placeholders:  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        The routing key, defining the group to be notified
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        The API key for the target VictorOps account
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationWebHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"
        elif key == "notifyEventMerges":
            suggest = "notify_event_merges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationWebHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationWebHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationWebHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 payload: str,
                 url: str,
                 headers: Optional[Sequence['outputs.NotificationWebHookHeader']] = None,
                 notify_event_merges: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str payload: The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the WebHook endpoint
        :param Sequence['NotificationWebHookHeaderArgs'] headers: A list of the additional HTTP headers
        :param bool notify_event_merges: Call webhook if new events merge into existing problems
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if notify_event_merges is not None:
            pulumi.set(__self__, "notify_event_merges", notify_event_merges)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the WebHook endpoint
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.NotificationWebHookHeader']]:
        """
        A list of the additional HTTP headers
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="notifyEventMerges")
    def notify_event_merges(self) -> Optional[bool]:
        """
        Call webhook if new events merge into existing problems
        """
        return pulumi.get(self, "notify_event_merges")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationWebHookHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationXmatters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAnyCertificate":
            suggest = "accept_any_certificate"
        elif key == "alertingProfile":
            suggest = "alerting_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationXmatters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationXmatters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationXmatters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept_any_certificate: bool,
                 active: bool,
                 alerting_profile: str,
                 name: str,
                 payload: str,
                 url: str,
                 headers: Optional[Sequence['outputs.NotificationXmattersHeader']] = None,
                 unknowns: Optional[str] = None):
        """
        :param bool accept_any_certificate: Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        :param bool active: The configuration is enabled (`true`) or disabled (`false`)
        :param str alerting_profile: The ID of the associated alerting profile
        :param str name: The name of the notification configuration
        :param str payload: The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        :param str url: The URL of the xMatters WebHook
        :param Sequence['NotificationXmattersHeaderArgs'] headers: A list of the additional HTTP headers
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "accept_any_certificate", accept_any_certificate)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "alerting_profile", alerting_profile)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="acceptAnyCertificate")
    def accept_any_certificate(self) -> bool:
        """
        Accept any, including self-signed and invalid, SSL certificate (`true`) or only trusted (`false`) certificates
        """
        return pulumi.get(self, "accept_any_certificate")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        The configuration is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="alertingProfile")
    def alerting_profile(self) -> str:
        """
        The ID of the associated alerting profile
        """
        return pulumi.get(self, "alerting_profile")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        The content of the notification message.  You can use the following placeholders:  * `{ImpactedEntities}`: Details about the entities impacted by the problem in form of a JSON array.  * `{ImpactedEntity}`: The entity impacted by the problem or *X* impacted entities.  * `{PID}`: The ID of the reported problem.  * `{ProblemDetailsHTML}`: All problem event details, including root cause, as an HTML-formatted string.  * `{ProblemDetailsJSON}`: All problem event details, including root cause, as a JSON object.  * `{ProblemDetailsMarkdown}`: All problem event details, including root cause, as a [Markdown-formatted](https://www.markdownguide.org/cheat-sheet/) string.  * `{ProblemDetailsText}`: All problem event details, including root cause, as a text-formatted string.  * `{ProblemID}`: The display number of the reported problem.  * `{ProblemImpact}`: The [impact level](https://www.dynatrace.com/support/help/shortlink/impact-analysis) of the problem. Possible values are `APPLICATION`, `SERVICE`, and `INFRASTRUCTURE`.  * `{ProblemSeverity}`: The [severity level](https://www.dynatrace.com/support/help/shortlink/event-types) of the problem. Possible values are `AVAILABILITY`, `ERROR`, `PERFORMANCE`, `RESOURCE_CONTENTION`, and `CUSTOM_ALERT`.  * `{ProblemTitle}`: A short description of the problem.  * `{ProblemURL}`: The URL of the problem within Dynatrace.  * `{State}`: The state of the problem. Possible values are `OPEN` and `RESOLVED`.  * `{Tags}`: The list of tags that are defined for all impacted entities, separated by commas
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the xMatters WebHook
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.NotificationXmattersHeader']]:
        """
        A list of the additional HTTP headers
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class NotificationXmattersHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ProcessgroupNamingConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ProcessgroupNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ProcessgroupNamingConditionConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ProcessgroupNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ProcessgroupNamingConditionConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ProcessgroupNamingConditionConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ProcessgroupNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProcessgroupNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProcessgroupNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProcessgroupNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class QueueManagerAliasQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasQueues":
            suggest = "alias_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerAliasQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerAliasQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerAliasQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_queues: Optional[Sequence['outputs.QueueManagerAliasQueueAliasQueue']] = None):
        """
        :param Sequence['QueueManagerAliasQueueAliasQueueArgs'] alias_queues: Alias queue definitions for queue manager
        """
        if alias_queues is not None:
            pulumi.set(__self__, "alias_queues", alias_queues)

    @property
    @pulumi.getter(name="aliasQueues")
    def alias_queues(self) -> Optional[Sequence['outputs.QueueManagerAliasQueueAliasQueue']]:
        """
        Alias queue definitions for queue manager
        """
        return pulumi.get(self, "alias_queues")


@pulumi.output_type
class QueueManagerAliasQueueAliasQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasQueueName":
            suggest = "alias_queue_name"
        elif key == "baseQueueName":
            suggest = "base_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerAliasQueueAliasQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerAliasQueueAliasQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerAliasQueueAliasQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_queue_name: str,
                 base_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "alias_queue_name", alias_queue_name)
        pulumi.set(__self__, "base_queue_name", base_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="aliasQueueName")
    def alias_queue_name(self) -> str:
        return pulumi.get(self, "alias_queue_name")

    @property
    @pulumi.getter(name="baseQueueName")
    def base_queue_name(self) -> str:
        return pulumi.get(self, "base_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class QueueManagerClusterQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterQueues":
            suggest = "cluster_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerClusterQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerClusterQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerClusterQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_queues: Optional[Sequence['outputs.QueueManagerClusterQueueClusterQueue']] = None):
        """
        :param Sequence['QueueManagerClusterQueueClusterQueueArgs'] cluster_queues: Cluster queue definitions for queue manager
        """
        if cluster_queues is not None:
            pulumi.set(__self__, "cluster_queues", cluster_queues)

    @property
    @pulumi.getter(name="clusterQueues")
    def cluster_queues(self) -> Optional[Sequence['outputs.QueueManagerClusterQueueClusterQueue']]:
        """
        Cluster queue definitions for queue manager
        """
        return pulumi.get(self, "cluster_queues")


@pulumi.output_type
class QueueManagerClusterQueueClusterQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localQueueName":
            suggest = "local_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerClusterQueueClusterQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerClusterQueueClusterQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerClusterQueueClusterQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "local_queue_name", local_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="localQueueName")
    def local_queue_name(self) -> str:
        return pulumi.get(self, "local_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class QueueManagerRemoteQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteQueues":
            suggest = "remote_queues"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerRemoteQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerRemoteQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerRemoteQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_queues: Optional[Sequence['outputs.QueueManagerRemoteQueueRemoteQueue']] = None):
        """
        :param Sequence['QueueManagerRemoteQueueRemoteQueueArgs'] remote_queues: Remote queue definitions for queue manager
        """
        if remote_queues is not None:
            pulumi.set(__self__, "remote_queues", remote_queues)

    @property
    @pulumi.getter(name="remoteQueues")
    def remote_queues(self) -> Optional[Sequence['outputs.QueueManagerRemoteQueueRemoteQueue']]:
        """
        Remote queue definitions for queue manager
        """
        return pulumi.get(self, "remote_queues")


@pulumi.output_type
class QueueManagerRemoteQueueRemoteQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localQueueName":
            suggest = "local_queue_name"
        elif key == "remoteQueueManager":
            suggest = "remote_queue_manager"
        elif key == "remoteQueueName":
            suggest = "remote_queue_name"
        elif key == "clusterVisibilities":
            suggest = "cluster_visibilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueManagerRemoteQueueRemoteQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueManagerRemoteQueueRemoteQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueManagerRemoteQueueRemoteQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_queue_name: str,
                 remote_queue_manager: str,
                 remote_queue_name: str,
                 cluster_visibilities: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "local_queue_name", local_queue_name)
        pulumi.set(__self__, "remote_queue_manager", remote_queue_manager)
        pulumi.set(__self__, "remote_queue_name", remote_queue_name)
        if cluster_visibilities is not None:
            pulumi.set(__self__, "cluster_visibilities", cluster_visibilities)

    @property
    @pulumi.getter(name="localQueueName")
    def local_queue_name(self) -> str:
        return pulumi.get(self, "local_queue_name")

    @property
    @pulumi.getter(name="remoteQueueManager")
    def remote_queue_manager(self) -> str:
        return pulumi.get(self, "remote_queue_manager")

    @property
    @pulumi.getter(name="remoteQueueName")
    def remote_queue_name(self) -> str:
        return pulumi.get(self, "remote_queue_name")

    @property
    @pulumi.getter(name="clusterVisibilities")
    def cluster_visibilities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cluster_visibilities")


@pulumi.output_type
class RequestAttributeDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capturingAndStorageLocation":
            suggest = "capturing_and_storage_location"
        elif key == "cicsSdkMethodNodeCondition":
            suggest = "cics_sdk_method_node_condition"
        elif key == "iibLabelMethodNodeCondition":
            suggest = "iib_label_method_node_condition"
        elif key == "iibMethodNodeCondition":
            suggest = "iib_method_node_condition"
        elif key == "iibNodeType":
            suggest = "iib_node_type"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "sessionAttributeTechnology":
            suggest = "session_attribute_technology"
        elif key == "valueProcessing":
            suggest = "value_processing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 source: str,
                 capturing_and_storage_location: Optional[str] = None,
                 cics_sdk_method_node_condition: Optional['outputs.RequestAttributeDataSourceCicsSdkMethodNodeCondition'] = None,
                 iib_label_method_node_condition: Optional['outputs.RequestAttributeDataSourceIibLabelMethodNodeCondition'] = None,
                 iib_method_node_condition: Optional['outputs.RequestAttributeDataSourceIibMethodNodeCondition'] = None,
                 iib_node_type: Optional[str] = None,
                 methods: Optional[Sequence['outputs.RequestAttributeDataSourceMethod']] = None,
                 parameter_name: Optional[str] = None,
                 scope: Optional['outputs.RequestAttributeDataSourceScope'] = None,
                 session_attribute_technology: Optional[str] = None,
                 technology: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value_processing: Optional['outputs.RequestAttributeDataSourceValueProcessing'] = None):
        """
        :param bool enabled: The data source is enabled (`true`) or disabled (`false`)
        :param str source: The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
        :param str capturing_and_storage_location: Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
        :param 'RequestAttributeDataSourceCicsSdkMethodNodeConditionArgs' cics_sdk_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param 'RequestAttributeDataSourceIibLabelMethodNodeConditionArgs' iib_label_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param 'RequestAttributeDataSourceIibMethodNodeConditionArgs' iib_method_node_condition: IBM integration bus label node name condition for which the value is captured
        :param str iib_node_type: The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
        :param Sequence['RequestAttributeDataSourceMethodArgs'] methods: The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
        :param str parameter_name: The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
        :param 'RequestAttributeDataSourceScopeArgs' scope: Conditions for data capturing
        :param str session_attribute_technology: The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "source", source)
        if capturing_and_storage_location is not None:
            pulumi.set(__self__, "capturing_and_storage_location", capturing_and_storage_location)
        if cics_sdk_method_node_condition is not None:
            pulumi.set(__self__, "cics_sdk_method_node_condition", cics_sdk_method_node_condition)
        if iib_label_method_node_condition is not None:
            pulumi.set(__self__, "iib_label_method_node_condition", iib_label_method_node_condition)
        if iib_method_node_condition is not None:
            pulumi.set(__self__, "iib_method_node_condition", iib_method_node_condition)
        if iib_node_type is not None:
            pulumi.set(__self__, "iib_node_type", iib_node_type)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if parameter_name is not None:
            pulumi.set(__self__, "parameter_name", parameter_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if session_attribute_technology is not None:
            pulumi.set(__self__, "session_attribute_technology", session_attribute_technology)
        if technology is not None:
            pulumi.set(__self__, "technology", technology)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_processing is not None:
            pulumi.set(__self__, "value_processing", value_processing)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The data source is enabled (`true`) or disabled (`false`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="capturingAndStorageLocation")
    def capturing_and_storage_location(self) -> Optional[str]:
        """
        Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
        """
        return pulumi.get(self, "capturing_and_storage_location")

    @property
    @pulumi.getter(name="cicsSdkMethodNodeCondition")
    def cics_sdk_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceCicsSdkMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "cics_sdk_method_node_condition")

    @property
    @pulumi.getter(name="iibLabelMethodNodeCondition")
    def iib_label_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceIibLabelMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "iib_label_method_node_condition")

    @property
    @pulumi.getter(name="iibMethodNodeCondition")
    def iib_method_node_condition(self) -> Optional['outputs.RequestAttributeDataSourceIibMethodNodeCondition']:
        """
        IBM integration bus label node name condition for which the value is captured
        """
        return pulumi.get(self, "iib_method_node_condition")

    @property
    @pulumi.getter(name="iibNodeType")
    def iib_node_type(self) -> Optional[str]:
        """
        The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
        """
        return pulumi.get(self, "iib_node_type")

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence['outputs.RequestAttributeDataSourceMethod']]:
        """
        The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
        """
        return pulumi.get(self, "methods")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        """
        The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
        """
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.RequestAttributeDataSourceScope']:
        """
        Conditions for data capturing
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sessionAttributeTechnology")
    def session_attribute_technology(self) -> Optional[str]:
        """
        The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
        """
        return pulumi.get(self, "session_attribute_technology")

    @property
    @pulumi.getter
    def technology(self) -> Optional[str]:
        return pulumi.get(self, "technology")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueProcessing")
    def value_processing(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessing']:
        return pulumi.get(self, "value_processing")


@pulumi.output_type
class RequestAttributeDataSourceCicsSdkMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceIibLabelMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceIibMethodNodeCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "argumentIndex":
            suggest = "argument_index"
        elif key == "deepObjectAccess":
            suggest = "deep_object_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture: str,
                 argument_index: Optional[int] = None,
                 deep_object_access: Optional[str] = None,
                 method: Optional['outputs.RequestAttributeDataSourceMethodMethod'] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "capture", capture)
        if argument_index is not None:
            pulumi.set(__self__, "argument_index", argument_index)
        if deep_object_access is not None:
            pulumi.set(__self__, "deep_object_access", deep_object_access)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def capture(self) -> str:
        return pulumi.get(self, "capture")

    @property
    @pulumi.getter(name="argumentIndex")
    def argument_index(self) -> Optional[int]:
        return pulumi.get(self, "argument_index")

    @property
    @pulumi.getter(name="deepObjectAccess")
    def deep_object_access(self) -> Optional[str]:
        return pulumi.get(self, "deep_object_access")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RequestAttributeDataSourceMethodMethod']:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceMethodMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "methodName":
            suggest = "method_name"
        elif key == "returnType":
            suggest = "return_type"
        elif key == "argumentTypes":
            suggest = "argument_types"
        elif key == "className":
            suggest = "class_name"
        elif key == "fileName":
            suggest = "file_name"
        elif key == "fileNameMatcher":
            suggest = "file_name_matcher"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceMethodMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceMethodMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceMethodMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method_name: str,
                 return_type: str,
                 visibility: str,
                 argument_types: Optional[Sequence[str]] = None,
                 class_name: Optional[str] = None,
                 file_name: Optional[str] = None,
                 file_name_matcher: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "method_name", method_name)
        pulumi.set(__self__, "return_type", return_type)
        pulumi.set(__self__, "visibility", visibility)
        if argument_types is not None:
            pulumi.set(__self__, "argument_types", argument_types)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if file_name_matcher is not None:
            pulumi.set(__self__, "file_name_matcher", file_name_matcher)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="methodName")
    def method_name(self) -> str:
        return pulumi.get(self, "method_name")

    @property
    @pulumi.getter(name="returnType")
    def return_type(self) -> str:
        return pulumi.get(self, "return_type")

    @property
    @pulumi.getter
    def visibility(self) -> str:
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter(name="argumentTypes")
    def argument_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "argument_types")

    @property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[str]:
        return pulumi.get(self, "class_name")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[str]:
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="fileNameMatcher")
    def file_name_matcher(self) -> Optional[str]:
        return pulumi.get(self, "file_name_matcher")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostGroup":
            suggest = "host_group"
        elif key == "processGroup":
            suggest = "process_group"
        elif key == "serviceTechnology":
            suggest = "service_technology"
        elif key == "tagOfProcessGroup":
            suggest = "tag_of_process_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_group: Optional[str] = None,
                 process_group: Optional[str] = None,
                 service_technology: Optional[str] = None,
                 tag_of_process_group: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if host_group is not None:
            pulumi.set(__self__, "host_group", host_group)
        if process_group is not None:
            pulumi.set(__self__, "process_group", process_group)
        if service_technology is not None:
            pulumi.set(__self__, "service_technology", service_technology)
        if tag_of_process_group is not None:
            pulumi.set(__self__, "tag_of_process_group", tag_of_process_group)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="hostGroup")
    def host_group(self) -> Optional[str]:
        return pulumi.get(self, "host_group")

    @property
    @pulumi.getter(name="processGroup")
    def process_group(self) -> Optional[str]:
        return pulumi.get(self, "process_group")

    @property
    @pulumi.getter(name="serviceTechnology")
    def service_technology(self) -> Optional[str]:
        return pulumi.get(self, "service_technology")

    @property
    @pulumi.getter(name="tagOfProcessGroup")
    def tag_of_process_group(self) -> Optional[str]:
        return pulumi.get(self, "tag_of_process_group")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extractSubstring":
            suggest = "extract_substring"
        elif key == "splitAt":
            suggest = "split_at"
        elif key == "valueCondition":
            suggest = "value_condition"
        elif key == "valueExtractorRegex":
            suggest = "value_extractor_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceValueProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceValueProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceValueProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extract_substring: Optional['outputs.RequestAttributeDataSourceValueProcessingExtractSubstring'] = None,
                 split_at: Optional[str] = None,
                 trim: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value_condition: Optional['outputs.RequestAttributeDataSourceValueProcessingValueCondition'] = None,
                 value_extractor_regex: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        if extract_substring is not None:
            pulumi.set(__self__, "extract_substring", extract_substring)
        if split_at is not None:
            pulumi.set(__self__, "split_at", split_at)
        if trim is not None:
            pulumi.set(__self__, "trim", trim)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value_condition is not None:
            pulumi.set(__self__, "value_condition", value_condition)
        if value_extractor_regex is not None:
            pulumi.set(__self__, "value_extractor_regex", value_extractor_regex)

    @property
    @pulumi.getter(name="extractSubstring")
    def extract_substring(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessingExtractSubstring']:
        return pulumi.get(self, "extract_substring")

    @property
    @pulumi.getter(name="splitAt")
    def split_at(self) -> Optional[str]:
        return pulumi.get(self, "split_at")

    @property
    @pulumi.getter
    def trim(self) -> Optional[bool]:
        return pulumi.get(self, "trim")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="valueCondition")
    def value_condition(self) -> Optional['outputs.RequestAttributeDataSourceValueProcessingValueCondition']:
        return pulumi.get(self, "value_condition")

    @property
    @pulumi.getter(name="valueExtractorRegex")
    def value_extractor_regex(self) -> Optional[str]:
        return pulumi.get(self, "value_extractor_regex")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessingExtractSubstring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDelimiter":
            suggest = "end_delimiter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestAttributeDataSourceValueProcessingExtractSubstring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestAttributeDataSourceValueProcessingExtractSubstring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestAttributeDataSourceValueProcessingExtractSubstring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: str,
                 position: str,
                 end_delimiter: Optional[str] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "position", position)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter
    def position(self) -> str:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestAttributeDataSourceValueProcessingValueCondition(dict):
    def __init__(__self__, *,
                 operator: str,
                 value: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        """
        :param str unknowns: allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        """
        allows for configuring properties that are not explicitly supported by the current version of this provider
        """
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditions(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.RequestNamingConditionsCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.RequestNamingConditionsCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class RequestNamingConditionsCondition(dict):
    def __init__(__self__, *,
                 attribute: str,
                 comparison: 'outputs.RequestNamingConditionsConditionComparison'):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "comparison", comparison)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def comparison(self) -> 'outputs.RequestNamingConditionsConditionComparison':
        return pulumi.get(self, "comparison")


@pulumi.output_type
class RequestNamingConditionsConditionComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "esbInputNodeType":
            suggest = "esb_input_node_type"
        elif key == "failedState":
            suggest = "failed_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "fastString":
            suggest = "fast_string"
        elif key == "flawState":
            suggest = "flaw_state"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "httpStatusClass":
            suggest = "http_status_class"
        elif key == "iibInputNodeType":
            suggest = "iib_input_node_type"
        elif key == "numberRequestAttribute":
            suggest = "number_request_attribute"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "stringRequestAttribute":
            suggest = "string_request_attribute"
        elif key == "zosCallType":
            suggest = "zos_call_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean: Optional['outputs.RequestNamingConditionsConditionComparisonBoolean'] = None,
                 esb_input_node_type: Optional['outputs.RequestNamingConditionsConditionComparisonEsbInputNodeType'] = None,
                 failed_state: Optional['outputs.RequestNamingConditionsConditionComparisonFailedState'] = None,
                 failure_reason: Optional['outputs.RequestNamingConditionsConditionComparisonFailureReason'] = None,
                 fast_string: Optional['outputs.RequestNamingConditionsConditionComparisonFastString'] = None,
                 flaw_state: Optional['outputs.RequestNamingConditionsConditionComparisonFlawState'] = None,
                 generic: Optional['outputs.RequestNamingConditionsConditionComparisonGeneric'] = None,
                 http_method: Optional['outputs.RequestNamingConditionsConditionComparisonHttpMethod'] = None,
                 http_status_class: Optional['outputs.RequestNamingConditionsConditionComparisonHttpStatusClass'] = None,
                 iib_input_node_type: Optional['outputs.RequestNamingConditionsConditionComparisonIibInputNodeType'] = None,
                 negate: Optional[bool] = None,
                 number: Optional['outputs.RequestNamingConditionsConditionComparisonNumber'] = None,
                 number_request_attribute: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttribute'] = None,
                 service_type: Optional['outputs.RequestNamingConditionsConditionComparisonServiceType'] = None,
                 string: Optional['outputs.RequestNamingConditionsConditionComparisonString'] = None,
                 string_request_attribute: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttribute'] = None,
                 tag: Optional['outputs.RequestNamingConditionsConditionComparisonTag'] = None,
                 zos_call_type: Optional['outputs.RequestNamingConditionsConditionComparisonZosCallType'] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if esb_input_node_type is not None:
            pulumi.set(__self__, "esb_input_node_type", esb_input_node_type)
        if failed_state is not None:
            pulumi.set(__self__, "failed_state", failed_state)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if fast_string is not None:
            pulumi.set(__self__, "fast_string", fast_string)
        if flaw_state is not None:
            pulumi.set(__self__, "flaw_state", flaw_state)
        if generic is not None:
            pulumi.set(__self__, "generic", generic)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if http_status_class is not None:
            pulumi.set(__self__, "http_status_class", http_status_class)
        if iib_input_node_type is not None:
            pulumi.set(__self__, "iib_input_node_type", iib_input_node_type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if number_request_attribute is not None:
            pulumi.set(__self__, "number_request_attribute", number_request_attribute)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_request_attribute is not None:
            pulumi.set(__self__, "string_request_attribute", string_request_attribute)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if zos_call_type is not None:
            pulumi.set(__self__, "zos_call_type", zos_call_type)

    @property
    @pulumi.getter
    def boolean(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonBoolean']:
        return pulumi.get(self, "boolean")

    @property
    @pulumi.getter(name="esbInputNodeType")
    def esb_input_node_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonEsbInputNodeType']:
        return pulumi.get(self, "esb_input_node_type")

    @property
    @pulumi.getter(name="failedState")
    def failed_state(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFailedState']:
        return pulumi.get(self, "failed_state")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFailureReason']:
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="fastString")
    def fast_string(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFastString']:
        return pulumi.get(self, "fast_string")

    @property
    @pulumi.getter(name="flawState")
    def flaw_state(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonFlawState']:
        return pulumi.get(self, "flaw_state")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonGeneric']:
        return pulumi.get(self, "generic")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonHttpMethod']:
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="httpStatusClass")
    def http_status_class(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonHttpStatusClass']:
        return pulumi.get(self, "http_status_class")

    @property
    @pulumi.getter(name="iibInputNodeType")
    def iib_input_node_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonIibInputNodeType']:
        return pulumi.get(self, "iib_input_node_type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def number(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumber']:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="numberRequestAttribute")
    def number_request_attribute(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttribute']:
        return pulumi.get(self, "number_request_attribute")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonServiceType']:
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def string(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonString']:
        return pulumi.get(self, "string")

    @property
    @pulumi.getter(name="stringRequestAttribute")
    def string_request_attribute(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttribute']:
        return pulumi.get(self, "string_request_attribute")

    @property
    @pulumi.getter
    def tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTag']:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="zosCallType")
    def zos_call_type(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonZosCallType']:
        return pulumi.get(self, "zos_call_type")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonBoolean(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[bool] = None,
                 values: Optional[Sequence[bool]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[bool]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonEsbInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFailedState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFailureReason(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFastString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonFastString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonFastString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonFastString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonFlawState(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonGeneric(dict):
    def __init__(__self__, *,
                 type: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonHttpMethod(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonHttpStatusClass(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonIibInputNodeType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumber(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[float] = None,
                 values: Optional[Sequence[float]] = None):
        pulumi.set(__self__, "request_attribute", request_attribute)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[float]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonServiceType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[bool] = None,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchOnChildCalls":
            suggest = "match_on_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_attribute: str,
                 case_sensitive: Optional[bool] = None,
                 match_on_child_calls: Optional[bool] = None,
                 operator: Optional[str] = None,
                 source: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSource'] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "request_attribute", request_attribute)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_on_child_calls is not None:
            pulumi.set(__self__, "match_on_child_calls", match_on_child_calls)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> str:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchOnChildCalls")
    def match_on_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "match_on_child_calls")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttributeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTag(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.RequestNamingConditionsConditionComparisonTagValue'] = None,
                 values: Optional['outputs.RequestNamingConditionsConditionComparisonTagValues'] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTagValue']:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional['outputs.RequestNamingConditionsConditionComparisonTagValues']:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValues(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.RequestNamingConditionsConditionComparisonTagValuesValue']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.RequestNamingConditionsConditionComparisonTagValuesValue']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonTagValuesValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingConditionsConditionComparisonZosCallType(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class RequestNamingPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Optional[Sequence['outputs.RequestNamingPlaceholdersPlaceholder']] = None):
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Optional[Sequence['outputs.RequestNamingPlaceholdersPlaceholder']]:
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimiterOrRegex":
            suggest = "delimiter_or_regex"
        elif key == "endDelimiter":
            suggest = "end_delimiter"
        elif key == "requestAttribute":
            suggest = "request_attribute"
        elif key == "useFromChildCalls":
            suggest = "use_from_child_calls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 kind: str,
                 name: str,
                 aggregation: Optional[str] = None,
                 delimiter_or_regex: Optional[str] = None,
                 end_delimiter: Optional[str] = None,
                 normalization: Optional[str] = None,
                 request_attribute: Optional[str] = None,
                 source: Optional['outputs.RequestNamingPlaceholdersPlaceholderSource'] = None,
                 unknowns: Optional[str] = None,
                 use_from_child_calls: Optional[bool] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if delimiter_or_regex is not None:
            pulumi.set(__self__, "delimiter_or_regex", delimiter_or_regex)
        if end_delimiter is not None:
            pulumi.set(__self__, "end_delimiter", end_delimiter)
        if normalization is not None:
            pulumi.set(__self__, "normalization", normalization)
        if request_attribute is not None:
            pulumi.set(__self__, "request_attribute", request_attribute)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if use_from_child_calls is not None:
            pulumi.set(__self__, "use_from_child_calls", use_from_child_calls)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="delimiterOrRegex")
    def delimiter_or_regex(self) -> Optional[str]:
        return pulumi.get(self, "delimiter_or_regex")

    @property
    @pulumi.getter(name="endDelimiter")
    def end_delimiter(self) -> Optional[str]:
        return pulumi.get(self, "end_delimiter")

    @property
    @pulumi.getter
    def normalization(self) -> Optional[str]:
        return pulumi.get(self, "normalization")

    @property
    @pulumi.getter(name="requestAttribute")
    def request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "request_attribute")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSource']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="useFromChildCalls")
    def use_from_child_calls(self) -> Optional[bool]:
        return pulumi.get(self, "use_from_child_calls")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementZone":
            suggest = "management_zone"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholderSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholderSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholderSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_zone: Optional[str] = None,
                 service_tag: Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTag'] = None,
                 unknowns: Optional[str] = None):
        if management_zone is not None:
            pulumi.set(__self__, "management_zone", management_zone)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="managementZone")
    def management_zone(self) -> Optional[str]:
        return pulumi.get(self, "management_zone")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTag']:
        return pulumi.get(self, "service_tag")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSourceServiceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestNamingPlaceholdersPlaceholderSourceServiceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestNamingPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestNamingPlaceholdersPlaceholderSourceServiceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 context: Optional[str] = None,
                 tag_key: Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey'] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional['outputs.RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey']:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class RequestNamingPlaceholdersPlaceholderSourceServiceTagTagKey(dict):
    def __init__(__self__, *,
                 context: Optional[str] = None,
                 key: Optional[str] = None):
        if context is not None:
            pulumi.set(__self__, "context", context)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class ServiceAnomaliesFailureRates(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ServiceAnomaliesFailureRatesAuto'] = None,
                 thresholds: Optional['outputs.ServiceAnomaliesFailureRatesThresholds'] = None):
        """
        :param 'ServiceAnomaliesFailureRatesAutoArgs' auto: Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        :param 'ServiceAnomaliesFailureRatesThresholdsArgs' thresholds: Fixed thresholds for failure rate increase detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ServiceAnomaliesFailureRatesAuto']:
        """
        Parameters of failure rate increase auto-detection. Example: If the expected error rate is 1.5%, and you set an absolute increase of 1%, and a relative increase of 50%, the thresholds will be:  Absolute: 1.5% + **1%** = 2.5%  Relative: 1.5% + 1.5% * **50%** = 2.25%
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ServiceAnomaliesFailureRatesThresholds']:
        """
        Fixed thresholds for failure rate increase detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ServiceAnomaliesFailureRatesAuto(dict):
    def __init__(__self__, *,
                 absolute: int,
                 relative: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "absolute", absolute)
        pulumi.set(__self__, "relative", relative)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def absolute(self) -> int:
        return pulumi.get(self, "absolute")

    @property
    @pulumi.getter
    def relative(self) -> int:
        return pulumi.get(self, "relative")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesFailureRatesThresholds(dict):
    def __init__(__self__, *,
                 sensitivity: str,
                 threshold: int,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "threshold", threshold)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesLoad(dict):
    def __init__(__self__, *,
                 drops: Optional['outputs.ServiceAnomaliesLoadDrops'] = None,
                 spikes: Optional['outputs.ServiceAnomaliesLoadSpikes'] = None):
        """
        :param 'ServiceAnomaliesLoadDropsArgs' drops: The configuration of traffic drops detection
        :param 'ServiceAnomaliesLoadSpikesArgs' spikes: The configuration of traffic spikes detection
        """
        if drops is not None:
            pulumi.set(__self__, "drops", drops)
        if spikes is not None:
            pulumi.set(__self__, "spikes", spikes)

    @property
    @pulumi.getter
    def drops(self) -> Optional['outputs.ServiceAnomaliesLoadDrops']:
        """
        The configuration of traffic drops detection
        """
        return pulumi.get(self, "drops")

    @property
    @pulumi.getter
    def spikes(self) -> Optional['outputs.ServiceAnomaliesLoadSpikes']:
        """
        The configuration of traffic spikes detection
        """
        return pulumi.get(self, "spikes")


@pulumi.output_type
class ServiceAnomaliesLoadDrops(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None):
        """
        :param int minutes: Alert if the service stays in abnormal state for at least *X* minutes
        :param int percent: Alert if the observed load is more than *X* % of the expected value
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Alert if the service stays in abnormal state for at least *X* minutes
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        """
        Alert if the observed load is more than *X* % of the expected value
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class ServiceAnomaliesLoadSpikes(dict):
    def __init__(__self__, *,
                 minutes: Optional[int] = None,
                 percent: Optional[int] = None,
                 unknowns: Optional[str] = None):
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def percent(self) -> Optional[int]:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesResponseTimes(dict):
    def __init__(__self__, *,
                 auto: Optional['outputs.ServiceAnomaliesResponseTimesAuto'] = None,
                 thresholds: Optional['outputs.ServiceAnomaliesResponseTimesThresholds'] = None):
        """
        :param 'ServiceAnomaliesResponseTimesAutoArgs' auto: Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        :param 'ServiceAnomaliesResponseTimesThresholdsArgs' thresholds: Fixed thresholds for response time degradation detection
        """
        if auto is not None:
            pulumi.set(__self__, "auto", auto)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter
    def auto(self) -> Optional['outputs.ServiceAnomaliesResponseTimesAuto']:
        """
        Parameters of the response time degradation auto-detection. Violation of **any** criterion triggers an alert
        """
        return pulumi.get(self, "auto")

    @property
    @pulumi.getter
    def thresholds(self) -> Optional['outputs.ServiceAnomaliesResponseTimesThresholds']:
        """
        Fixed thresholds for response time degradation detection
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class ServiceAnomaliesResponseTimesAuto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"
        elif key == "slowestPercent":
            suggest = "slowest_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesResponseTimesAuto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesResponseTimesAuto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesResponseTimesAuto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 percent: int,
                 slowest_milliseconds: int,
                 slowest_percent: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "percent", percent)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        pulumi.set(__self__, "slowest_percent", slowest_percent)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def percent(self) -> int:
        return pulumi.get(self, "percent")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter(name="slowestPercent")
    def slowest_percent(self) -> int:
        return pulumi.get(self, "slowest_percent")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceAnomaliesResponseTimesThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowestMilliseconds":
            suggest = "slowest_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAnomaliesResponseTimesThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAnomaliesResponseTimesThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAnomaliesResponseTimesThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load: str,
                 milliseconds: int,
                 sensitivity: str,
                 slowest_milliseconds: int,
                 unknowns: Optional[str] = None):
        """
        :param str load: The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
        """
        pulumi.set(__self__, "load", load)
        pulumi.set(__self__, "milliseconds", milliseconds)
        pulumi.set(__self__, "sensitivity", sensitivity)
        pulumi.set(__self__, "slowest_milliseconds", slowest_milliseconds)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def load(self) -> str:
        """
        The configuration of load spikes detection. Detecting load spikes will be disabled if this block is omitted.
        """
        return pulumi.get(self, "load")

    @property
    @pulumi.getter
    def milliseconds(self) -> int:
        return pulumi.get(self, "milliseconds")

    @property
    @pulumi.getter
    def sensitivity(self) -> str:
        return pulumi.get(self, "sensitivity")

    @property
    @pulumi.getter(name="slowestMilliseconds")
    def slowest_milliseconds(self) -> int:
        return pulumi.get(self, "slowest_milliseconds")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingCondition(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ServiceNamingConditionCondition']] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ServiceNamingConditionCondition']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class ServiceNamingConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationTypeComparisons":
            suggest = "application_type_comparisons"
        elif key == "applicationTypes":
            suggest = "application_types"
        elif key == "azureComputeModeComparisons":
            suggest = "azure_compute_mode_comparisons"
        elif key == "azureComputeModes":
            suggest = "azure_compute_modes"
        elif key == "azureSkuComparisions":
            suggest = "azure_sku_comparisions"
        elif key == "azureSkus":
            suggest = "azure_skus"
        elif key == "baseComparisonBasics":
            suggest = "base_comparison_basics"
        elif key == "baseConditionKeys":
            suggest = "base_condition_keys"
        elif key == "bitnessComparisions":
            suggest = "bitness_comparisions"
        elif key == "cloudTypeComparisons":
            suggest = "cloud_type_comparisons"
        elif key == "cloudTypes":
            suggest = "cloud_types"
        elif key == "customApplicationTypeComparisons":
            suggest = "custom_application_type_comparisons"
        elif key == "customApplicationTypes":
            suggest = "custom_application_types"
        elif key == "customHostMetadataConditionKeys":
            suggest = "custom_host_metadata_condition_keys"
        elif key == "customHostMetadatas":
            suggest = "custom_host_metadatas"
        elif key == "customProcessMetadataConditionKeys":
            suggest = "custom_process_metadata_condition_keys"
        elif key == "customProcessMetadatas":
            suggest = "custom_process_metadatas"
        elif key == "databaseTopologies":
            suggest = "database_topologies"
        elif key == "databaseTopologyComparisons":
            suggest = "database_topology_comparisons"
        elif key == "dcrumDecoderComparisons":
            suggest = "dcrum_decoder_comparisons"
        elif key == "dcrumDecoders":
            suggest = "dcrum_decoders"
        elif key == "entityIdComparisons":
            suggest = "entity_id_comparisons"
        elif key == "hostTeches":
            suggest = "host_teches"
        elif key == "hypervisorTypeComparisions":
            suggest = "hypervisor_type_comparisions"
        elif key == "indexedNameComparisons":
            suggest = "indexed_name_comparisons"
        elif key == "indexedNames":
            suggest = "indexed_names"
        elif key == "indexedStringComparisons":
            suggest = "indexed_string_comparisons"
        elif key == "indexedStrings":
            suggest = "indexed_strings"
        elif key == "indexedTagComparisons":
            suggest = "indexed_tag_comparisons"
        elif key == "indexedTags":
            suggest = "indexed_tags"
        elif key == "integerComparisons":
            suggest = "integer_comparisons"
        elif key == "ipaddressComparisons":
            suggest = "ipaddress_comparisons"
        elif key == "mobilePlatformComparisons":
            suggest = "mobile_platform_comparisons"
        elif key == "mobilePlatforms":
            suggest = "mobile_platforms"
        elif key == "osArches":
            suggest = "os_arches"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "osarchitectureComparisons":
            suggest = "osarchitecture_comparisons"
        elif key == "ostypeComparisons":
            suggest = "ostype_comparisons"
        elif key == "paasTypeComparisons":
            suggest = "paas_type_comparisons"
        elif key == "paasTypes":
            suggest = "paas_types"
        elif key == "processMetadataConditionKeys":
            suggest = "process_metadata_condition_keys"
        elif key == "processMetadatas":
            suggest = "process_metadatas"
        elif key == "serviceTopologies":
            suggest = "service_topologies"
        elif key == "serviceTopologyComparisons":
            suggest = "service_topology_comparisons"
        elif key == "serviceTypeComparisons":
            suggest = "service_type_comparisons"
        elif key == "serviceTypes":
            suggest = "service_types"
        elif key == "simpleHostTechComparisons":
            suggest = "simple_host_tech_comparisons"
        elif key == "simpleTechComparisons":
            suggest = "simple_tech_comparisons"
        elif key == "stringComparisons":
            suggest = "string_comparisons"
        elif key == "stringConditionKeys":
            suggest = "string_condition_keys"
        elif key == "stringKeys":
            suggest = "string_keys"
        elif key == "syntheticEngineTypeComparisons":
            suggest = "synthetic_engine_type_comparisons"
        elif key == "syntheticEngines":
            suggest = "synthetic_engines"
        elif key == "tagComparisons":
            suggest = "tag_comparisons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationTypeComparison']] = None,
                 application_types: Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationType']] = None,
                 azure_compute_mode_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeModeComparison']] = None,
                 azure_compute_modes: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeMode']] = None,
                 azure_sku_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkuComparision']] = None,
                 azure_skus: Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkus']] = None,
                 base_comparison_basics: Optional[Sequence['outputs.ServiceNamingConditionConditionBaseComparisonBasic']] = None,
                 base_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionBaseConditionKey']] = None,
                 bitness_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionBitnessComparision']] = None,
                 bitnesses: Optional[Sequence['outputs.ServiceNamingConditionConditionBitness']] = None,
                 cloud_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionCloudTypeComparison']] = None,
                 cloud_types: Optional[Sequence['outputs.ServiceNamingConditionConditionCloudType']] = None,
                 comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionComparison']] = None,
                 custom_application_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationTypeComparison']] = None,
                 custom_application_types: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationType']] = None,
                 custom_host_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKey']] = None,
                 custom_host_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadata']] = None,
                 custom_process_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKey']] = None,
                 custom_process_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadata']] = None,
                 database_topologies: Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopology']] = None,
                 database_topology_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopologyComparison']] = None,
                 dcrum_decoder_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoderComparison']] = None,
                 dcrum_decoders: Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoder']] = None,
                 entities: Optional[Sequence['outputs.ServiceNamingConditionConditionEntity']] = None,
                 entity_id_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionEntityIdComparison']] = None,
                 host_teches: Optional[Sequence['outputs.ServiceNamingConditionConditionHostTech']] = None,
                 hypervisor_type_comparisions: Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisorTypeComparision']] = None,
                 hypervisors: Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisor']] = None,
                 indexed_name_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedNameComparison']] = None,
                 indexed_names: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedName']] = None,
                 indexed_string_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedStringComparison']] = None,
                 indexed_strings: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedString']] = None,
                 indexed_tag_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTagComparison']] = None,
                 indexed_tags: Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTag']] = None,
                 integer_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIntegerComparison']] = None,
                 integers: Optional[Sequence['outputs.ServiceNamingConditionConditionInteger']] = None,
                 ipaddress_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddressComparison']] = None,
                 ipaddresses: Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddress']] = None,
                 keys: Optional[Sequence['outputs.ServiceNamingConditionConditionKey']] = None,
                 mobile_platform_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatformComparison']] = None,
                 mobile_platforms: Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatform']] = None,
                 os_arches: Optional[Sequence['outputs.ServiceNamingConditionConditionOsArch']] = None,
                 os_types: Optional[Sequence['outputs.ServiceNamingConditionConditionOsType']] = None,
                 osarchitecture_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionOsarchitectureComparison']] = None,
                 ostype_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionOstypeComparison']] = None,
                 paas_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionPaasTypeComparison']] = None,
                 paas_types: Optional[Sequence['outputs.ServiceNamingConditionConditionPaasType']] = None,
                 process_metadata_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadataConditionKey']] = None,
                 process_metadatas: Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadata']] = None,
                 service_topologies: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopology']] = None,
                 service_topology_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopologyComparison']] = None,
                 service_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTypeComparison']] = None,
                 service_types: Optional[Sequence['outputs.ServiceNamingConditionConditionServiceType']] = None,
                 simple_host_tech_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleHostTechComparison']] = None,
                 simple_tech_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleTechComparison']] = None,
                 string_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionStringComparison']] = None,
                 string_condition_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionStringConditionKey']] = None,
                 string_keys: Optional[Sequence['outputs.ServiceNamingConditionConditionStringKey']] = None,
                 strings: Optional[Sequence['outputs.ServiceNamingConditionConditionString']] = None,
                 synthetic_engine_type_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngineTypeComparison']] = None,
                 synthetic_engines: Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngine']] = None,
                 tag_comparisons: Optional[Sequence['outputs.ServiceNamingConditionConditionTagComparison']] = None,
                 tags: Optional[Sequence['outputs.ServiceNamingConditionConditionTag']] = None,
                 teches: Optional[Sequence['outputs.ServiceNamingConditionConditionTech']] = None,
                 unknowns: Optional[str] = None):
        if application_type_comparisons is not None:
            pulumi.set(__self__, "application_type_comparisons", application_type_comparisons)
        if application_types is not None:
            pulumi.set(__self__, "application_types", application_types)
        if azure_compute_mode_comparisons is not None:
            pulumi.set(__self__, "azure_compute_mode_comparisons", azure_compute_mode_comparisons)
        if azure_compute_modes is not None:
            pulumi.set(__self__, "azure_compute_modes", azure_compute_modes)
        if azure_sku_comparisions is not None:
            pulumi.set(__self__, "azure_sku_comparisions", azure_sku_comparisions)
        if azure_skus is not None:
            pulumi.set(__self__, "azure_skus", azure_skus)
        if base_comparison_basics is not None:
            pulumi.set(__self__, "base_comparison_basics", base_comparison_basics)
        if base_condition_keys is not None:
            pulumi.set(__self__, "base_condition_keys", base_condition_keys)
        if bitness_comparisions is not None:
            pulumi.set(__self__, "bitness_comparisions", bitness_comparisions)
        if bitnesses is not None:
            pulumi.set(__self__, "bitnesses", bitnesses)
        if cloud_type_comparisons is not None:
            pulumi.set(__self__, "cloud_type_comparisons", cloud_type_comparisons)
        if cloud_types is not None:
            pulumi.set(__self__, "cloud_types", cloud_types)
        if comparisons is not None:
            pulumi.set(__self__, "comparisons", comparisons)
        if custom_application_type_comparisons is not None:
            pulumi.set(__self__, "custom_application_type_comparisons", custom_application_type_comparisons)
        if custom_application_types is not None:
            pulumi.set(__self__, "custom_application_types", custom_application_types)
        if custom_host_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_host_metadata_condition_keys", custom_host_metadata_condition_keys)
        if custom_host_metadatas is not None:
            pulumi.set(__self__, "custom_host_metadatas", custom_host_metadatas)
        if custom_process_metadata_condition_keys is not None:
            pulumi.set(__self__, "custom_process_metadata_condition_keys", custom_process_metadata_condition_keys)
        if custom_process_metadatas is not None:
            pulumi.set(__self__, "custom_process_metadatas", custom_process_metadatas)
        if database_topologies is not None:
            pulumi.set(__self__, "database_topologies", database_topologies)
        if database_topology_comparisons is not None:
            pulumi.set(__self__, "database_topology_comparisons", database_topology_comparisons)
        if dcrum_decoder_comparisons is not None:
            pulumi.set(__self__, "dcrum_decoder_comparisons", dcrum_decoder_comparisons)
        if dcrum_decoders is not None:
            pulumi.set(__self__, "dcrum_decoders", dcrum_decoders)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_id_comparisons is not None:
            pulumi.set(__self__, "entity_id_comparisons", entity_id_comparisons)
        if host_teches is not None:
            pulumi.set(__self__, "host_teches", host_teches)
        if hypervisor_type_comparisions is not None:
            pulumi.set(__self__, "hypervisor_type_comparisions", hypervisor_type_comparisions)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if indexed_name_comparisons is not None:
            pulumi.set(__self__, "indexed_name_comparisons", indexed_name_comparisons)
        if indexed_names is not None:
            pulumi.set(__self__, "indexed_names", indexed_names)
        if indexed_string_comparisons is not None:
            pulumi.set(__self__, "indexed_string_comparisons", indexed_string_comparisons)
        if indexed_strings is not None:
            pulumi.set(__self__, "indexed_strings", indexed_strings)
        if indexed_tag_comparisons is not None:
            pulumi.set(__self__, "indexed_tag_comparisons", indexed_tag_comparisons)
        if indexed_tags is not None:
            pulumi.set(__self__, "indexed_tags", indexed_tags)
        if integer_comparisons is not None:
            pulumi.set(__self__, "integer_comparisons", integer_comparisons)
        if integers is not None:
            pulumi.set(__self__, "integers", integers)
        if ipaddress_comparisons is not None:
            pulumi.set(__self__, "ipaddress_comparisons", ipaddress_comparisons)
        if ipaddresses is not None:
            pulumi.set(__self__, "ipaddresses", ipaddresses)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if mobile_platform_comparisons is not None:
            pulumi.set(__self__, "mobile_platform_comparisons", mobile_platform_comparisons)
        if mobile_platforms is not None:
            pulumi.set(__self__, "mobile_platforms", mobile_platforms)
        if os_arches is not None:
            pulumi.set(__self__, "os_arches", os_arches)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if osarchitecture_comparisons is not None:
            pulumi.set(__self__, "osarchitecture_comparisons", osarchitecture_comparisons)
        if ostype_comparisons is not None:
            pulumi.set(__self__, "ostype_comparisons", ostype_comparisons)
        if paas_type_comparisons is not None:
            pulumi.set(__self__, "paas_type_comparisons", paas_type_comparisons)
        if paas_types is not None:
            pulumi.set(__self__, "paas_types", paas_types)
        if process_metadata_condition_keys is not None:
            pulumi.set(__self__, "process_metadata_condition_keys", process_metadata_condition_keys)
        if process_metadatas is not None:
            pulumi.set(__self__, "process_metadatas", process_metadatas)
        if service_topologies is not None:
            pulumi.set(__self__, "service_topologies", service_topologies)
        if service_topology_comparisons is not None:
            pulumi.set(__self__, "service_topology_comparisons", service_topology_comparisons)
        if service_type_comparisons is not None:
            pulumi.set(__self__, "service_type_comparisons", service_type_comparisons)
        if service_types is not None:
            pulumi.set(__self__, "service_types", service_types)
        if simple_host_tech_comparisons is not None:
            pulumi.set(__self__, "simple_host_tech_comparisons", simple_host_tech_comparisons)
        if simple_tech_comparisons is not None:
            pulumi.set(__self__, "simple_tech_comparisons", simple_tech_comparisons)
        if string_comparisons is not None:
            pulumi.set(__self__, "string_comparisons", string_comparisons)
        if string_condition_keys is not None:
            pulumi.set(__self__, "string_condition_keys", string_condition_keys)
        if string_keys is not None:
            pulumi.set(__self__, "string_keys", string_keys)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)
        if synthetic_engine_type_comparisons is not None:
            pulumi.set(__self__, "synthetic_engine_type_comparisons", synthetic_engine_type_comparisons)
        if synthetic_engines is not None:
            pulumi.set(__self__, "synthetic_engines", synthetic_engines)
        if tag_comparisons is not None:
            pulumi.set(__self__, "tag_comparisons", tag_comparisons)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if teches is not None:
            pulumi.set(__self__, "teches", teches)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter(name="applicationTypeComparisons")
    def application_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationTypeComparison']]:
        return pulumi.get(self, "application_type_comparisons")

    @property
    @pulumi.getter(name="applicationTypes")
    def application_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionApplicationType']]:
        return pulumi.get(self, "application_types")

    @property
    @pulumi.getter(name="azureComputeModeComparisons")
    def azure_compute_mode_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeModeComparison']]:
        return pulumi.get(self, "azure_compute_mode_comparisons")

    @property
    @pulumi.getter(name="azureComputeModes")
    def azure_compute_modes(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureComputeMode']]:
        return pulumi.get(self, "azure_compute_modes")

    @property
    @pulumi.getter(name="azureSkuComparisions")
    def azure_sku_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkuComparision']]:
        return pulumi.get(self, "azure_sku_comparisions")

    @property
    @pulumi.getter(name="azureSkus")
    def azure_skus(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionAzureSkus']]:
        return pulumi.get(self, "azure_skus")

    @property
    @pulumi.getter(name="baseComparisonBasics")
    def base_comparison_basics(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBaseComparisonBasic']]:
        return pulumi.get(self, "base_comparison_basics")

    @property
    @pulumi.getter(name="baseConditionKeys")
    def base_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBaseConditionKey']]:
        return pulumi.get(self, "base_condition_keys")

    @property
    @pulumi.getter(name="bitnessComparisions")
    def bitness_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBitnessComparision']]:
        return pulumi.get(self, "bitness_comparisions")

    @property
    @pulumi.getter
    def bitnesses(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionBitness']]:
        return pulumi.get(self, "bitnesses")

    @property
    @pulumi.getter(name="cloudTypeComparisons")
    def cloud_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCloudTypeComparison']]:
        return pulumi.get(self, "cloud_type_comparisons")

    @property
    @pulumi.getter(name="cloudTypes")
    def cloud_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCloudType']]:
        return pulumi.get(self, "cloud_types")

    @property
    @pulumi.getter
    def comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionComparison']]:
        return pulumi.get(self, "comparisons")

    @property
    @pulumi.getter(name="customApplicationTypeComparisons")
    def custom_application_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationTypeComparison']]:
        return pulumi.get(self, "custom_application_type_comparisons")

    @property
    @pulumi.getter(name="customApplicationTypes")
    def custom_application_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomApplicationType']]:
        return pulumi.get(self, "custom_application_types")

    @property
    @pulumi.getter(name="customHostMetadataConditionKeys")
    def custom_host_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKey']]:
        return pulumi.get(self, "custom_host_metadata_condition_keys")

    @property
    @pulumi.getter(name="customHostMetadatas")
    def custom_host_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomHostMetadata']]:
        return pulumi.get(self, "custom_host_metadatas")

    @property
    @pulumi.getter(name="customProcessMetadataConditionKeys")
    def custom_process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKey']]:
        return pulumi.get(self, "custom_process_metadata_condition_keys")

    @property
    @pulumi.getter(name="customProcessMetadatas")
    def custom_process_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionCustomProcessMetadata']]:
        return pulumi.get(self, "custom_process_metadatas")

    @property
    @pulumi.getter(name="databaseTopologies")
    def database_topologies(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopology']]:
        return pulumi.get(self, "database_topologies")

    @property
    @pulumi.getter(name="databaseTopologyComparisons")
    def database_topology_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDatabaseTopologyComparison']]:
        return pulumi.get(self, "database_topology_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoderComparisons")
    def dcrum_decoder_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoderComparison']]:
        return pulumi.get(self, "dcrum_decoder_comparisons")

    @property
    @pulumi.getter(name="dcrumDecoders")
    def dcrum_decoders(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionDcrumDecoder']]:
        return pulumi.get(self, "dcrum_decoders")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionEntity']]:
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="entityIdComparisons")
    def entity_id_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionEntityIdComparison']]:
        return pulumi.get(self, "entity_id_comparisons")

    @property
    @pulumi.getter(name="hostTeches")
    def host_teches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHostTech']]:
        return pulumi.get(self, "host_teches")

    @property
    @pulumi.getter(name="hypervisorTypeComparisions")
    def hypervisor_type_comparisions(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisorTypeComparision']]:
        return pulumi.get(self, "hypervisor_type_comparisions")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionHypervisor']]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="indexedNameComparisons")
    def indexed_name_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedNameComparison']]:
        return pulumi.get(self, "indexed_name_comparisons")

    @property
    @pulumi.getter(name="indexedNames")
    def indexed_names(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedName']]:
        return pulumi.get(self, "indexed_names")

    @property
    @pulumi.getter(name="indexedStringComparisons")
    def indexed_string_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedStringComparison']]:
        return pulumi.get(self, "indexed_string_comparisons")

    @property
    @pulumi.getter(name="indexedStrings")
    def indexed_strings(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedString']]:
        return pulumi.get(self, "indexed_strings")

    @property
    @pulumi.getter(name="indexedTagComparisons")
    def indexed_tag_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTagComparison']]:
        return pulumi.get(self, "indexed_tag_comparisons")

    @property
    @pulumi.getter(name="indexedTags")
    def indexed_tags(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIndexedTag']]:
        return pulumi.get(self, "indexed_tags")

    @property
    @pulumi.getter(name="integerComparisons")
    def integer_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIntegerComparison']]:
        return pulumi.get(self, "integer_comparisons")

    @property
    @pulumi.getter
    def integers(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionInteger']]:
        return pulumi.get(self, "integers")

    @property
    @pulumi.getter(name="ipaddressComparisons")
    def ipaddress_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddressComparison']]:
        return pulumi.get(self, "ipaddress_comparisons")

    @property
    @pulumi.getter
    def ipaddresses(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionIpaddress']]:
        return pulumi.get(self, "ipaddresses")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionKey']]:
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="mobilePlatformComparisons")
    def mobile_platform_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatformComparison']]:
        return pulumi.get(self, "mobile_platform_comparisons")

    @property
    @pulumi.getter(name="mobilePlatforms")
    def mobile_platforms(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionMobilePlatform']]:
        return pulumi.get(self, "mobile_platforms")

    @property
    @pulumi.getter(name="osArches")
    def os_arches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsArch']]:
        return pulumi.get(self, "os_arches")

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsType']]:
        return pulumi.get(self, "os_types")

    @property
    @pulumi.getter(name="osarchitectureComparisons")
    def osarchitecture_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOsarchitectureComparison']]:
        return pulumi.get(self, "osarchitecture_comparisons")

    @property
    @pulumi.getter(name="ostypeComparisons")
    def ostype_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionOstypeComparison']]:
        return pulumi.get(self, "ostype_comparisons")

    @property
    @pulumi.getter(name="paasTypeComparisons")
    def paas_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionPaasTypeComparison']]:
        return pulumi.get(self, "paas_type_comparisons")

    @property
    @pulumi.getter(name="paasTypes")
    def paas_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionPaasType']]:
        return pulumi.get(self, "paas_types")

    @property
    @pulumi.getter(name="processMetadataConditionKeys")
    def process_metadata_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadataConditionKey']]:
        return pulumi.get(self, "process_metadata_condition_keys")

    @property
    @pulumi.getter(name="processMetadatas")
    def process_metadatas(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionProcessMetadata']]:
        return pulumi.get(self, "process_metadatas")

    @property
    @pulumi.getter(name="serviceTopologies")
    def service_topologies(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopology']]:
        return pulumi.get(self, "service_topologies")

    @property
    @pulumi.getter(name="serviceTopologyComparisons")
    def service_topology_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTopologyComparison']]:
        return pulumi.get(self, "service_topology_comparisons")

    @property
    @pulumi.getter(name="serviceTypeComparisons")
    def service_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceTypeComparison']]:
        return pulumi.get(self, "service_type_comparisons")

    @property
    @pulumi.getter(name="serviceTypes")
    def service_types(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionServiceType']]:
        return pulumi.get(self, "service_types")

    @property
    @pulumi.getter(name="simpleHostTechComparisons")
    def simple_host_tech_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleHostTechComparison']]:
        return pulumi.get(self, "simple_host_tech_comparisons")

    @property
    @pulumi.getter(name="simpleTechComparisons")
    def simple_tech_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSimpleTechComparison']]:
        return pulumi.get(self, "simple_tech_comparisons")

    @property
    @pulumi.getter(name="stringComparisons")
    def string_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringComparison']]:
        return pulumi.get(self, "string_comparisons")

    @property
    @pulumi.getter(name="stringConditionKeys")
    def string_condition_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringConditionKey']]:
        return pulumi.get(self, "string_condition_keys")

    @property
    @pulumi.getter(name="stringKeys")
    def string_keys(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionStringKey']]:
        return pulumi.get(self, "string_keys")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionString']]:
        return pulumi.get(self, "strings")

    @property
    @pulumi.getter(name="syntheticEngineTypeComparisons")
    def synthetic_engine_type_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngineTypeComparison']]:
        return pulumi.get(self, "synthetic_engine_type_comparisons")

    @property
    @pulumi.getter(name="syntheticEngines")
    def synthetic_engines(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionSyntheticEngine']]:
        return pulumi.get(self, "synthetic_engines")

    @property
    @pulumi.getter(name="tagComparisons")
    def tag_comparisons(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTagComparison']]:
        return pulumi.get(self, "tag_comparisons")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teches(self) -> Optional[Sequence['outputs.ServiceNamingConditionConditionTech']]:
        return pulumi.get(self, "teches")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureComputeMode(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureComputeModeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureSkuComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionAzureSkus(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionBaseComparisonBasic(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionBaseConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionBitness(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionBitnessComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCloudType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCloudTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionComparison(dict):
    def __init__(__self__, *,
                 type: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomApplicationType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCustomApplicationTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomHostMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomHostMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomHostMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomHostMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomHostMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomHostMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomHostMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomProcessMetadataDynamicKey',
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomProcessMetadataDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionCustomProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionCustomProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: 'outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey',
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> 'outputs.ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey':
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataConditionKeyDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionCustomProcessMetadataDynamicKey(dict):
    def __init__(__self__, *,
                 key: str,
                 source: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionDatabaseTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDatabaseTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDcrumDecoder(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionDcrumDecoderComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionEntity(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionEntityIdComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHostTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionHostTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionHostTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHostTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionHostTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionHostTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionHostTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionHypervisor(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionHypervisorTypeComparision(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedName(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedNameComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedString(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedStringComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionIndexedTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionIndexedTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionIndexedTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionIndexedTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIndexedTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionInteger(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIntegerComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[int] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIpaddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionIpaddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionIpaddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionIpaddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionIpaddressComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionIpaddressComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionIpaddressComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionKey(dict):
    def __init__(__self__, *,
                 attribute: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionMobilePlatform(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionMobilePlatformComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsArch(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOsarchitectureComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionOstypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionPaasType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionPaasTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionProcessMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionProcessMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionProcessMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionProcessMetadataConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionProcessMetadataConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionProcessMetadataConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTopology(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTopologyComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceType(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionServiceTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleHostTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionSimpleHostTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionSimpleHostTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleHostTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionSimpleHostTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionSimpleHostTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleTechComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionSimpleTechComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionSimpleTechComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSimpleTechComparisonValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionSimpleTechComparisonValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionSimpleTechComparisonValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class ServiceNamingConditionConditionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionStringComparison(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringComparison. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringComparison.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringComparison.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 case_sensitive: Optional[bool] = None,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionStringConditionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringConditionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringConditionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionStringKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicKey":
            suggest = "dynamic_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionStringKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionStringKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionStringKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: str,
                 dynamic_key: str,
                 unknowns: Optional[str] = None):
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "dynamic_key", dynamic_key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter(name="dynamicKey")
    def dynamic_key(self) -> str:
        return pulumi.get(self, "dynamic_key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")


@pulumi.output_type
class ServiceNamingConditionConditionSyntheticEngine(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionSyntheticEngineTypeComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTag(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTagValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTagValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagComparison(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTagComparisonValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTagComparisonValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagComparisonValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTagValue(dict):
    def __init__(__self__, *,
                 context: str,
                 key: str,
                 unknowns: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "context", context)
        pulumi.set(__self__, "key", key)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def context(self) -> str:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTech(dict):
    def __init__(__self__, *,
                 operator: str,
                 negate: Optional[bool] = None,
                 unknowns: Optional[str] = None,
                 value: Optional['outputs.ServiceNamingConditionConditionTechValue'] = None):
        pulumi.set(__self__, "operator", operator)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        return pulumi.get(self, "negate")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.ServiceNamingConditionConditionTechValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceNamingConditionConditionTechValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verbatimType":
            suggest = "verbatim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNamingConditionConditionTechValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNamingConditionConditionTechValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNamingConditionConditionTechValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 unknowns: Optional[str] = None,
                 verbatim_type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unknowns is not None:
            pulumi.set(__self__, "unknowns", unknowns)
        if verbatim_type is not None:
            pulumi.set(__self__, "verbatim_type", verbatim_type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unknowns(self) -> Optional[str]:
        return pulumi.get(self, "unknowns")

    @property
    @pulumi.getter(name="verbatimType")
    def verbatim_type(self) -> Optional[str]:
        return pulumi.get(self, "verbatim_type")


@pulumi.output_type
class SpanCaptureRuleMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanCaptureRuleMatchesMatch']):
        """
        :param Sequence['SpanCaptureRuleMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanCaptureRuleMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanCaptureRuleMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanCaptureRuleMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanCaptureRuleMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanCaptureRuleMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SpanContextPropagationMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanContextPropagationMatchesMatch']):
        """
        :param Sequence['SpanContextPropagationMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanContextPropagationMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanContextPropagationMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanContextPropagationMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanContextPropagationMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanContextPropagationMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SpanEntryPointMatches(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.SpanEntryPointMatchesMatch']):
        """
        :param Sequence['SpanEntryPointMatchesMatchArgs'] matches: Matching strategies for the Span
        """
        pulumi.set(__self__, "matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.SpanEntryPointMatchesMatch']:
        """
        Matching strategies for the Span
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class SpanEntryPointMatchesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpanEntryPointMatchesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpanEntryPointMatchesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpanEntryPointMatchesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison: str,
                 source: str,
                 case_sensitive: Optional[bool] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "source", source)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparison(self) -> str:
        return pulumi.get(self, "comparison")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class UserGroupPermissions(dict):
    def __init__(__self__, *,
                 grants: Sequence['outputs.UserGroupPermissionsGrant']):
        """
        :param Sequence['UserGroupPermissionsGrantArgs'] grants: A permission granted to one or multiple environments
        """
        pulumi.set(__self__, "grants", grants)

    @property
    @pulumi.getter
    def grants(self) -> Sequence['outputs.UserGroupPermissionsGrant']:
        """
        A permission granted to one or multiple environments
        """
        return pulumi.get(self, "grants")


@pulumi.output_type
class UserGroupPermissionsGrant(dict):
    def __init__(__self__, *,
                 permission: str,
                 environments: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "permission", permission)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)

    @property
    @pulumi.getter
    def permission(self) -> str:
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def environments(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "environments")


@pulumi.output_type
class WebApplicationConversionGoals(dict):
    def __init__(__self__, *,
                 goals: Sequence['outputs.WebApplicationConversionGoalsGoal']):
        """
        :param Sequence['WebApplicationConversionGoalsGoalArgs'] goals: A conversion goal of the application
        """
        pulumi.set(__self__, "goals", goals)

    @property
    @pulumi.getter
    def goals(self) -> Sequence['outputs.WebApplicationConversionGoalsGoal']:
        """
        A conversion goal of the application
        """
        return pulumi.get(self, "goals")


@pulumi.output_type
class WebApplicationConversionGoalsGoal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAction":
            suggest = "user_action"
        elif key == "visitDuration":
            suggest = "visit_duration"
        elif key == "visitNumAction":
            suggest = "visit_num_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 destination: Optional['outputs.WebApplicationConversionGoalsGoalDestination'] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None,
                 user_action: Optional['outputs.WebApplicationConversionGoalsGoalUserAction'] = None,
                 visit_duration: Optional['outputs.WebApplicationConversionGoalsGoalVisitDuration'] = None,
                 visit_num_action: Optional['outputs.WebApplicationConversionGoalsGoalVisitNumAction'] = None):
        """
        :param str name: The name of the web application, displayed in the UI
        :param str id: The ID of this resource.
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "name", name)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_action is not None:
            pulumi.set(__self__, "user_action", user_action)
        if visit_duration is not None:
            pulumi.set(__self__, "visit_duration", visit_duration)
        if visit_num_action is not None:
            pulumi.set(__self__, "visit_num_action", visit_num_action)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the web application, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.WebApplicationConversionGoalsGoalDestination']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAction")
    def user_action(self) -> Optional['outputs.WebApplicationConversionGoalsGoalUserAction']:
        return pulumi.get(self, "user_action")

    @property
    @pulumi.getter(name="visitDuration")
    def visit_duration(self) -> Optional['outputs.WebApplicationConversionGoalsGoalVisitDuration']:
        return pulumi.get(self, "visit_duration")

    @property
    @pulumi.getter(name="visitNumAction")
    def visit_num_action(self) -> Optional['outputs.WebApplicationConversionGoalsGoalVisitNumAction']:
        return pulumi.get(self, "visit_num_action")


@pulumi.output_type
class WebApplicationConversionGoalsGoalDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlOrPath":
            suggest = "url_or_path"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_or_path: str,
                 case_sensitive: Optional[bool] = None,
                 match_type: Optional[str] = None):
        pulumi.set(__self__, "url_or_path", url_or_path)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @property
    @pulumi.getter(name="urlOrPath")
    def url_or_path(self) -> str:
        return pulumi.get(self, "url_or_path")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        return pulumi.get(self, "match_type")


@pulumi.output_type
class WebApplicationConversionGoalsGoalUserAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchEntity":
            suggest = "match_entity"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalUserAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalUserAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalUserAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[str] = None,
                 case_sensitive: Optional[bool] = None,
                 match_entity: Optional[str] = None,
                 match_type: Optional[str] = None,
                 value: Optional[str] = None):
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_entity is not None:
            pulumi.set(__self__, "match_entity", match_entity)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchEntity")
    def match_entity(self) -> Optional[str]:
        return pulumi.get(self, "match_entity")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebApplicationConversionGoalsGoalVisitDuration(dict):
    def __init__(__self__, *,
                 duration: int):
        pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> int:
        return pulumi.get(self, "duration")


@pulumi.output_type
class WebApplicationConversionGoalsGoalVisitNumAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numUserActions":
            suggest = "num_user_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationConversionGoalsGoalVisitNumAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationConversionGoalsGoalVisitNumAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationConversionGoalsGoalVisitNumAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_user_actions: Optional[int] = None):
        if num_user_actions is not None:
            pulumi.set(__self__, "num_user_actions", num_user_actions)

    @property
    @pulumi.getter(name="numUserActions")
    def num_user_actions(self) -> Optional[int]:
        return pulumi.get(self, "num_user_actions")


@pulumi.output_type
class WebApplicationCustomActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationCustomActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationCustomActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationCustomActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: Optional[int] = None,
                 frustrating_threshold: Optional[int] = None,
                 threshold: Optional[int] = None,
                 tolerated_fallback_threshold: Optional[int] = None,
                 tolerated_threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int threshold: no documentation available
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        if frustrating_fallback_threshold is not None:
            pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        if frustrating_threshold is not None:
            pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if tolerated_fallback_threshold is not None:
            pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        if tolerated_threshold is not None:
            pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")


@pulumi.output_type
class WebApplicationKeyUserAction(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.WebApplicationKeyUserActionAction']):
        """
        :param Sequence['WebApplicationKeyUserActionActionArgs'] actions: Configuration of the key user action
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.WebApplicationKeyUserActionAction']:
        """
        Configuration of the key user action
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class WebApplicationKeyUserActionAction(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 domain: Optional[str] = None):
        """
        :param str name: The name of the web application, displayed in the UI
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the web application, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")


@pulumi.output_type
class WebApplicationLoadActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationLoadActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationLoadActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationLoadActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: Optional[int] = None,
                 frustrating_threshold: Optional[int] = None,
                 threshold: Optional[int] = None,
                 tolerated_fallback_threshold: Optional[int] = None,
                 tolerated_threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int threshold: no documentation available
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        if frustrating_fallback_threshold is not None:
            pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        if frustrating_threshold is not None:
            pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if tolerated_fallback_threshold is not None:
            pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        if tolerated_threshold is not None:
            pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")


@pulumi.output_type
class WebApplicationMetaDataCaptureSettings(dict):
    def __init__(__self__, *,
                 captures: Optional[Sequence['outputs.WebApplicationMetaDataCaptureSettingsCapture']] = None):
        """
        :param Sequence['WebApplicationMetaDataCaptureSettingsCaptureArgs'] captures: Java script agent meta data capture settings
        """
        if captures is not None:
            pulumi.set(__self__, "captures", captures)

    @property
    @pulumi.getter
    def captures(self) -> Optional[Sequence['outputs.WebApplicationMetaDataCaptureSettingsCapture']]:
        """
        Java script agent meta data capture settings
        """
        return pulumi.get(self, "captures")


@pulumi.output_type
class WebApplicationMetaDataCaptureSettingsCapture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capturingName":
            suggest = "capturing_name"
        elif key == "publicMetadata":
            suggest = "public_metadata"
        elif key == "uniqueId":
            suggest = "unique_id"
        elif key == "useLastValue":
            suggest = "use_last_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMetaDataCaptureSettingsCapture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMetaDataCaptureSettingsCapture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMetaDataCaptureSettingsCapture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capturing_name: str,
                 name: str,
                 type: str,
                 public_metadata: Optional[bool] = None,
                 unique_id: Optional[int] = None,
                 use_last_value: Optional[bool] = None):
        """
        :param str name: The name of the web application, displayed in the UI
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "capturing_name", capturing_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if public_metadata is not None:
            pulumi.set(__self__, "public_metadata", public_metadata)
        if unique_id is not None:
            pulumi.set(__self__, "unique_id", unique_id)
        if use_last_value is not None:
            pulumi.set(__self__, "use_last_value", use_last_value)

    @property
    @pulumi.getter(name="capturingName")
    def capturing_name(self) -> str:
        return pulumi.get(self, "capturing_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the web application, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="publicMetadata")
    def public_metadata(self) -> Optional[bool]:
        return pulumi.get(self, "public_metadata")

    @property
    @pulumi.getter(name="uniqueId")
    def unique_id(self) -> Optional[int]:
        return pulumi.get(self, "unique_id")

    @property
    @pulumi.getter(name="useLastValue")
    def use_last_value(self) -> Optional[bool]:
        return pulumi.get(self, "use_last_value")


@pulumi.output_type
class WebApplicationMonitoringSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentCapture":
            suggest = "content_capture"
        elif key == "injectionMode":
            suggest = "injection_mode"
        elif key == "addCrossOriginAnonymousAttribute":
            suggest = "add_cross_origin_anonymous_attribute"
        elif key == "advancedJavascriptTagSettings":
            suggest = "advanced_javascript_tag_settings"
        elif key == "angularPackageName":
            suggest = "angular_package_name"
        elif key == "browserRestrictionSettings":
            suggest = "browser_restriction_settings"
        elif key == "cacheControlHeaderOptimizations":
            suggest = "cache_control_header_optimizations"
        elif key == "cookiePlacementDomain":
            suggest = "cookie_placement_domain"
        elif key == "correlationHeaderInclusionRegex":
            suggest = "correlation_header_inclusion_regex"
        elif key == "customConfigurationProperties":
            suggest = "custom_configuration_properties"
        elif key == "excludeXhrRegex":
            suggest = "exclude_xhr_regex"
        elif key == "fetchRequests":
            suggest = "fetch_requests"
        elif key == "ipAddressRestrictionSettings":
            suggest = "ip_address_restriction_settings"
        elif key == "javascriptFrameworkSupport":
            suggest = "javascript_framework_support"
        elif key == "javascriptInjectionRules":
            suggest = "javascript_injection_rules"
        elif key == "libraryFileLocation":
            suggest = "library_file_location"
        elif key == "monitoringDataPath":
            suggest = "monitoring_data_path"
        elif key == "scriptTagCacheDurationInHours":
            suggest = "script_tag_cache_duration_in_hours"
        elif key == "secureCookieAttribute":
            suggest = "secure_cookie_attribute"
        elif key == "serverRequestPathId":
            suggest = "server_request_path_id"
        elif key == "xmlHttpRequest":
            suggest = "xml_http_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_capture: 'outputs.WebApplicationMonitoringSettingsContentCapture',
                 injection_mode: str,
                 add_cross_origin_anonymous_attribute: Optional[bool] = None,
                 advanced_javascript_tag_settings: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings'] = None,
                 angular_package_name: Optional[str] = None,
                 browser_restriction_settings: Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettings'] = None,
                 cache_control_header_optimizations: Optional[bool] = None,
                 cookie_placement_domain: Optional[str] = None,
                 correlation_header_inclusion_regex: Optional[str] = None,
                 custom_configuration_properties: Optional[str] = None,
                 exclude_xhr_regex: Optional[str] = None,
                 fetch_requests: Optional[bool] = None,
                 ip_address_restriction_settings: Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettings'] = None,
                 javascript_framework_support: Optional['outputs.WebApplicationMonitoringSettingsJavascriptFrameworkSupport'] = None,
                 javascript_injection_rules: Optional['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRules'] = None,
                 library_file_location: Optional[str] = None,
                 monitoring_data_path: Optional[str] = None,
                 script_tag_cache_duration_in_hours: Optional[int] = None,
                 secure_cookie_attribute: Optional[bool] = None,
                 server_request_path_id: Optional[str] = None,
                 xml_http_request: Optional[bool] = None):
        """
        :param 'WebApplicationMonitoringSettingsContentCaptureArgs' content_capture: Settings for content capture
        :param str injection_mode: Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
        :param bool add_cross_origin_anonymous_attribute: Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
        :param 'WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsArgs' advanced_javascript_tag_settings: Advanced JavaScript tag settings
        :param str angular_package_name: The name of the angular package
        :param 'WebApplicationMonitoringSettingsBrowserRestrictionSettingsArgs' browser_restriction_settings: Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
        :param bool cache_control_header_optimizations: Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
        :param str cookie_placement_domain: Domain for cookie placement. Maximum 150 characters.
        :param str correlation_header_inclusion_regex: To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
        """
        pulumi.set(__self__, "content_capture", content_capture)
        pulumi.set(__self__, "injection_mode", injection_mode)
        if add_cross_origin_anonymous_attribute is not None:
            pulumi.set(__self__, "add_cross_origin_anonymous_attribute", add_cross_origin_anonymous_attribute)
        if advanced_javascript_tag_settings is not None:
            pulumi.set(__self__, "advanced_javascript_tag_settings", advanced_javascript_tag_settings)
        if angular_package_name is not None:
            pulumi.set(__self__, "angular_package_name", angular_package_name)
        if browser_restriction_settings is not None:
            pulumi.set(__self__, "browser_restriction_settings", browser_restriction_settings)
        if cache_control_header_optimizations is not None:
            pulumi.set(__self__, "cache_control_header_optimizations", cache_control_header_optimizations)
        if cookie_placement_domain is not None:
            pulumi.set(__self__, "cookie_placement_domain", cookie_placement_domain)
        if correlation_header_inclusion_regex is not None:
            pulumi.set(__self__, "correlation_header_inclusion_regex", correlation_header_inclusion_regex)
        if custom_configuration_properties is not None:
            pulumi.set(__self__, "custom_configuration_properties", custom_configuration_properties)
        if exclude_xhr_regex is not None:
            pulumi.set(__self__, "exclude_xhr_regex", exclude_xhr_regex)
        if fetch_requests is not None:
            pulumi.set(__self__, "fetch_requests", fetch_requests)
        if ip_address_restriction_settings is not None:
            pulumi.set(__self__, "ip_address_restriction_settings", ip_address_restriction_settings)
        if javascript_framework_support is not None:
            pulumi.set(__self__, "javascript_framework_support", javascript_framework_support)
        if javascript_injection_rules is not None:
            pulumi.set(__self__, "javascript_injection_rules", javascript_injection_rules)
        if library_file_location is not None:
            pulumi.set(__self__, "library_file_location", library_file_location)
        if monitoring_data_path is not None:
            pulumi.set(__self__, "monitoring_data_path", monitoring_data_path)
        if script_tag_cache_duration_in_hours is not None:
            pulumi.set(__self__, "script_tag_cache_duration_in_hours", script_tag_cache_duration_in_hours)
        if secure_cookie_attribute is not None:
            pulumi.set(__self__, "secure_cookie_attribute", secure_cookie_attribute)
        if server_request_path_id is not None:
            pulumi.set(__self__, "server_request_path_id", server_request_path_id)
        if xml_http_request is not None:
            pulumi.set(__self__, "xml_http_request", xml_http_request)

    @property
    @pulumi.getter(name="contentCapture")
    def content_capture(self) -> 'outputs.WebApplicationMonitoringSettingsContentCapture':
        """
        Settings for content capture
        """
        return pulumi.get(self, "content_capture")

    @property
    @pulumi.getter(name="injectionMode")
    def injection_mode(self) -> str:
        """
        Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
        """
        return pulumi.get(self, "injection_mode")

    @property
    @pulumi.getter(name="addCrossOriginAnonymousAttribute")
    def add_cross_origin_anonymous_attribute(self) -> Optional[bool]:
        """
        Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
        """
        return pulumi.get(self, "add_cross_origin_anonymous_attribute")

    @property
    @pulumi.getter(name="advancedJavascriptTagSettings")
    def advanced_javascript_tag_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings']:
        """
        Advanced JavaScript tag settings
        """
        return pulumi.get(self, "advanced_javascript_tag_settings")

    @property
    @pulumi.getter(name="angularPackageName")
    def angular_package_name(self) -> Optional[str]:
        """
        The name of the angular package
        """
        return pulumi.get(self, "angular_package_name")

    @property
    @pulumi.getter(name="browserRestrictionSettings")
    def browser_restriction_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettings']:
        """
        Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
        """
        return pulumi.get(self, "browser_restriction_settings")

    @property
    @pulumi.getter(name="cacheControlHeaderOptimizations")
    def cache_control_header_optimizations(self) -> Optional[bool]:
        """
        Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
        """
        return pulumi.get(self, "cache_control_header_optimizations")

    @property
    @pulumi.getter(name="cookiePlacementDomain")
    def cookie_placement_domain(self) -> Optional[str]:
        """
        Domain for cookie placement. Maximum 150 characters.
        """
        return pulumi.get(self, "cookie_placement_domain")

    @property
    @pulumi.getter(name="correlationHeaderInclusionRegex")
    def correlation_header_inclusion_regex(self) -> Optional[str]:
        """
        To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
        """
        return pulumi.get(self, "correlation_header_inclusion_regex")

    @property
    @pulumi.getter(name="customConfigurationProperties")
    def custom_configuration_properties(self) -> Optional[str]:
        return pulumi.get(self, "custom_configuration_properties")

    @property
    @pulumi.getter(name="excludeXhrRegex")
    def exclude_xhr_regex(self) -> Optional[str]:
        return pulumi.get(self, "exclude_xhr_regex")

    @property
    @pulumi.getter(name="fetchRequests")
    def fetch_requests(self) -> Optional[bool]:
        return pulumi.get(self, "fetch_requests")

    @property
    @pulumi.getter(name="ipAddressRestrictionSettings")
    def ip_address_restriction_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettings']:
        return pulumi.get(self, "ip_address_restriction_settings")

    @property
    @pulumi.getter(name="javascriptFrameworkSupport")
    def javascript_framework_support(self) -> Optional['outputs.WebApplicationMonitoringSettingsJavascriptFrameworkSupport']:
        return pulumi.get(self, "javascript_framework_support")

    @property
    @pulumi.getter(name="javascriptInjectionRules")
    def javascript_injection_rules(self) -> Optional['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRules']:
        return pulumi.get(self, "javascript_injection_rules")

    @property
    @pulumi.getter(name="libraryFileLocation")
    def library_file_location(self) -> Optional[str]:
        return pulumi.get(self, "library_file_location")

    @property
    @pulumi.getter(name="monitoringDataPath")
    def monitoring_data_path(self) -> Optional[str]:
        return pulumi.get(self, "monitoring_data_path")

    @property
    @pulumi.getter(name="scriptTagCacheDurationInHours")
    def script_tag_cache_duration_in_hours(self) -> Optional[int]:
        return pulumi.get(self, "script_tag_cache_duration_in_hours")

    @property
    @pulumi.getter(name="secureCookieAttribute")
    def secure_cookie_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "secure_cookie_attribute")

    @property
    @pulumi.getter(name="serverRequestPathId")
    def server_request_path_id(self) -> Optional[str]:
        return pulumi.get(self, "server_request_path_id")

    @property
    @pulumi.getter(name="xmlHttpRequest")
    def xml_http_request(self) -> Optional[bool]:
        return pulumi.get(self, "xml_http_request")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxActionNameLength":
            suggest = "max_action_name_length"
        elif key == "maxErrorsToCapture":
            suggest = "max_errors_to_capture"
        elif key == "additionalEventHandlers":
            suggest = "additional_event_handlers"
        elif key == "eventWrapperSettings":
            suggest = "event_wrapper_settings"
        elif key == "globalEventCaptureSettings":
            suggest = "global_event_capture_settings"
        elif key == "instrumentUnsupportedAjaxFrameworks":
            suggest = "instrument_unsupported_ajax_frameworks"
        elif key == "specialCharactersToEscape":
            suggest = "special_characters_to_escape"
        elif key == "syncBeaconFirefox":
            suggest = "sync_beacon_firefox"
        elif key == "syncBeaconInternetExplorer":
            suggest = "sync_beacon_internet_explorer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_action_name_length: int,
                 max_errors_to_capture: int,
                 additional_event_handlers: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers'] = None,
                 event_wrapper_settings: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings'] = None,
                 global_event_capture_settings: Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings'] = None,
                 instrument_unsupported_ajax_frameworks: Optional[bool] = None,
                 special_characters_to_escape: Optional[str] = None,
                 sync_beacon_firefox: Optional[bool] = None,
                 sync_beacon_internet_explorer: Optional[bool] = None):
        pulumi.set(__self__, "max_action_name_length", max_action_name_length)
        pulumi.set(__self__, "max_errors_to_capture", max_errors_to_capture)
        if additional_event_handlers is not None:
            pulumi.set(__self__, "additional_event_handlers", additional_event_handlers)
        if event_wrapper_settings is not None:
            pulumi.set(__self__, "event_wrapper_settings", event_wrapper_settings)
        if global_event_capture_settings is not None:
            pulumi.set(__self__, "global_event_capture_settings", global_event_capture_settings)
        if instrument_unsupported_ajax_frameworks is not None:
            pulumi.set(__self__, "instrument_unsupported_ajax_frameworks", instrument_unsupported_ajax_frameworks)
        if special_characters_to_escape is not None:
            pulumi.set(__self__, "special_characters_to_escape", special_characters_to_escape)
        if sync_beacon_firefox is not None:
            pulumi.set(__self__, "sync_beacon_firefox", sync_beacon_firefox)
        if sync_beacon_internet_explorer is not None:
            pulumi.set(__self__, "sync_beacon_internet_explorer", sync_beacon_internet_explorer)

    @property
    @pulumi.getter(name="maxActionNameLength")
    def max_action_name_length(self) -> int:
        return pulumi.get(self, "max_action_name_length")

    @property
    @pulumi.getter(name="maxErrorsToCapture")
    def max_errors_to_capture(self) -> int:
        return pulumi.get(self, "max_errors_to_capture")

    @property
    @pulumi.getter(name="additionalEventHandlers")
    def additional_event_handlers(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers']:
        return pulumi.get(self, "additional_event_handlers")

    @property
    @pulumi.getter(name="eventWrapperSettings")
    def event_wrapper_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings']:
        return pulumi.get(self, "event_wrapper_settings")

    @property
    @pulumi.getter(name="globalEventCaptureSettings")
    def global_event_capture_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings']:
        return pulumi.get(self, "global_event_capture_settings")

    @property
    @pulumi.getter(name="instrumentUnsupportedAjaxFrameworks")
    def instrument_unsupported_ajax_frameworks(self) -> Optional[bool]:
        return pulumi.get(self, "instrument_unsupported_ajax_frameworks")

    @property
    @pulumi.getter(name="specialCharactersToEscape")
    def special_characters_to_escape(self) -> Optional[str]:
        return pulumi.get(self, "special_characters_to_escape")

    @property
    @pulumi.getter(name="syncBeaconFirefox")
    def sync_beacon_firefox(self) -> Optional[bool]:
        return pulumi.get(self, "sync_beacon_firefox")

    @property
    @pulumi.getter(name="syncBeaconInternetExplorer")
    def sync_beacon_internet_explorer(self) -> Optional[bool]:
        return pulumi.get(self, "sync_beacon_internet_explorer")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDomNodes":
            suggest = "max_dom_nodes"
        elif key == "toStringMethod":
            suggest = "to_string_method"
        elif key == "useMouseUpEventForClicks":
            suggest = "use_mouse_up_event_for_clicks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_dom_nodes: int,
                 blur: Optional[bool] = None,
                 change: Optional[bool] = None,
                 click: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 to_string_method: Optional[bool] = None,
                 use_mouse_up_event_for_clicks: Optional[bool] = None):
        pulumi.set(__self__, "max_dom_nodes", max_dom_nodes)
        if blur is not None:
            pulumi.set(__self__, "blur", blur)
        if change is not None:
            pulumi.set(__self__, "change", change)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if to_string_method is not None:
            pulumi.set(__self__, "to_string_method", to_string_method)
        if use_mouse_up_event_for_clicks is not None:
            pulumi.set(__self__, "use_mouse_up_event_for_clicks", use_mouse_up_event_for_clicks)

    @property
    @pulumi.getter(name="maxDomNodes")
    def max_dom_nodes(self) -> int:
        return pulumi.get(self, "max_dom_nodes")

    @property
    @pulumi.getter
    def blur(self) -> Optional[bool]:
        return pulumi.get(self, "blur")

    @property
    @pulumi.getter
    def change(self) -> Optional[bool]:
        return pulumi.get(self, "change")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter(name="toStringMethod")
    def to_string_method(self) -> Optional[bool]:
        return pulumi.get(self, "to_string_method")

    @property
    @pulumi.getter(name="useMouseUpEventForClicks")
    def use_mouse_up_event_for_clicks(self) -> Optional[bool]:
        return pulumi.get(self, "use_mouse_up_event_for_clicks")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "touchEnd":
            suggest = "touch_end"
        elif key == "touchStart":
            suggest = "touch_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blur: Optional[bool] = None,
                 change: Optional[bool] = None,
                 click: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 touch_end: Optional[bool] = None,
                 touch_start: Optional[bool] = None):
        if blur is not None:
            pulumi.set(__self__, "blur", blur)
        if change is not None:
            pulumi.set(__self__, "change", change)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if touch_end is not None:
            pulumi.set(__self__, "touch_end", touch_end)
        if touch_start is not None:
            pulumi.set(__self__, "touch_start", touch_start)

    @property
    @pulumi.getter
    def blur(self) -> Optional[bool]:
        return pulumi.get(self, "blur")

    @property
    @pulumi.getter
    def change(self) -> Optional[bool]:
        return pulumi.get(self, "change")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter(name="touchEnd")
    def touch_end(self) -> Optional[bool]:
        return pulumi.get(self, "touch_end")

    @property
    @pulumi.getter(name="touchStart")
    def touch_start(self) -> Optional[bool]:
        return pulumi.get(self, "touch_start")


@pulumi.output_type
class WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalEventCapturedAsUserInput":
            suggest = "additional_event_captured_as_user_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_event_captured_as_user_input: Optional[str] = None,
                 click: Optional[bool] = None,
                 doubleclick: Optional[bool] = None,
                 keydown: Optional[bool] = None,
                 keyup: Optional[bool] = None,
                 mousedown: Optional[bool] = None,
                 mouseup: Optional[bool] = None,
                 scroll: Optional[bool] = None):
        if additional_event_captured_as_user_input is not None:
            pulumi.set(__self__, "additional_event_captured_as_user_input", additional_event_captured_as_user_input)
        if click is not None:
            pulumi.set(__self__, "click", click)
        if doubleclick is not None:
            pulumi.set(__self__, "doubleclick", doubleclick)
        if keydown is not None:
            pulumi.set(__self__, "keydown", keydown)
        if keyup is not None:
            pulumi.set(__self__, "keyup", keyup)
        if mousedown is not None:
            pulumi.set(__self__, "mousedown", mousedown)
        if mouseup is not None:
            pulumi.set(__self__, "mouseup", mouseup)
        if scroll is not None:
            pulumi.set(__self__, "scroll", scroll)

    @property
    @pulumi.getter(name="additionalEventCapturedAsUserInput")
    def additional_event_captured_as_user_input(self) -> Optional[str]:
        return pulumi.get(self, "additional_event_captured_as_user_input")

    @property
    @pulumi.getter
    def click(self) -> Optional[bool]:
        return pulumi.get(self, "click")

    @property
    @pulumi.getter
    def doubleclick(self) -> Optional[bool]:
        return pulumi.get(self, "doubleclick")

    @property
    @pulumi.getter
    def keydown(self) -> Optional[bool]:
        return pulumi.get(self, "keydown")

    @property
    @pulumi.getter
    def keyup(self) -> Optional[bool]:
        return pulumi.get(self, "keyup")

    @property
    @pulumi.getter
    def mousedown(self) -> Optional[bool]:
        return pulumi.get(self, "mousedown")

    @property
    @pulumi.getter
    def mouseup(self) -> Optional[bool]:
        return pulumi.get(self, "mouseup")

    @property
    @pulumi.getter
    def scroll(self) -> Optional[bool]:
        return pulumi.get(self, "scroll")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettings(dict):
    def __init__(__self__, *,
                 mode: str,
                 restrictions: Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions'] = None):
        pulumi.set(__self__, "mode", mode)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions']:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictions(dict):
    def __init__(__self__, *,
                 restrictions: Sequence['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction']):
        pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def restrictions(self) -> Sequence['outputs.WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction']:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "browserType":
            suggest = "browser_type"
        elif key == "browserVersion":
            suggest = "browser_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 browser_type: str,
                 browser_version: Optional[str] = None,
                 comparator: Optional[str] = None,
                 platform: Optional[str] = None):
        pulumi.set(__self__, "browser_type", browser_type)
        if browser_version is not None:
            pulumi.set(__self__, "browser_version", browser_version)
        if comparator is not None:
            pulumi.set(__self__, "comparator", comparator)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter(name="browserType")
    def browser_type(self) -> str:
        return pulumi.get(self, "browser_type")

    @property
    @pulumi.getter(name="browserVersion")
    def browser_version(self) -> Optional[str]:
        return pulumi.get(self, "browser_version")

    @property
    @pulumi.getter
    def comparator(self) -> Optional[str]:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        return pulumi.get(self, "platform")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCapture(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "javascriptErrors":
            suggest = "javascript_errors"
        elif key == "resourceTimingSettings":
            suggest = "resource_timing_settings"
        elif key == "timeoutSettings":
            suggest = "timeout_settings"
        elif key == "visuallyCompleteAndSpeedIndex":
            suggest = "visually_complete_and_speed_index"
        elif key == "visuallyCompleteSettings":
            suggest = "visually_complete_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCapture. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCapture.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCapture.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 javascript_errors: Optional[bool] = None,
                 resource_timing_settings: Optional['outputs.WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings'] = None,
                 timeout_settings: Optional['outputs.WebApplicationMonitoringSettingsContentCaptureTimeoutSettings'] = None,
                 visually_complete_and_speed_index: Optional[bool] = None,
                 visually_complete_settings: Optional['outputs.WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings'] = None):
        if javascript_errors is not None:
            pulumi.set(__self__, "javascript_errors", javascript_errors)
        if resource_timing_settings is not None:
            pulumi.set(__self__, "resource_timing_settings", resource_timing_settings)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if visually_complete_and_speed_index is not None:
            pulumi.set(__self__, "visually_complete_and_speed_index", visually_complete_and_speed_index)
        if visually_complete_settings is not None:
            pulumi.set(__self__, "visually_complete_settings", visually_complete_settings)

    @property
    @pulumi.getter(name="javascriptErrors")
    def javascript_errors(self) -> Optional[bool]:
        return pulumi.get(self, "javascript_errors")

    @property
    @pulumi.getter(name="resourceTimingSettings")
    def resource_timing_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings']:
        return pulumi.get(self, "resource_timing_settings")

    @property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsContentCaptureTimeoutSettings']:
        return pulumi.get(self, "timeout_settings")

    @property
    @pulumi.getter(name="visuallyCompleteAndSpeedIndex")
    def visually_complete_and_speed_index(self) -> Optional[bool]:
        return pulumi.get(self, "visually_complete_and_speed_index")

    @property
    @pulumi.getter(name="visuallyCompleteSettings")
    def visually_complete_settings(self) -> Optional['outputs.WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings']:
        return pulumi.get(self, "visually_complete_settings")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instrumentationDelay":
            suggest = "instrumentation_delay"
        elif key == "nonW3cResourceTimings":
            suggest = "non_w3c_resource_timings"
        elif key == "resourceTimingCaptureType":
            suggest = "resource_timing_capture_type"
        elif key == "resourceTimingsDomainLimit":
            suggest = "resource_timings_domain_limit"
        elif key == "w3cResourceTimings":
            suggest = "w3c_resource_timings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureResourceTimingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instrumentation_delay: int,
                 non_w3c_resource_timings: Optional[bool] = None,
                 resource_timing_capture_type: Optional[str] = None,
                 resource_timings_domain_limit: Optional[int] = None,
                 w3c_resource_timings: Optional[bool] = None):
        pulumi.set(__self__, "instrumentation_delay", instrumentation_delay)
        if non_w3c_resource_timings is not None:
            pulumi.set(__self__, "non_w3c_resource_timings", non_w3c_resource_timings)
        if resource_timing_capture_type is not None:
            pulumi.set(__self__, "resource_timing_capture_type", resource_timing_capture_type)
        if resource_timings_domain_limit is not None:
            pulumi.set(__self__, "resource_timings_domain_limit", resource_timings_domain_limit)
        if w3c_resource_timings is not None:
            pulumi.set(__self__, "w3c_resource_timings", w3c_resource_timings)

    @property
    @pulumi.getter(name="instrumentationDelay")
    def instrumentation_delay(self) -> int:
        return pulumi.get(self, "instrumentation_delay")

    @property
    @pulumi.getter(name="nonW3cResourceTimings")
    def non_w3c_resource_timings(self) -> Optional[bool]:
        return pulumi.get(self, "non_w3c_resource_timings")

    @property
    @pulumi.getter(name="resourceTimingCaptureType")
    def resource_timing_capture_type(self) -> Optional[str]:
        return pulumi.get(self, "resource_timing_capture_type")

    @property
    @pulumi.getter(name="resourceTimingsDomainLimit")
    def resource_timings_domain_limit(self) -> Optional[int]:
        return pulumi.get(self, "resource_timings_domain_limit")

    @property
    @pulumi.getter(name="w3cResourceTimings")
    def w3c_resource_timings(self) -> Optional[bool]:
        return pulumi.get(self, "w3c_resource_timings")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporaryActionLimit":
            suggest = "temporary_action_limit"
        elif key == "temporaryActionTotalTimeout":
            suggest = "temporary_action_total_timeout"
        elif key == "timedActionSupport":
            suggest = "timed_action_support"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporary_action_limit: int,
                 temporary_action_total_timeout: int,
                 timed_action_support: Optional[bool] = None):
        pulumi.set(__self__, "temporary_action_limit", temporary_action_limit)
        pulumi.set(__self__, "temporary_action_total_timeout", temporary_action_total_timeout)
        if timed_action_support is not None:
            pulumi.set(__self__, "timed_action_support", timed_action_support)

    @property
    @pulumi.getter(name="temporaryActionLimit")
    def temporary_action_limit(self) -> int:
        return pulumi.get(self, "temporary_action_limit")

    @property
    @pulumi.getter(name="temporaryActionTotalTimeout")
    def temporary_action_total_timeout(self) -> int:
        return pulumi.get(self, "temporary_action_total_timeout")

    @property
    @pulumi.getter(name="timedActionSupport")
    def timed_action_support(self) -> Optional[bool]:
        return pulumi.get(self, "timed_action_support")


@pulumi.output_type
class WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeUrlRegex":
            suggest = "exclude_url_regex"
        elif key == "ignoredMutationsList":
            suggest = "ignored_mutations_list"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "mutationTimeout":
            suggest = "mutation_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsContentCaptureVisuallyCompleteSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_url_regex: Optional[str] = None,
                 ignored_mutations_list: Optional[str] = None,
                 inactivity_timeout: Optional[int] = None,
                 mutation_timeout: Optional[int] = None,
                 threshold: Optional[int] = None):
        if exclude_url_regex is not None:
            pulumi.set(__self__, "exclude_url_regex", exclude_url_regex)
        if ignored_mutations_list is not None:
            pulumi.set(__self__, "ignored_mutations_list", ignored_mutations_list)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if mutation_timeout is not None:
            pulumi.set(__self__, "mutation_timeout", mutation_timeout)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="excludeUrlRegex")
    def exclude_url_regex(self) -> Optional[str]:
        return pulumi.get(self, "exclude_url_regex")

    @property
    @pulumi.getter(name="ignoredMutationsList")
    def ignored_mutations_list(self) -> Optional[str]:
        return pulumi.get(self, "ignored_mutations_list")

    @property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[int]:
        return pulumi.get(self, "inactivity_timeout")

    @property
    @pulumi.getter(name="mutationTimeout")
    def mutation_timeout(self) -> Optional[int]:
        return pulumi.get(self, "mutation_timeout")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettings(dict):
    def __init__(__self__, *,
                 mode: str,
                 restrictions: Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions'] = None):
        pulumi.set(__self__, "mode", mode)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions']:
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictions(dict):
    def __init__(__self__, *,
                 ranges: Sequence['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange']):
        pulumi.set(__self__, "ranges", ranges)

    @property
    @pulumi.getter
    def ranges(self) -> Sequence['outputs.WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange']:
        return pulumi.get(self, "ranges")


@pulumi.output_type
class WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressTo":
            suggest = "address_to"
        elif key == "subnetMask":
            suggest = "subnet_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 address_to: Optional[str] = None,
                 subnet_mask: Optional[int] = None):
        pulumi.set(__self__, "address", address)
        if address_to is not None:
            pulumi.set(__self__, "address_to", address_to)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="addressTo")
    def address_to(self) -> Optional[str]:
        return pulumi.get(self, "address_to")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[int]:
        return pulumi.get(self, "subnet_mask")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptFrameworkSupport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeXObject":
            suggest = "active_x_object"
        elif key == "mooTools":
            suggest = "moo_tools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsJavascriptFrameworkSupport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsJavascriptFrameworkSupport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsJavascriptFrameworkSupport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_x_object: Optional[bool] = None,
                 angular: Optional[bool] = None,
                 dojo: Optional[bool] = None,
                 extjs: Optional[bool] = None,
                 icefaces: Optional[bool] = None,
                 jquery: Optional[bool] = None,
                 moo_tools: Optional[bool] = None,
                 prototype: Optional[bool] = None):
        if active_x_object is not None:
            pulumi.set(__self__, "active_x_object", active_x_object)
        if angular is not None:
            pulumi.set(__self__, "angular", angular)
        if dojo is not None:
            pulumi.set(__self__, "dojo", dojo)
        if extjs is not None:
            pulumi.set(__self__, "extjs", extjs)
        if icefaces is not None:
            pulumi.set(__self__, "icefaces", icefaces)
        if jquery is not None:
            pulumi.set(__self__, "jquery", jquery)
        if moo_tools is not None:
            pulumi.set(__self__, "moo_tools", moo_tools)
        if prototype is not None:
            pulumi.set(__self__, "prototype", prototype)

    @property
    @pulumi.getter(name="activeXObject")
    def active_x_object(self) -> Optional[bool]:
        return pulumi.get(self, "active_x_object")

    @property
    @pulumi.getter
    def angular(self) -> Optional[bool]:
        return pulumi.get(self, "angular")

    @property
    @pulumi.getter
    def dojo(self) -> Optional[bool]:
        return pulumi.get(self, "dojo")

    @property
    @pulumi.getter
    def extjs(self) -> Optional[bool]:
        return pulumi.get(self, "extjs")

    @property
    @pulumi.getter
    def icefaces(self) -> Optional[bool]:
        return pulumi.get(self, "icefaces")

    @property
    @pulumi.getter
    def jquery(self) -> Optional[bool]:
        return pulumi.get(self, "jquery")

    @property
    @pulumi.getter(name="mooTools")
    def moo_tools(self) -> Optional[bool]:
        return pulumi.get(self, "moo_tools")

    @property
    @pulumi.getter
    def prototype(self) -> Optional[bool]:
        return pulumi.get(self, "prototype")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptInjectionRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationMonitoringSettingsJavascriptInjectionRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationMonitoringSettingsJavascriptInjectionRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlOperator":
            suggest = "url_operator"
        elif key == "htmlPattern":
            suggest = "html_pattern"
        elif key == "urlPattern":
            suggest = "url_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationMonitoringSettingsJavascriptInjectionRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationMonitoringSettingsJavascriptInjectionRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationMonitoringSettingsJavascriptInjectionRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule: str,
                 url_operator: str,
                 enabled: Optional[bool] = None,
                 html_pattern: Optional[str] = None,
                 target: Optional[str] = None,
                 url_pattern: Optional[str] = None):
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "url_operator", url_operator)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if html_pattern is not None:
            pulumi.set(__self__, "html_pattern", html_pattern)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if url_pattern is not None:
            pulumi.set(__self__, "url_pattern", url_pattern)

    @property
    @pulumi.getter
    def rule(self) -> str:
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter(name="urlOperator")
    def url_operator(self) -> str:
        return pulumi.get(self, "url_operator")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="htmlPattern")
    def html_pattern(self) -> Optional[str]:
        return pulumi.get(self, "html_pattern")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="urlPattern")
    def url_pattern(self) -> Optional[str]:
        return pulumi.get(self, "url_pattern")


@pulumi.output_type
class WebApplicationSessionReplayConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costControlPercentage":
            suggest = "cost_control_percentage"
        elif key == "cssResourceCapturingExclusionRules":
            suggest = "css_resource_capturing_exclusion_rules"
        elif key == "enableCssResourceCapturing":
            suggest = "enable_css_resource_capturing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationSessionReplayConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationSessionReplayConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationSessionReplayConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_control_percentage: int,
                 css_resource_capturing_exclusion_rules: Optional[Sequence[str]] = None,
                 enable_css_resource_capturing: Optional[bool] = None,
                 enabled: Optional[bool] = None):
        """
        :param int cost_control_percentage: Session replay sampling rating in percent
        :param Sequence[str] css_resource_capturing_exclusion_rules: A list of URLs to be excluded from CSS resource capturing
        :param bool enable_css_resource_capturing: Capture (`true`) or don't capture (`false`) CSS resources from the session
        :param bool enabled: SessionReplay Enabled/Disabled
        """
        pulumi.set(__self__, "cost_control_percentage", cost_control_percentage)
        if css_resource_capturing_exclusion_rules is not None:
            pulumi.set(__self__, "css_resource_capturing_exclusion_rules", css_resource_capturing_exclusion_rules)
        if enable_css_resource_capturing is not None:
            pulumi.set(__self__, "enable_css_resource_capturing", enable_css_resource_capturing)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="costControlPercentage")
    def cost_control_percentage(self) -> int:
        """
        Session replay sampling rating in percent
        """
        return pulumi.get(self, "cost_control_percentage")

    @property
    @pulumi.getter(name="cssResourceCapturingExclusionRules")
    def css_resource_capturing_exclusion_rules(self) -> Optional[Sequence[str]]:
        """
        A list of URLs to be excluded from CSS resource capturing
        """
        return pulumi.get(self, "css_resource_capturing_exclusion_rules")

    @property
    @pulumi.getter(name="enableCssResourceCapturing")
    def enable_css_resource_capturing(self) -> Optional[bool]:
        """
        Capture (`true`) or don't capture (`false`) CSS resources from the session
        """
        return pulumi.get(self, "enable_css_resource_capturing")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        SessionReplay Enabled/Disabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WebApplicationUserActionAndSessionProperties(dict):
    def __init__(__self__, *,
                 properties: Optional[Sequence['outputs.WebApplicationUserActionAndSessionPropertiesProperty']] = None):
        """
        :param Sequence['WebApplicationUserActionAndSessionPropertiesPropertyArgs'] properties: User action and session properties settings
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.WebApplicationUserActionAndSessionPropertiesProperty']]:
        """
        User action and session properties settings
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class WebApplicationUserActionAndSessionPropertiesProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "longStringLength":
            suggest = "long_string_length"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "serverSideRequestAttribute":
            suggest = "server_side_request_attribute"
        elif key == "storeAsSessionProperty":
            suggest = "store_as_session_property"
        elif key == "storeAsUserActionProperty":
            suggest = "store_as_user_action_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionAndSessionPropertiesProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionAndSessionPropertiesProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionAndSessionPropertiesProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: int,
                 key: str,
                 origin: str,
                 type: str,
                 aggregation: Optional[str] = None,
                 cleanup_rule: Optional[str] = None,
                 display_name: Optional[str] = None,
                 ignore_case: Optional[bool] = None,
                 long_string_length: Optional[int] = None,
                 metadata_id: Optional[int] = None,
                 server_side_request_attribute: Optional[str] = None,
                 store_as_session_property: Optional[bool] = None,
                 store_as_user_action_property: Optional[bool] = None):
        """
        :param int id: The ID of this resource.
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "type", type)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if long_string_length is not None:
            pulumi.set(__self__, "long_string_length", long_string_length)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if server_side_request_attribute is not None:
            pulumi.set(__self__, "server_side_request_attribute", server_side_request_attribute)
        if store_as_session_property is not None:
            pulumi.set(__self__, "store_as_session_property", store_as_session_property)
        if store_as_user_action_property is not None:
            pulumi.set(__self__, "store_as_user_action_property", store_as_user_action_property)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def origin(self) -> str:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="longStringLength")
    def long_string_length(self) -> Optional[int]:
        return pulumi.get(self, "long_string_length")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="serverSideRequestAttribute")
    def server_side_request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "server_side_request_attribute")

    @property
    @pulumi.getter(name="storeAsSessionProperty")
    def store_as_session_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_session_property")

    @property
    @pulumi.getter(name="storeAsUserActionProperty")
    def store_as_user_action_property(self) -> Optional[bool]:
        return pulumi.get(self, "store_as_user_action_property")


@pulumi.output_type
class WebApplicationUserActionNamingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionNamingRules":
            suggest = "custom_action_naming_rules"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "loadActionNamingRules":
            suggest = "load_action_naming_rules"
        elif key == "queryParameterCleanups":
            suggest = "query_parameter_cleanups"
        elif key == "splitUserActionsByDomain":
            suggest = "split_user_actions_by_domain"
        elif key == "useFirstDetectedLoadAction":
            suggest = "use_first_detected_load_action"
        elif key == "xhrActionNamingRules":
            suggest = "xhr_action_naming_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRules'] = None,
                 ignore_case: Optional[bool] = None,
                 load_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRules'] = None,
                 placeholders: Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholders'] = None,
                 query_parameter_cleanups: Optional[Sequence[str]] = None,
                 split_user_actions_by_domain: Optional[bool] = None,
                 use_first_detected_load_action: Optional[bool] = None,
                 xhr_action_naming_rules: Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRules'] = None):
        """
        :param 'WebApplicationUserActionNamingSettingsCustomActionNamingRulesArgs' custom_action_naming_rules: User action naming rules for custom actions
        :param bool ignore_case: Case insensitive naming
        :param 'WebApplicationUserActionNamingSettingsLoadActionNamingRulesArgs' load_action_naming_rules: User action naming rules for loading actions
        :param 'WebApplicationUserActionNamingSettingsPlaceholdersArgs' placeholders: User action placeholders
        :param Sequence[str] query_parameter_cleanups: User action naming rules for custom actions
        :param bool split_user_actions_by_domain: Deactivate this setting if different domains should not result in separate user actions
        :param bool use_first_detected_load_action: First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
        :param 'WebApplicationUserActionNamingSettingsXhrActionNamingRulesArgs' xhr_action_naming_rules: User action naming rules for XHR actions
        """
        if custom_action_naming_rules is not None:
            pulumi.set(__self__, "custom_action_naming_rules", custom_action_naming_rules)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if load_action_naming_rules is not None:
            pulumi.set(__self__, "load_action_naming_rules", load_action_naming_rules)
        if placeholders is not None:
            pulumi.set(__self__, "placeholders", placeholders)
        if query_parameter_cleanups is not None:
            pulumi.set(__self__, "query_parameter_cleanups", query_parameter_cleanups)
        if split_user_actions_by_domain is not None:
            pulumi.set(__self__, "split_user_actions_by_domain", split_user_actions_by_domain)
        if use_first_detected_load_action is not None:
            pulumi.set(__self__, "use_first_detected_load_action", use_first_detected_load_action)
        if xhr_action_naming_rules is not None:
            pulumi.set(__self__, "xhr_action_naming_rules", xhr_action_naming_rules)

    @property
    @pulumi.getter(name="customActionNamingRules")
    def custom_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRules']:
        """
        User action naming rules for custom actions
        """
        return pulumi.get(self, "custom_action_naming_rules")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Case insensitive naming
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="loadActionNamingRules")
    def load_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRules']:
        """
        User action naming rules for loading actions
        """
        return pulumi.get(self, "load_action_naming_rules")

    @property
    @pulumi.getter
    def placeholders(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholders']:
        """
        User action placeholders
        """
        return pulumi.get(self, "placeholders")

    @property
    @pulumi.getter(name="queryParameterCleanups")
    def query_parameter_cleanups(self) -> Optional[Sequence[str]]:
        """
        User action naming rules for custom actions
        """
        return pulumi.get(self, "query_parameter_cleanups")

    @property
    @pulumi.getter(name="splitUserActionsByDomain")
    def split_user_actions_by_domain(self) -> Optional[bool]:
        """
        Deactivate this setting if different domains should not result in separate user actions
        """
        return pulumi.get(self, "split_user_actions_by_domain")

    @property
    @pulumi.getter(name="useFirstDetectedLoadAction")
    def use_first_detected_load_action(self) -> Optional[bool]:
        """
        First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
        """
        return pulumi.get(self, "use_first_detected_load_action")

    @property
    @pulumi.getter(name="xhrActionNamingRules")
    def xhr_action_naming_rules(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRules']:
        """
        User action naming rules for XHR actions
        """
        return pulumi.get(self, "xhr_action_naming_rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsCustomActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsLoadActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholders(dict):
    def __init__(__self__, *,
                 placeholders: Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder']):
        pulumi.set(__self__, "placeholders", placeholders)

    @property
    @pulumi.getter
    def placeholders(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder']:
        return pulumi.get(self, "placeholders")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processingPart":
            suggest = "processing_part"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "processingSteps":
            suggest = "processing_steps"
        elif key == "useGuessedElementIdentifier":
            suggest = "use_guessed_element_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input: str,
                 name: str,
                 processing_part: str,
                 metadata_id: Optional[int] = None,
                 processing_steps: Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps'] = None,
                 use_guessed_element_identifier: Optional[bool] = None):
        """
        :param str name: The name of the web application, displayed in the UI
        """
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "processing_part", processing_part)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if processing_steps is not None:
            pulumi.set(__self__, "processing_steps", processing_steps)
        if use_guessed_element_identifier is not None:
            pulumi.set(__self__, "use_guessed_element_identifier", use_guessed_element_identifier)

    @property
    @pulumi.getter
    def input(self) -> str:
        return pulumi.get(self, "input")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the web application, displayed in the UI
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="processingPart")
    def processing_part(self) -> str:
        return pulumi.get(self, "processing_part")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="processingSteps")
    def processing_steps(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps']:
        return pulumi.get(self, "processing_steps")

    @property
    @pulumi.getter(name="useGuessedElementIdentifier")
    def use_guessed_element_identifier(self) -> Optional[bool]:
        return pulumi.get(self, "use_guessed_element_identifier")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps(dict):
    def __init__(__self__, *,
                 steps: Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep']):
        pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep']:
        return pulumi.get(self, "steps")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackToInput":
            suggest = "fallback_to_input"
        elif key == "patternAfter":
            suggest = "pattern_after"
        elif key == "patternAfterSearchType":
            suggest = "pattern_after_search_type"
        elif key == "patternBefore":
            suggest = "pattern_before"
        elif key == "patternBeforeSearchType":
            suggest = "pattern_before_search_type"
        elif key == "patternToReplace":
            suggest = "pattern_to_replace"
        elif key == "regularExpression":
            suggest = "regular_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 fallback_to_input: Optional[bool] = None,
                 pattern_after: Optional[str] = None,
                 pattern_after_search_type: Optional[str] = None,
                 pattern_before: Optional[str] = None,
                 pattern_before_search_type: Optional[str] = None,
                 pattern_to_replace: Optional[str] = None,
                 regular_expression: Optional[str] = None,
                 replacement: Optional[str] = None):
        """
        :param str type: The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        pulumi.set(__self__, "type", type)
        if fallback_to_input is not None:
            pulumi.set(__self__, "fallback_to_input", fallback_to_input)
        if pattern_after is not None:
            pulumi.set(__self__, "pattern_after", pattern_after)
        if pattern_after_search_type is not None:
            pulumi.set(__self__, "pattern_after_search_type", pattern_after_search_type)
        if pattern_before is not None:
            pulumi.set(__self__, "pattern_before", pattern_before)
        if pattern_before_search_type is not None:
            pulumi.set(__self__, "pattern_before_search_type", pattern_before_search_type)
        if pattern_to_replace is not None:
            pulumi.set(__self__, "pattern_to_replace", pattern_to_replace)
        if regular_expression is not None:
            pulumi.set(__self__, "regular_expression", regular_expression)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fallbackToInput")
    def fallback_to_input(self) -> Optional[bool]:
        return pulumi.get(self, "fallback_to_input")

    @property
    @pulumi.getter(name="patternAfter")
    def pattern_after(self) -> Optional[str]:
        return pulumi.get(self, "pattern_after")

    @property
    @pulumi.getter(name="patternAfterSearchType")
    def pattern_after_search_type(self) -> Optional[str]:
        return pulumi.get(self, "pattern_after_search_type")

    @property
    @pulumi.getter(name="patternBefore")
    def pattern_before(self) -> Optional[str]:
        return pulumi.get(self, "pattern_before")

    @property
    @pulumi.getter(name="patternBeforeSearchType")
    def pattern_before_search_type(self) -> Optional[str]:
        return pulumi.get(self, "pattern_before_search_type")

    @property
    @pulumi.getter(name="patternToReplace")
    def pattern_to_replace(self) -> Optional[str]:
        return pulumi.get(self, "pattern_to_replace")

    @property
    @pulumi.getter(name="regularExpression")
    def regular_expression(self) -> Optional[str]:
        return pulumi.get(self, "regular_expression")

    @property
    @pulumi.getter
    def replacement(self) -> Optional[str]:
        return pulumi.get(self, "replacement")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRules(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOrConditions":
            suggest = "use_or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserActionNamingSettingsXhrActionNamingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: str,
                 conditions: Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions'] = None,
                 use_or_conditions: Optional[bool] = None):
        pulumi.set(__self__, "template", template)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if use_or_conditions is not None:
            pulumi.set(__self__, "use_or_conditions", use_or_conditions)

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="useOrConditions")
    def use_or_conditions(self) -> Optional[bool]:
        return pulumi.get(self, "use_or_conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditions(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition']):
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition']:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class WebApplicationUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition(dict):
    def __init__(__self__, *,
                 operand1: str,
                 operator: str,
                 operand2: Optional[str] = None):
        pulumi.set(__self__, "operand1", operand1)
        pulumi.set(__self__, "operator", operator)
        if operand2 is not None:
            pulumi.set(__self__, "operand2", operand2)

    @property
    @pulumi.getter
    def operand1(self) -> str:
        return pulumi.get(self, "operand1")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def operand2(self) -> Optional[str]:
        return pulumi.get(self, "operand2")


@pulumi.output_type
class WebApplicationUserTags(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.WebApplicationUserTagsTag']):
        """
        :param Sequence['WebApplicationUserTagsTagArgs'] tags: User tag settings
        """
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.WebApplicationUserTagsTag']:
        """
        User tag settings
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class WebApplicationUserTagsTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupRule":
            suggest = "cleanup_rule"
        elif key == "ignoreCase":
            suggest = "ignore_case"
        elif key == "metadataId":
            suggest = "metadata_id"
        elif key == "serverSideRequestAttribute":
            suggest = "server_side_request_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationUserTagsTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationUserTagsTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationUserTagsTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: int,
                 cleanup_rule: Optional[str] = None,
                 ignore_case: Optional[bool] = None,
                 metadata_id: Optional[int] = None,
                 server_side_request_attribute: Optional[str] = None):
        """
        :param int id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        if cleanup_rule is not None:
            pulumi.set(__self__, "cleanup_rule", cleanup_rule)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if metadata_id is not None:
            pulumi.set(__self__, "metadata_id", metadata_id)
        if server_side_request_attribute is not None:
            pulumi.set(__self__, "server_side_request_attribute", server_side_request_attribute)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="cleanupRule")
    def cleanup_rule(self) -> Optional[str]:
        return pulumi.get(self, "cleanup_rule")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter(name="metadataId")
    def metadata_id(self) -> Optional[int]:
        return pulumi.get(self, "metadata_id")

    @property
    @pulumi.getter(name="serverSideRequestAttribute")
    def server_side_request_attribute(self) -> Optional[str]:
        return pulumi.get(self, "server_side_request_attribute")


@pulumi.output_type
class WebApplicationWaterfallSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceBrowserCachingThreshold":
            suggest = "resource_browser_caching_threshold"
        elif key == "resourcesThreshold":
            suggest = "resources_threshold"
        elif key == "slowCndResourcesThreshold":
            suggest = "slow_cnd_resources_threshold"
        elif key == "slowFirstPartyResourcesThreshold":
            suggest = "slow_first_party_resources_threshold"
        elif key == "slowThirdPartyResourcesThreshold":
            suggest = "slow_third_party_resources_threshold"
        elif key == "speedIndexVisuallyCompleteRatioThreshold":
            suggest = "speed_index_visually_complete_ratio_threshold"
        elif key == "uncompressedResourcesThreshold":
            suggest = "uncompressed_resources_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationWaterfallSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationWaterfallSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationWaterfallSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_browser_caching_threshold: int,
                 resources_threshold: int,
                 slow_cnd_resources_threshold: int,
                 slow_first_party_resources_threshold: int,
                 slow_third_party_resources_threshold: int,
                 speed_index_visually_complete_ratio_threshold: int,
                 uncompressed_resources_threshold: int):
        """
        :param int resource_browser_caching_threshold: Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
        :param int resources_threshold: Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
        :param int slow_cnd_resources_threshold: Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int slow_first_party_resources_threshold: Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int slow_third_party_resources_threshold: Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        :param int speed_index_visually_complete_ratio_threshold: Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
        :param int uncompressed_resources_threshold: Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
        """
        pulumi.set(__self__, "resource_browser_caching_threshold", resource_browser_caching_threshold)
        pulumi.set(__self__, "resources_threshold", resources_threshold)
        pulumi.set(__self__, "slow_cnd_resources_threshold", slow_cnd_resources_threshold)
        pulumi.set(__self__, "slow_first_party_resources_threshold", slow_first_party_resources_threshold)
        pulumi.set(__self__, "slow_third_party_resources_threshold", slow_third_party_resources_threshold)
        pulumi.set(__self__, "speed_index_visually_complete_ratio_threshold", speed_index_visually_complete_ratio_threshold)
        pulumi.set(__self__, "uncompressed_resources_threshold", uncompressed_resources_threshold)

    @property
    @pulumi.getter(name="resourceBrowserCachingThreshold")
    def resource_browser_caching_threshold(self) -> int:
        """
        Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
        """
        return pulumi.get(self, "resource_browser_caching_threshold")

    @property
    @pulumi.getter(name="resourcesThreshold")
    def resources_threshold(self) -> int:
        """
        Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "resources_threshold")

    @property
    @pulumi.getter(name="slowCndResourcesThreshold")
    def slow_cnd_resources_threshold(self) -> int:
        """
        Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_cnd_resources_threshold")

    @property
    @pulumi.getter(name="slowFirstPartyResourcesThreshold")
    def slow_first_party_resources_threshold(self) -> int:
        """
        Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_first_party_resources_threshold")

    @property
    @pulumi.getter(name="slowThirdPartyResourcesThreshold")
    def slow_third_party_resources_threshold(self) -> int:
        """
        Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
        """
        return pulumi.get(self, "slow_third_party_resources_threshold")

    @property
    @pulumi.getter(name="speedIndexVisuallyCompleteRatioThreshold")
    def speed_index_visually_complete_ratio_threshold(self) -> int:
        """
        Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
        """
        return pulumi.get(self, "speed_index_visually_complete_ratio_threshold")

    @property
    @pulumi.getter(name="uncompressedResourcesThreshold")
    def uncompressed_resources_threshold(self) -> int:
        """
        Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
        """
        return pulumi.get(self, "uncompressed_resources_threshold")


@pulumi.output_type
class WebApplicationXhrActionApdexSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frustratingFallbackThreshold":
            suggest = "frustrating_fallback_threshold"
        elif key == "frustratingThreshold":
            suggest = "frustrating_threshold"
        elif key == "toleratedFallbackThreshold":
            suggest = "tolerated_fallback_threshold"
        elif key == "toleratedThreshold":
            suggest = "tolerated_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebApplicationXhrActionApdexSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebApplicationXhrActionApdexSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebApplicationXhrActionApdexSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frustrating_fallback_threshold: Optional[int] = None,
                 frustrating_threshold: Optional[int] = None,
                 threshold: Optional[int] = None,
                 tolerated_fallback_threshold: Optional[int] = None,
                 tolerated_threshold: Optional[int] = None):
        """
        :param int frustrating_fallback_threshold: Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        :param int frustrating_threshold: Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        :param int threshold: no documentation available
        :param int tolerated_fallback_threshold: Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        :param int tolerated_threshold: Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        if frustrating_fallback_threshold is not None:
            pulumi.set(__self__, "frustrating_fallback_threshold", frustrating_fallback_threshold)
        if frustrating_threshold is not None:
            pulumi.set(__self__, "frustrating_threshold", frustrating_threshold)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if tolerated_fallback_threshold is not None:
            pulumi.set(__self__, "tolerated_fallback_threshold", tolerated_fallback_threshold)
        if tolerated_threshold is not None:
            pulumi.set(__self__, "tolerated_threshold", tolerated_threshold)

    @property
    @pulumi.getter(name="frustratingFallbackThreshold")
    def frustrating_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_fallback_threshold")

    @property
    @pulumi.getter(name="frustratingThreshold")
    def frustrating_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
        """
        return pulumi.get(self, "frustrating_threshold")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        no documentation available
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="toleratedFallbackThreshold")
    def tolerated_fallback_threshold(self) -> Optional[int]:
        """
        Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_fallback_threshold")

    @property
    @pulumi.getter(name="toleratedThreshold")
    def tolerated_threshold(self) -> Optional[int]:
        """
        Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
        """
        return pulumi.get(self, "tolerated_threshold")


@pulumi.output_type
class WebhookNotificationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.WebhookNotificationHeadersHeader']):
        """
        :param Sequence['WebhookNotificationHeadersHeaderArgs'] headers: An additional HTTP Header to include when sending requests
        """
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.WebhookNotificationHeadersHeader']:
        """
        An additional HTTP Header to include when sending requests
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class WebhookNotificationHeadersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookNotificationHeadersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookNotificationHeadersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookNotificationHeadersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the notification configuration
        """
        pulumi.set(__self__, "name", name)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class XmattersNotificationHeaders(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.XmattersNotificationHeadersHeader']):
        """
        :param Sequence['XmattersNotificationHeadersHeaderArgs'] headers: An additional HTTP Header to include when sending requests
        """
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.XmattersNotificationHeadersHeader']:
        """
        An additional HTTP Header to include when sending requests
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class XmattersNotificationHeadersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in XmattersNotificationHeadersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        XmattersNotificationHeadersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        XmattersNotificationHeadersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 secret_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the notification configuration
        """
        pulumi.set(__self__, "name", name)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notification configuration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[str]:
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSyntheticLocationsLocationsResult(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence['outputs.GetSyntheticLocationsLocationsLocationResult']] = None):
        """
        :param Sequence['GetSyntheticLocationsLocationsLocationArgs'] locations: The name of the location
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.GetSyntheticLocationsLocationsLocationResult']]:
        """
        The name of the location
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSyntheticLocationsLocationsLocationResult(dict):
    def __init__(__self__, *,
                 cloud_platform: str,
                 ips: Sequence[str],
                 stage: str,
                 status: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "cloud_platform", cloud_platform)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "stage", stage)
        pulumi.set(__self__, "status", status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudPlatform")
    def cloud_platform(self) -> str:
        return pulumi.get(self, "cloud_platform")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def stage(self) -> str:
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


