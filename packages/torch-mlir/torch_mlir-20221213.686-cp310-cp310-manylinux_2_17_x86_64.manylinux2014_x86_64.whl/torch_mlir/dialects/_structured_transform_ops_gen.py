
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _structured_transform_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DecomposeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.decompose"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FuseIntoContainingOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.fuse_into_containing_op"

  _ODS_REGIONS = (0, True)

  def __init__(self, fused_op, producer_op, containing_op, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(producer_op))
    operands.append(_get_op_result_or_value(containing_op))
    results.append(fused_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def producer_op(self):
    return self.operation.operands[0]

  @builtins.property
  def containing_op(self):
    return self.operation.operands[1]

  @builtins.property
  def fused_op(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FuseOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.fuse"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, loops, target, *, tile_sizes=None, tile_interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if tile_sizes is not None: attributes["tile_sizes"] = tile_sizes
    if tile_interchange is not None: attributes["tile_interchange"] = tile_interchange
    results.append(transformed)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GeneralizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.generalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InterchangeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.interchange"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, iterator_interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if iterator_interchange is not None: attributes["iterator_interchange"] = iterator_interchange
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MatchOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.match"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, target, *, ops=None, interface=None, op_attrs=None, filter_result_type=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if ops is not None: attributes["ops"] = ops
    if interface is not None: attributes["interface"] = interface
    if op_attrs is not None: attributes["op_attrs"] = op_attrs
    if filter_result_type is not None: attributes["filter_result_type"] = filter_result_type
    results.append(results_)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def results_(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MultiTileSizesOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.multitile_sizes"

  _ODS_REGIONS = (0, True)

  def __init__(self, low_size, high_size, split_point, target, dimension, target_size, *, divisor=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    attributes["dimension"] = dimension
    attributes["target_size"] = target_size
    if divisor is not None: attributes["divisor"] = divisor
    results.append(low_size)
    results.append(high_size)
    results.append(split_point)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dimension(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["dimension"])

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def target_size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["target_size"])

  @target_size.setter
  def target_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_size"] = value

  @builtins.property
  def divisor(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["divisor"])

  @divisor.setter
  def divisor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["divisor"] = value

  @builtins.property
  def low_size(self):
    return self.operation.results[0]

  @builtins.property
  def high_size(self):
    return self.operation.results[1]

  @builtins.property
  def split_point(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, padding_values=None, padding_dimensions=None, pack_paddings=None, hoist_paddings=None, transpose_paddings=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if padding_values is not None: attributes["padding_values"] = padding_values
    if padding_dimensions is not None: attributes["padding_dimensions"] = padding_dimensions
    if pack_paddings is not None: attributes["pack_paddings"] = pack_paddings
    if hoist_paddings is not None: attributes["hoist_paddings"] = hoist_paddings
    if transpose_paddings is not None: attributes["transpose_paddings"] = transpose_paddings
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PromoteOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.promote"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, operands_to_promote=None, use_full_tile_buffers=None, use_full_tiles_by_default=None, use_alloca=None, alignment=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if operands_to_promote is not None: attributes["operands_to_promote"] = operands_to_promote
    if use_full_tile_buffers is not None: attributes["use_full_tile_buffers"] = use_full_tile_buffers
    if bool(use_full_tiles_by_default): attributes["use_full_tiles_by_default"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_alloca): attributes["use_alloca"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if alignment is not None: attributes["alignment"] = alignment
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def use_full_tiles_by_default(self):
    return "use_full_tiles_by_default" in self.operation.attributes

  @use_full_tiles_by_default.setter
  def use_full_tiles_by_default(self, value):
    if bool(value):
      self.operation.attributes["use_full_tiles_by_default"] = _ods_ir.UnitAttr.get()
    elif "use_full_tiles_by_default" in self.operation.attributes:
      del self.operation.attributes["use_full_tiles_by_default"]

  @use_full_tiles_by_default.deleter
  def use_full_tiles_by_default(self):
    del self.operation.attributes["use_full_tiles_by_default"]

  @builtins.property
  def use_alloca(self):
    return "use_alloca" in self.operation.attributes

  @use_alloca.setter
  def use_alloca(self, value):
    if bool(value):
      self.operation.attributes["use_alloca"] = _ods_ir.UnitAttr.get()
    elif "use_alloca" in self.operation.attributes:
      del self.operation.attributes["use_alloca"]

  @use_alloca.deleter
  def use_alloca(self):
    del self.operation.attributes["use_alloca"]

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return _ods_ir.IntegerAttr(self.operation.attributes["alignment"])

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReplaceOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.replace"

  _ODS_REGIONS = (1, True)

  def __init__(self, replacement, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    results.append(replacement)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def replacement(self):
    return self.operation.results[0]

  @builtins.property
  def bodyRegion(self):
    return self.regions[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScalarizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.scalarize"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, first, second, target, dimension, static_split_point, *, dynamic_split_point=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if dynamic_split_point is not None: operands.append(_get_op_result_or_value(dynamic_split_point))
    attributes["dimension"] = dimension
    attributes["static_split_point"] = static_split_point
    results.append(first)
    results.append(second)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_split_point(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def dimension(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["dimension"])

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def static_split_point(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["static_split_point"])

  @static_split_point.setter
  def static_split_point(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_split_point"] = value

  @builtins.property
  def first(self):
    return self.operation.results[0]

  @builtins.property
  def second(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitReductionOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.split_reduction"

  _ODS_REGIONS = (0, True)

  def __init__(self, init_or_alloc_op, fill_op, split_linalg_op, combining_linalg_op, target, *, split_factor=None, insert_split_dimension=None, inner_parallel=None, use_scaling_algorithm=None, use_alloc=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if split_factor is not None: attributes["split_factor"] = split_factor
    if insert_split_dimension is not None: attributes["insert_split_dimension"] = insert_split_dimension
    if bool(inner_parallel): attributes["inner_parallel"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_scaling_algorithm): attributes["use_scaling_algorithm"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_alloc): attributes["use_alloc"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(init_or_alloc_op)
    results.append(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def split_factor(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["split_factor"])

  @split_factor.setter
  def split_factor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["split_factor"] = value

  @builtins.property
  def insert_split_dimension(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["insert_split_dimension"])

  @insert_split_dimension.setter
  def insert_split_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["insert_split_dimension"] = value

  @builtins.property
  def inner_parallel(self):
    return "inner_parallel" in self.operation.attributes

  @inner_parallel.setter
  def inner_parallel(self, value):
    if bool(value):
      self.operation.attributes["inner_parallel"] = _ods_ir.UnitAttr.get()
    elif "inner_parallel" in self.operation.attributes:
      del self.operation.attributes["inner_parallel"]

  @inner_parallel.deleter
  def inner_parallel(self):
    del self.operation.attributes["inner_parallel"]

  @builtins.property
  def use_scaling_algorithm(self):
    return "use_scaling_algorithm" in self.operation.attributes

  @use_scaling_algorithm.setter
  def use_scaling_algorithm(self, value):
    if bool(value):
      self.operation.attributes["use_scaling_algorithm"] = _ods_ir.UnitAttr.get()
    elif "use_scaling_algorithm" in self.operation.attributes:
      del self.operation.attributes["use_scaling_algorithm"]

  @use_scaling_algorithm.deleter
  def use_scaling_algorithm(self):
    del self.operation.attributes["use_scaling_algorithm"]

  @builtins.property
  def use_alloc(self):
    return "use_alloc" in self.operation.attributes

  @use_alloc.setter
  def use_alloc(self, value):
    if bool(value):
      self.operation.attributes["use_alloc"] = _ods_ir.UnitAttr.get()
    elif "use_alloc" in self.operation.attributes:
      del self.operation.attributes["use_alloc"]

  @use_alloc.deleter
  def use_alloc(self):
    del self.operation.attributes["use_alloc"]

  @builtins.property
  def init_or_alloc_op(self):
    return self.operation.results[0]

  @builtins.property
  def fill_op(self):
    return self.operation.results[1]

  @builtins.property
  def split_linalg_op(self):
    return self.operation.results[2]

  @builtins.property
  def combining_linalg_op(self):
    return self.operation.results[3]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_linalg_op, loops, target, dynamic_sizes, *, static_sizes=None, interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.extend(_get_op_results_or_values(dynamic_sizes))
    if static_sizes is not None: attributes["static_sizes"] = static_sizes
    if interchange is not None: attributes["interchange"] = interchange
    results.append(tiled_linalg_op)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def tiled_linalg_op(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileReductionUsingForeachThreadOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_reduction_using_foreach_thread"

  _ODS_REGIONS = (0, True)

  def __init__(self, fill_op, split_linalg_op, combining_linalg_op, target, *, num_threads=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if num_threads is not None: attributes["num_threads"] = num_threads
    results.append(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def fill_op(self):
    return self.operation.results[0]

  @builtins.property
  def split_linalg_op(self):
    return self.operation.results[1]

  @builtins.property
  def combining_linalg_op(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileReductionUsingScfOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_reduction_using_scf"

  _ODS_REGIONS = (0, True)

  def __init__(self, fill_op, split_linalg_op, combining_linalg_op, target, *, tile_sizes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if tile_sizes is not None: attributes["tile_sizes"] = tile_sizes
    results.append(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def fill_op(self):
    return self.operation.results[0]

  @builtins.property
  def split_linalg_op(self):
    return self.operation.results[1]

  @builtins.property
  def combining_linalg_op(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileToForeachThreadOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_to_foreach_thread_op"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, foreach_thread_op, tiled_op, target, num_threads, tile_sizes, *, static_num_threads=None, static_tile_sizes=None, mapping=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.append(_get_op_results_or_values(num_threads))
    operands.append(_get_op_results_or_values(tile_sizes))
    if static_num_threads is not None: attributes["static_num_threads"] = static_num_threads
    if static_tile_sizes is not None: attributes["static_tile_sizes"] = static_tile_sizes
    if mapping is not None: attributes["mapping"] = mapping
    results.append(foreach_thread_op)
    results.append(tiled_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operand_segment_sizes"], 0)
    return operand_range[0]

  @builtins.property
  def num_threads(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operand_segment_sizes"], 1)
    return operand_range

  @builtins.property
  def tile_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operand_segment_sizes"], 2)
    return operand_range

  @builtins.property
  def foreach_thread_op(self):
    return self.operation.results[0]

  @builtins.property
  def tiled_op(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileToScfForOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile_to_scf_for"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_linalg_op, loops, target, dynamic_sizes, *, static_sizes=None, interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    operands.extend(_get_op_results_or_values(dynamic_sizes))
    if static_sizes is not None: attributes["static_sizes"] = static_sizes
    if interchange is not None: attributes["interchange"] = interchange
    results.append(tiled_linalg_op)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def tiled_linalg_op(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class VectorizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.vectorize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, vectorize_padding=None, disable_multi_reduction_to_contract_patterns=None, disable_transfer_permutation_map_lowering_patterns=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if bool(vectorize_padding): attributes["vectorize_padding"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(disable_multi_reduction_to_contract_patterns): attributes["disable_multi_reduction_to_contract_patterns"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(disable_transfer_permutation_map_lowering_patterns): attributes["disable_transfer_permutation_map_lowering_patterns"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def vectorize_padding(self):
    return "vectorize_padding" in self.operation.attributes

  @vectorize_padding.setter
  def vectorize_padding(self, value):
    if bool(value):
      self.operation.attributes["vectorize_padding"] = _ods_ir.UnitAttr.get()
    elif "vectorize_padding" in self.operation.attributes:
      del self.operation.attributes["vectorize_padding"]

  @vectorize_padding.deleter
  def vectorize_padding(self):
    del self.operation.attributes["vectorize_padding"]

  @builtins.property
  def disable_multi_reduction_to_contract_patterns(self):
    return "disable_multi_reduction_to_contract_patterns" in self.operation.attributes

  @disable_multi_reduction_to_contract_patterns.setter
  def disable_multi_reduction_to_contract_patterns(self, value):
    if bool(value):
      self.operation.attributes["disable_multi_reduction_to_contract_patterns"] = _ods_ir.UnitAttr.get()
    elif "disable_multi_reduction_to_contract_patterns" in self.operation.attributes:
      del self.operation.attributes["disable_multi_reduction_to_contract_patterns"]

  @disable_multi_reduction_to_contract_patterns.deleter
  def disable_multi_reduction_to_contract_patterns(self):
    del self.operation.attributes["disable_multi_reduction_to_contract_patterns"]

  @builtins.property
  def disable_transfer_permutation_map_lowering_patterns(self):
    return "disable_transfer_permutation_map_lowering_patterns" in self.operation.attributes

  @disable_transfer_permutation_map_lowering_patterns.setter
  def disable_transfer_permutation_map_lowering_patterns(self, value):
    if bool(value):
      self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"] = _ods_ir.UnitAttr.get()
    elif "disable_transfer_permutation_map_lowering_patterns" in self.operation.attributes:
      del self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"]

  @disable_transfer_permutation_map_lowering_patterns.deleter
  def disable_transfer_permutation_map_lowering_patterns(self):
    del self.operation.attributes["disable_transfer_permutation_map_lowering_patterns"]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]
