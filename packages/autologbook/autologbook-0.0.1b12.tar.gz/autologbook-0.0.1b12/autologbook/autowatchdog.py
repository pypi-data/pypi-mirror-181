# -*- coding: utf-8 -*-
#  Copyright (c) 2022.  Antonio Bulgheroni.
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
#  documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
#  permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
#  Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
#  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
#  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
#  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"""
Created on Tue Jun 28 10:33:35 2022

@author: elog-admin
"""
from __future__ import annotations

import logging
import math
import os
import shutil
import time
from datetime import datetime
from pathlib import Path

import PIL
import watchdog.events
import watchdog.observers
from tenacity import after_log, retry, retry_if_not_exception_type, stop_after_attempt, wait_fixed, wait_incrementing

from autologbook import autoconfig, autoerror, autotools
from autologbook.autoprotocol import (
    HTMLObject,
    Protocol,
    QuattroFEIPicture,
    Sample,
    VegaPicture,
    VersaFEIPicture,
    Video,
    XL40Picture,
)

log = logging.getLogger('__main__')


class MirrorEventHandler(watchdog.events.FileSystemEventHandler):
    """
    The mirror event handler class.

    This class has the task to deliver and process file system events occurring in the monitored directory in order to
    mirror its content on the destination path.

    Its constructor takes indeed two paths, the origin path and the destination one where the file system has to be
    mirrored.

    This event handler can be used as standalone for mirroring purposes, or it can be used as a class member in other
    event handlers to extend the capability of such event handler to mirroring.

    """

    def __init__(self, original_path: str | Path, destination_path: str | Path, **kwargs):
        """
        Dunder init method.

        Parameters
        ----------
        original_path: str | Path
            The origin path of the mirroring handler. This folder is corresponding to the directory being monitored
            by the watchdog observer.

        destination_path: str | Path
            The destination directory where the original path must be mirrored.

        kwargs: Any
            Keywords parameters. No other parameters are used, but this generic is here so that the same parameter
            dictionary of the extended handler can be passed.

        """
        super().__init__()

        # original path
        self.original_path = original_path

        # destination path
        self.destination_path = destination_path

        # a copy of the previous event. This is to avoid to dispatch and process duplicated events.
        self.previous_event = None

    def dispatch(self, event):
        """
        Overload the dispatch method.

        This overload if recording the last dispatched event and avoid the dispatchment of the modified event
        just after the creation event.

        TODO: check that in normal operation (image generated by the microscope software) only one modified event
        is generated after the creation. If more than one event is generated, then we need to filter out all of them.

        Parameters
        ----------
        event:
            The file system event to be dispatched.
        """

        if self.previous_event is None:
            super().dispatch(event)
        else:
            old_key = self.previous_event.key
            new_key = event.key
            if old_key[1:] == new_key[1:] and old_key[0] == watchdog.events.EVENT_TYPE_CREATED \
                    and new_key[0] == watchdog.events.EVENT_TYPE_MODIFIED:
                # the two events are one after the other and the second one is just a
                # file modification of the first one.
                # then we don't dispatch the event, but we have to patch the event with the mirror_path.
                log.debug('Modified event not dispacthed!')
                self.patch_event(event)

            else:
                super().dispatch(event)

        self.previous_event = event

    def patch_event(self, event):
        event.mirror_path = self.actual_dest(event.src_path)
        if event.event_type == watchdog.events.EVENT_TYPE_MOVED:
            event.mirror_path_2 = self.actual_dest(event.dest_path)

    def on_any_event(self, event):
        """
        React on every event just before dispatching.

        Add the mirror_path attribute to the event and let the event be further dispatched.

        """
        self.patch_event(event)

    def on_created(self, event: watchdog.events.FileSystemEvent):
        """React to a file or directory creation"""
        log.debug('Mirror event %s, event %s' % (event.event_type, str(event.key)))
        try:
            self.process_on_created(event)
        except OSError as e:
            log.error('Error copying file %s to %s, skipping it.' %
                      (event.src_path, event.mirror_path))
            log.exception(e, exc_info=True)
        except Exception as e:
            log.exception(e, exc_info=True)
            log.error('Error encountered with processing of event %s.' % str(event.key))

    def on_deleted(self, event):
        """React to a file or directory removal"""
        log.debug('mirror event %s, event %s' % (event.event_type, str(event.key)))
        try:
            self.process_on_deleted(event)
        except FileNotFoundError as e:
            log.error('Error removing file %s' % event.mirror_path)
            log.error('Was the file already removed?')
            log.exception(e, exc_info=True)
        except Exception as e:
            log.exception(e, exc_info=True)
            log.error('Error encountered with processing of event %s.' % str(event.key))

    def on_modified(self, event):
        """React to a file modification"""
        if event.event_type != watchdog.events.EVENT_TYPE_MODIFIED and not event.directory:
            log.debug('mirror event %s, event %s' % (event.event_type, str(event.key)))
        try:
            self.process_on_modified(event)
        except OSError as e:
            log.error('Error copying file %s to %s, skipping it.' %
                      (event.src_path, event.mirror_path))
            log.exception(e, exc_info=True)
        except Exception as e:
            log.exception(e, exc_info=True)
            log.error('Error encountered with processing of event %s.' % str(event.key))

    def on_moved(self, event):
        """React to a file or directory move / rename"""
        log.debug('mirror event %s, event %s' % (event.event_type, str(event.key)))
        try:
            self.process_on_moved(event)
        except (PermissionError, FileExistsError) as e:
            log.error('Permission error while renaming %s in %s' %
                      (event.dest_path, event.mirror_path))
            log.exception(e, exc_info=True)
        except FileNotFoundError as e:
            log.error('File %s not found' % event.dest_path)
            log.exception(e, exc_info=True)
        except Exception as e:
            log.exception(e, exc_info=True)
            log.error('Error encountered with processing of event %s.' % str(event.key))

    def get_extra_path(self, actual_path: Path | str) -> Path:
        """
        Calculate the extra path with respect to the root path.

        Parameters
        ----------
        actual_path : path
            The actual path.

        Returns
        -------
        extra_path : path
            The extra path of actual_path relative to the src_path.

        """
        if not isinstance(actual_path, Path):
            actual_path = Path(actual_path)
        try:
            extra_path = actual_path.relative_to(self.original_path)
        except ValueError:
            log.exception(ValueError)
            extra_path = ''
        return extra_path

    def actual_dest(self, actual_src: Path | str) -> Path:
        """
        Calculate the resource destination.

        Parameters
        ----------
        actual_src : path
            Source path of a resource.

        Returns
        -------
        actual_dest : path
            The destination path calculated from the actual_src.

        """
        if not isinstance(actual_src, Path):
            actual_src = Path(actual_src)
        return Path(self.destination_path) / self.get_extra_path(actual_src)

    @retry(reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_MIRRORING_MAX_ATTEMPTS),
           wait=wait_fixed(autoconfig.AUTOLOGBOOK_MIRRORING_WAIT),
           after=after_log(log, logging.WARNING))
    def process_on_created(self, event: watchdog.events.FileSystemEvent):
        """
        Process a creation event.

        If the event is corresponding to a directory, then a directory with the same name and same parents is created
        in the destination folder.

        If the event is correspodning to a file, then it will be passed on to the process_on_modified method.

        This method is decorated with retry, so that in case of problems it will be executed again.

        Parameters
        ----------
        event:
            The file system event being processed.

        """
        if event.is_directory:
            # if it is a directory, make it on the destination
            actual_dest_path = Path(self.actual_dest(event.src_path))
            actual_dest_path.mkdir(parents=True, exist_ok=True)
            log.info('Created directory %s' % event.mirror_path)
        else:
            self.process_on_modified(event)

    @retry(reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_MIRRORING_MAX_ATTEMPTS),
           wait=wait_fixed(autoconfig.AUTOLOGBOOK_MIRRORING_WAIT),
           after=after_log(log, logging.WARNING))
    def process_on_deleted(self, event: watchdog.events):
        """
        Process a deletion event.

        If the event is corresponding to a directory, the corresponding folder in the destination folder is removed
        using the shutil.rmtree with ignore_errors=True.

        If the event is correspodning to a file, the corresponding file in the destination folder is unlinked without
        complaining if it is already not existing.

        This method is decorated with retry, so that in case of problems it will be executed again.

        Parameters
        ----------
        event:
            The file system event to be processed.

        """
        if event.mirror_path.is_file():
            event.mirror_path.unlink(missing_ok=True)
            log.info('Deleted file %s' % event.mirror_path)
        else:
            shutil.rmtree(event.mirror_path, ignore_errors=True)
            log.info('Deleted directory %s' % event.mirror_path)

    @retry(reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_MIRRORING_MAX_ATTEMPTS),
           wait=wait_fixed(autoconfig.AUTOLOGBOOK_MIRRORING_WAIT),
           after=after_log(log, logging.WARNING))
    def process_on_modified(self, event: watchdog.events):
        """
        Process a modification event.

        A modification event is emitted by the observer whenever a file is changed or the content of a directory is
        changed.

        If the case of a directory, this event is actually not processed because there is nothing to do.

        In case of a file, then it copied again to the destination.

        This method is decorated with retry, so that in case of problems it will be executed again.

        Parameters
        ----------
        event:
            The filesystem event to be processed.

        """
        if event.is_directory:
            # this occurs every time a file in a directory is modified
            # do not do anything and simply return
            return
        else:
            # if it is a file, we copy it again
            # be sure that the file is closed
            self.wait_until_file_is_closed(event.src_path)
            # copy it now
            shutil.copy2(event.src_path, event.mirror_path)
            log.info('Mirrored file %s to %s' % (event.src_path, event.mirror_path))

    @retry(reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_MIRRORING_MAX_ATTEMPTS),
           wait=wait_fixed(autoconfig.AUTOLOGBOOK_MIRRORING_WAIT),
           after=after_log(log, logging.WARNING))
    def process_on_moved(self, event):
        """
        Process a moved event.

        A moved event is emitted when the location of a file or directory is changed or when it is renamed.
        In the case of a directory, also all move events corresponding to the contained files will be emitted.

        Every moved event will be treated as a copy event followed by a delete event.

        This method is decorated with retry, so that in case of problems it will be executed again.

        Parameters
        ----------
        event:
            The file system event to be processed.

        """

        original_dest_path = event.dest_path
        actual_dest_path = self.actual_dest(original_dest_path)
        if Path(original_dest_path).is_dir():
            # this case should never happen... but in case
            actual_dest_path.mkdir(parents=True, exist_ok=True)
        else:
            self.wait_until_file_is_closed(event.dest_path)
            if not os.path.exists(actual_dest_path):
                actual_dest_path.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(original_dest_path, actual_dest_path)
                log.info('Mirrored %s to %s' %
                         (str(original_dest_path), str(actual_dest_path)))

        actual_dest_path = self.actual_dest(event.src_path)
        if actual_dest_path.is_file():
            actual_dest_path.unlink(missing_ok=True)
        else:
            shutil.rmtree(actual_dest_path, ignore_errors=True)
        log.info("Removed %s" % actual_dest_path)

    def process_all_existing(self):
        """
        Process all existing files / directories.

        This method is called just before the observer is started so that all already present files/directories are
        processed.

        """
        all_mirrored_files = self.destination_path.glob('**/*')
        log.info('Mirroring all existing items in %s' % self.original_path)
        for file in self.original_path.glob('**/*'):
            actual_dest = self.actual_dest(file)
            if actual_dest not in all_mirrored_files:
                if file.is_dir():
                    actual_dest.mkdir(parents=True, exist_ok=True)
                else:
                    if not actual_dest.exists():
                        actual_dest.parent.mkdir(parents=True, exist_ok=True)
                        shutil.copy2(file, actual_dest)
                        log.info('Mirrored %s to %s' % (str(file), str(actual_dest)))

    @staticmethod
    def wait_until_file_is_closed(file_path: Path):
        """
        Wait until the copy of the file in the event is finished.

        This method is monitoring the size of the newly added file. If it keeps
        on changing it means that is still being copied.

        The size of the file is polled with an adaptive delay. Very fast at the
        beginning and more slowly later on. The maximum polling delay is 1 sec.
        Normally only 1 interaction is necessary for a standard size TIFF file
        corresponding to a delay of 0.06s.

        Parameters
        ----------
        file_path : Path
            This is the file being transferred.

        Returns
        -------
        None.

        """

        old_size = -1
        i = 0.
        while old_size != Path(file_path).stat().st_size:
            old_size = Path(file_path).stat().st_size
            delay = 2 / math.pi * math.atan(i / 6 + 0.1)
            i += 1
            time.sleep(delay)


class ProtocolEventHandler(watchdog.events.RegexMatchingEventHandler):
    """
    The base implementation of the protocol event handler.

    For each microscope a specific subclass of this class is envisaged.

    It includes a mirroring event handler that can be activated.
    When mirroring is requested, every filesystem event will be dispatched to the mirroring handler first and then
    to the protocol handler.

    """

    def __init__(self, autoprotocol_instance, **kwargs):
        self.matching_patterns, self.excluded_patterns = autotools.get_patterns_from_config()

        # set the protocol instance
        self.autoprotocol_instance = autoprotocol_instance

        # set the queue reference
        self.queue = None

        # a copy of the previous event. This is to avoid to dispatch and process duplicated events.
        self.previous_event = None

        # the dictionary of all type guessers
        # it contains pairs of ElementTypeGuessers with their ElementType
        self.type_guessers = {}

        # microscope images
        image_file_matching = autoconfig.IMAGEFILE_MATCHING_PATTERNS
        image_file_exclude = autoconfig.IMAGEFILE_EXCLUDE_PATTERNS
        self.type_guessers[str(autotools.ElementType.MICROSCOPE_PIC)] = \
            (autotools.ElementTypeGuesser(image_file_matching, image_file_exclude),
             autotools.ElementType.MICROSCOPE_PIC)

        # attachments
        attachment_include_pattern = autoconfig.ATTACHMENT_MATCHING_PATTERNS
        attachment_exclude_pattern = autoconfig.ATTACHMENT_EXCLUDE_PATTERNS
        self.type_guessers[str(autotools.ElementType.ATTACHMENT_FILE)] = \
            (autotools.ElementTypeGuesser(attachment_include_pattern, attachment_exclude_pattern),
             autotools.ElementType.ATTACHMENT_FILE)

        # yaml customization file
        yaml_file_include_pattern = autoconfig.YAMLFILE_MATCHING_PATTERNS
        yaml_file_exclude_pattern = autoconfig.YAMLFILE_EXCLUDE_PATTERNS
        self.type_guessers[str(autotools.ElementType.YAML_FILE)] = \
            (autotools.ElementTypeGuesser(yaml_file_include_pattern, yaml_file_exclude_pattern),
             autotools.ElementType.YAML_FILE)

        # videos
        video_file_include_pattern = autoconfig.VIDEO_MATCHING_PATTERNS
        video_file_exclude_pattern = autoconfig.VIDEO_EXCLUDE_PATTERNS
        self.type_guessers[str(autotools.ElementType.VIDEO_FILE)] = \
            (autotools.ElementTypeGuesser(video_file_include_pattern, video_file_exclude_pattern),
             autotools.ElementType.VIDEO_FILE)

        required_arguments = [
            'original_path',  # the path to be monitored
            'destination_path',  # this is where the mirroring component has to copy the files
            'is_mirroring_requested',  # a flag to specify whether the mirroring is required or not
            'microscope',  # this is the microscope type
            'projectID',  # this is the project ID aka protocol number
            'project_name',  # this is the project name
            'responsible'  # this is the project responsible
        ]
        self.params = dict()
        for param in required_arguments:
            if param in kwargs:
                self.params[param] = kwargs[param]
            else:
                log.error('Missing %s. Cannot update worker parameters' % param)
                raise autoerror.MissingWorkerParameter(f'Missing {param}.')

        # this parameter contains a timestamp referring to the time when the
        # elog was updated. we initialize to one hour ago.
        self.last_update = datetime.fromtimestamp(datetime.now().timestamp() - 3600)

        super().__init__(regexes=self.matching_patterns, ignore_directories=True, case_sensitive=False,
                         ignore_regexes=self.excluded_patterns)

        self.mirror_maker = MirrorEventHandler(parent=self, **self.params)

    def process_on_created(self, event):
        """
        Stub of the process on created method. To be overloaded.

        Parameters
        ----------
        event:
            Filesystem event to be processed.
        """
        pass

    def process_on_deleted(self, event):
        """
        Stub of the process on deleted method. To be overloaded.

        Parameters
        ----------
        event:
            Filesystem event to be processed.
        """
        pass

    def process_on_modified(self, event):
        """
        Stub of the process on modified method. To be overloaded.

        Parameters
        ----------
        event:
            Filesystem event to be processed.
        """
        pass

    def process_on_moved(self, event: watchdog.events.DirMovedEvent | watchdog.events.FileMovedEvent):
        """
        Stub of the process on moved method.

        It is like a process_on_created followed by a process_on_deleted.

        Parameters
        ----------
        event:
            Filesystem event to be processed.
        """

        if event.is_directory:
            created_event = watchdog.events.DirCreatedEvent(event.mirror_path_2)
            deleted_event = watchdog.events.DirDeletedEvent(event.mirror_path)
        else:
            created_event = watchdog.events.FileCreatedEvent(event.mirror_path_2)
            deleted_event = watchdog.events.FileDeletedEvent(event.mirror_path)

        # we need to patch the events with the mirror path.
        # In the case of a move event, we have two mirror paths, one for the src and one for the dest path.
        created_event.mirror_path = event.mirror_path_2
        deleted_event.mirror_path = event.mirror_path

        self.process_on_created(created_event)
        self.process_on_deleted(deleted_event)

    def dispatch(self, event: watchdog.events.FileSystemEvent):
        """
        Overload of the dispatch method.

        This overload is calling the Mirroring Event Handler member class to dispatch (and process) the event before
        dispatching it to the Protocol Event Handler if mirroring is requested.

        In case mirroring is not requested, the filesystem event is patched adding the mirror_path attribute in order
        to maintain the compatibility with the mirroring requested case.

        Parameters
        ----------
        event:
            The filesystem event being dispatched.
        """

        if self.params['is_mirroring_requested']:
            self.mirror_maker.dispatch(event)

        else:
            event.mirror_path = event.src_path
            if event.event_type == watchdog.events.EVENT_TYPE_MOVED:
                event.mirror_path_2 = event.dest_path

        # due to a known limitation of watchdog, this cannot tell us if a removed object is a file or directory.
        # it will always generate FileDeletedEvents even if it was a directory. We can actually know it because we can
        # check if such a path is a sample.
        if event.event_type == watchdog.events.EVENT_TYPE_DELETED:
            sample_full_name = str(Path(event.mirror_path).relative_to(self.autoprotocol_instance.path)).replace('\\',
                                                                                                                 '/')
            if sample_full_name in self.autoprotocol_instance.samples:
                # this event is actually manually dispatched because of the limitation above
                self.process_on_removed_sample(event)
                self.previous_event = event
                # return here, because there is nothing else to dispatch
                return

        if self.previous_event is None:
            super().dispatch(event)
        else:
            old_key = self.previous_event.key
            new_key = event.key
            if old_key[1:] == new_key[1:] and old_key[0] == watchdog.events.EVENT_TYPE_CREATED \
                    and new_key[0] == watchdog.events.EVENT_TYPE_MODIFIED:
                # the two events are one after the other and the second one is just a
                # file modification of the first one.
                log.debug('Modified event not dispatched!')
            else:
                super().dispatch(event)

        self.previous_event = event

    def process_on_removed_sample(self, event: watchdog.events.FileSystemEvent, skip_elog_update: bool = False):
        sample_full_name = str(event.mirror_path.relative_to(self.autoprotocol_instance.path)).replace('\\', '/')
        self.autoprotocol_instance.remove_sample(sample_full_name)
        self.check_and_remove_parents(event.mirror_path)
        if not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    def guess_element_type(self, path):
        """
        Guess the type pf element.

        Starting from the full path retrieved from the FS event, all available
        ElementTypeGuessers are checked. As soon as one is returning a valid element
        the corresponding element type is returned.

        Parameters
        ----------
        path : str, Path
            The path of the FS event.

        Returns
        -------
        etype : autotools.ElementType
            The ElementType as guessed by the given path.

        """
        for (guesser, etype) in self.type_guessers.values():
            if guesser.is_ok(path):
                return etype

    @staticmethod
    def wait_until_file_is_closed(event):
        """
        Wait until the copy of the file in the event is finished.

        This method is monitoring the size of the newly added file. If it keeps
        on changing it means that is still being copied.

        The size of the file is polled with an adaptive delay. Very fast at the
        beginning and more slowly later on. The maximum polling delay is 1 sec.
        Normally only 1 interaction is necessary for a standard size TIFF file
        corresponding to a delay of 0.06s.

        Parameters
        ----------
        event : filesystem event
            This is the file system event generated by the file being
            copied.

        Returns
        -------
        None.

        """
        if isinstance(event, watchdog.events.FileCreatedEvent):
            old_size = -1
            i = 0.
            while old_size != Path(event.src_path).stat().st_size:
                old_size = Path(event.src_path).stat().st_size
                delay = 2 / math.pi * math.atan(i / 6 + 0.1)
                i += 1
                time.sleep(delay)

    def get_full_sample_name(self, new_pic_path: str | Path) -> str | None:
        r"""
        Get the sample full name from the picture path.

        For example, if a protocol is based in:
            R:\Results\2022\1234-project-resp\
        and a picture is created with the following path:
            R:\Results\2022\1234-project-resp\Sample1\Sample1.2\Sample1.2.1\image.tif

        then the sample full name will be:
            Sample1/Sample1.2/Sample1.2.1

        Parameters
        ----------
        new_pic_path : str | Path
            The full path of the newly added picture.

        Returns
        -------
        sample_full_name: str | None
            The sample full name or Nane if the object does not belong to a sample

        """
        if not isinstance(new_pic_path, Path):
            new_pic_path = Path(new_pic_path)

        sample_full_name = str(new_pic_path.relative_to(Path(self.params.get('destination_path'))).parent).replace('\\',
                                                                                                                   '/')
        if sample_full_name == '.':
            sample_full_name = None
        return sample_full_name

    def check_and_add_parents(self, new_pic_path):
        """
        Check if the parent samples of the new pictures are all existing.

        From the path of the new pictures, the list of all sample parents is
        calculated and the protocol is checked to verify that they are all there.
        If not, they are added.

        Parameters
        ----------
        new_pic_path : string or path
            The path of the newly added picture.

        Returns
        -------
        None.

        """
        if not isinstance(new_pic_path, Path):
            new_pic_path = Path(new_pic_path)

        # we need to add samples using their full_name
        # the parent lists returns something like:
        #
        #      ['SampleA', 'SampleA/SubSampleB', 'SampleA/SubSampleB/SubSampleC']
        for sample_full_name in autotools.parents_list(new_pic_path, self.autoprotocol_instance.path):
            if sample_full_name not in self.autoprotocol_instance.samples and sample_full_name != '.':
                self.autoprotocol_instance.add_sample(Sample(sample_full_name))

    def check_and_remove_parents(self, removed_pic_path):
        """
        Check if the parents are not needed anymore and remove them.

        From the path of the newly removed picture check if the parents samples
        are still needed. If they are emtpy, they are removed.

        Parameters
        ----------
        removed_pic_path : string or path
            The path of the newly removed picture.

        Returns
        -------
        None.

        """
        if not isinstance(removed_pic_path, Path):
            removed_pic_path = Path(removed_pic_path)

        # we need to remove samples using their full_name
        # the parent lists returns something like:
        #
        #      ['SampleA', 'SampleA/SubSampleB', 'SampleA/SubSampleB/SubSampleC']
        for sample_full_name in reversed(autotools.parents_list(removed_pic_path,
                                                                self.params.get('destination_path'))):
            if self.autoprotocol_instance.samples[sample_full_name].is_empty():
                log.debug('Sample %s is empty. Remove it' % sample_full_name)
                self.autoprotocol_instance.remove_sample(sample_full_name)
            else:
                log.debug('Sample %s is not empty. Leave it' %
                          sample_full_name)
                break

    def on_created(self, event):
        """
        Handle an on_created event.

        Parameters
        ----------
        event : watchdog.event

        Returns
        -------
        None.

        """
        try:
            self.process_on_created(event)
        except FileNotFoundError as e:
            log.debug(e, exc_info=True)
            log.error('File %s not found. Was it already deleted? Skipping it.' % event.mirror_path)
        except PIL.UnidentifiedImageError as e:
            log.debug(e, exc_info=True)
            log.error('Impossible to open image %s. Skipping it.' % event.mirror_path)
        except Exception as e:
            log.exception(e, exc_info=True)
            log.error('Error encountered with processing of event %s.' % str(event.key))

    def on_deleted(self, event):
        """
        Handle an on_delete event.

        It calls the remove_resource function.

        Parameters
        ----------
        event : watchdog.events

        Returns
        -------
        None.

        """
        try:
            self.process_on_deleted(event)
        except Exception as e:
            log.error('Error removing file %s, skipping it.' % event.mirror_path)
            log.exception(e, exc_info=True)
        except Exception as e:
            log.exception(e, exc_info=True)
            log.error('Error encountered with processing of event %s.' % str(event.key))

    def on_modified(self, event):
        try:
            self.process_on_modified(event)
        except FileNotFoundError as e:
            log.error(
                'File %s not found. Was it already deleted? Skipping it.' % event.mirror_path)
            log.debug(e, exc_info=True)
        except Exception as e:
            log.exception(e, exc_info=True)
            log.error('Error encountered with processing of event %s.' % str(event.key))

    def on_moved(self, event):
        """
        Handle an on_moved event.

        It calls the move_resource function.

        Parameters
        ----------
        event : watchdog.events

        Returns
        -------
        None.

        """
        try:
            self.process_on_moved(event)
        except Exception as e:
            log.error('Error moving %s to %s, skipping it.' % (event.src_path, event.dest_path))
            log.debug(e, exc_info=True)
        except Exception as e:
            log.exception(e, exc_info=True)
            log.error('Error encountered with processing of event %s.' % str(event.key))

    def set_queue_reference(self, queue):
        """
        Set the reference of the Observer queue.

        It is intended to offer the possibility to the user of performing some
        tasks depending on the amount of events in the queue waiting to be
        processed.

        Parameters
        ----------
        queue : Queue
            The event queue of the observer.

        Returns
        -------
        None.

        """
        self.queue = queue

    def update_logbook(self, skip_attachments=True):
        """
        Update the logbook entry.

        Generate the HTML code of the whole protocol and post it to the
        server.

        The positing will actually take place if the observer queue is 'almost empty' and if the last update was not
        too recent.

        Almost empty means that the size is below 2. In fact every time a creation event is generated there is at least
        one modified event for the file and also one for the directory coming along.

        Parameters
        ----------
        skip_attachments : bool, optional
            Allows to skip the attachments in order to reduce the network_path trafic.
            The default is True.

        """
        c = self.queue.qsize() < 2
        d = datetime.now().timestamp() - self.last_update.timestamp() > autoconfig.AUTOLOGBOOK_WATCHDOG_MIN_DELAY
        if c and d:

            HTMLObject.reset_html_content()
            self.autoprotocol_instance.generate_html()
            self.autoprotocol_instance.post_elog_message(skip_attachments)
            self.last_update = datetime.now()

        else:
            if not c and not d:
                why = 'Not empty queue and too recent update'
            else:
                if not c:
                    why = 'Not empty queue'
                if not d:
                    why = 'Too recent update'
            log.info('Skipping ELOG updates (%s)' % why)

    def process_already_existing_items(self):
        """
        Process all existing items.

        This function is processing all existing items found in the protocol
        folder when the watchdog is started.

        Returns
        -------
        None.

        """

        if self.params['is_mirroring_requested']:
            self.mirror_maker.process_all_existing()

        log.info('Processing existing files in folder %s' % self.autoprotocol_instance.path)

        for filename in sorted(autotools.reglob(path=os.path.join(self.autoprotocol_instance.path),
                                                matching_regexes=self.matching_patterns,
                                                ignore_regexes=self.excluded_patterns,
                                                recursive=True)):
            log.debug('Preprocess file %s' % filename)
            event = watchdog.events.FileCreatedEvent(os.path.join(filename))
            event.mirror_path = os.path.join(filename)
            # we are using the process_on_created even if
            # the files are already existing.
            self.process_on_created(event, skip_elog_update=True)
        self.update_logbook(skip_attachments=True)


class VersaELOGProtocolEventHandler(ProtocolEventHandler):
    """
    The VersaELOGProtocolEventHandler.

    This is a subclass of the general ProtocolEventHandler customized for the
    Versa microscope.

    """

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_created(self, event, skip_elog_update=False):
        """
        Process the creation of a new element.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.event

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """
        # be sure that the copy is finished.
        self.wait_until_file_is_closed(event)

        # guess the element type
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        # first we need to know what has been added
        if etype == autotools.ElementType.ATTACHMENT_FILE:
            self.autoprotocol_instance.add_attachment(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.YAML_FILE:
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we have a new image and we need to check if its sample and samples
            # parents already exists
            self.check_and_add_parents(event.mirror_path)

            # we know that sample_name already exists because it is checked
            # in the check_and_add_parents
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                logbook_changed = True
                try:
                    self.autoprotocol_instance.samples[sample_full_name].add_microscope_picture(
                        VersaFEIPicture(event.mirror_path))
                except PIL.UnidentifiedImageError as e:
                    log.error('Cannot identify image %s ' % str(event.mirror_path))
                    log.exception(e, exc_info=True)
                    # if mirroring is required, then try to recopy it
                    if self.params['is_mirroring_requested']:
                        # just dispatch once again the event
                        log.error('Trying to recopy the file from original folder')
                        self.mirror_maker.dispatch(event)
                    raise e  # this will force the tenacity decorator to repeat the whole method.

            else:
                # if we get here, it is because the user saved a tif file in the protocol
                # base folder and we don't know what to do with this. Just ignore it.
                log.debug('Found a TIFF file in the protocol base folder. Doing nothing')

        elif etype == autotools.ElementType.VIDEO_FILE:
            # it works as for images
            self.check_and_add_parents(event.mirror_path)
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                logbook_changed = True
                self.autoprotocol_instance.samples[sample_full_name].add_video(Video(event.mirror_path))
            else:
                log.debug('Found a video file in the protocol base folder. Doing nothing')

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_deleted(self, event, skip_elog_update=False):
        """
        Process the deletion of a resource.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.events

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        # first we need to know what has been added
        if etype == autotools.ElementType.ATTACHMENT_FILE:
            self.autoprotocol_instance.remove_attachment(event.mirror_path)
            self.autoprotocol_instance.remove_from_yaml(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we got an imaged removed.
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                # the tif image is in a sample folder

                # first we remove the yaml section if existing.
                # the picture id is used as a key for that dictionary.
                pic_id = self.autoprotocol_instance.samples[sample_full_name].images[str(event.mirror_path)].getID()
                self.autoprotocol_instance.remove_from_yaml(pic_id)

                # now remove the picture from the sample
                self.autoprotocol_instance.samples[sample_full_name].remove_microscope_picture_path(event.mirror_path)
                logbook_changed = True
                log.debug('Removing image (%s) from an existing sample (%s)' % (event.src_path, sample_full_name))
                self.check_and_remove_parents(event.mirror_path)

            else:
                # the tif image is in the protocol folder.
                # we just ignore it.
                log.debug('Found a TIFF file in the protocol base folder. Doing nothing')

        elif etype == autotools.ElementType.VIDEO_FILE:
            # we got a video removed.

            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                # the video is in a sample folder

                # first we remove the yaml section if existing.
                # the video path is used as a key for that dictionary.
                self.autoprotocol_instance.remove_from_yaml(event.src_path)

                # now remove the picture from the sample
                self.autoprotocol_instance.samples[sample_full_name].remove_video(event.mirror_path)
                logbook_changed = True
                log.debug('Removing video (%s) from an existing sample (%s)' % (event.mirror_path, sample_full_name))
                self.check_and_remove_parents(event.mirror_path)

            else:
                # the video is in the protocol folder.
                # we just ignore it.
                log.debug('Found a video file in the protocol base folder. Doing nothing')

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_modified(self, event, skip_elog_update=False):
        """
        Process the modification of a resource.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.events

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """
        # be sure that the file is closed.
        self.wait_until_file_is_closed(event)

        # guess the element type
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        if etype == autotools.ElementType.YAML_FILE:
            # there is a new yaml file.
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        if etype == autotools.ElementType.VIDEO_FILE:
            # we got modifications to a video.
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            self.autoprotocol_instance.samples[sample_full_name].videos[str(event.mirror_path)].update()
            logbook_changed = True

        if etype == autotools.ElementType.ATTACHMENT_FILE:
            # we got modifications to an attachment file.
            self.autoprotocol_instance.attachments[str(event.mirror_path)].update()
            logbook_changed = True

        if etype == autotools.ElementType.MICROSCOPE_PIC:
            # we got modifications to a microscope picture
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            self.autoprotocol_instance.samples[sample_full_name].images[str(event.mirror_path)].update()
            logbook_changed = True

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)


class QuattroELOGProtocolEventHandler(ProtocolEventHandler):
    """
    The QuattroELOGProtocolEventHandler.

    This is a subclass of the general ProtocolEventHandler including customized behavior specific for the Quattro
    Microscope.
    """

    def __init__(self, autoprotocol_instance: Protocol, **kwargs):
        super().__init__(autoprotocol_instance, **kwargs)

        # take the matching and exclude get_patterns from the autoconfig.
        navigation_include_pattern = autoconfig.NAVIGATION_MATCHING_PATTERNS
        navigation_exclude_pattern = autoconfig.NAVIGATION_EXCLUDE_PATTERNS
        self.type_guessers[str(autotools.ElementType.NAVIGATION_PIC)] = \
            (autotools.ElementTypeGuesser(navigation_include_pattern, navigation_exclude_pattern),
             autotools.ElementType.NAVIGATION_PIC)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_created(self, event, skip_elog_update=False):
        """
        Process the creation of a new element.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.event

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """

        # be sure that the copy is finished.
        self.wait_until_file_is_closed(event)

        # guess the element type
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        # first we need to know what has been added
        if etype == autotools.ElementType.NAVIGATION_PIC:
            self.autoprotocol_instance.add_navigation_camera_image(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.ATTACHMENT_FILE:
            self.autoprotocol_instance.add_attachment(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.YAML_FILE:
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we have a new image and we need to check if its sample and samples
            # parents already exists
            self.check_and_add_parents(event.mirror_path)

            # we know that sample_name already exists because it is checked
            # in the check_and_add_parents
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                logbook_changed = True
                try:
                    self.autoprotocol_instance.samples[sample_full_name].add_microscope_picture(
                        QuattroFEIPicture(str(event.mirror_path)))
                except PIL.UnidentifiedImageError as e:
                    log.error('Cannot identify image %s ' % str(event.mirror_path))
                    log.exception(e, exc_info=True)
                    # if mirroring is required, then try to recopy it
                    if self.params['is_mirroring_requested']:
                        # just dispatch once again the event
                        log.error('Trying to recopy the file from original folder')
                        self.mirror_maker.dispatch(event)
                    raise e  # this will force the tenacity decorator to repeat the whole method.
            else:
                # if we get here, it is because the user saved a tif file in the protocol
                # base folder and we don't know what to do with this. Just ignore it.
                log.debug('Found a TIFF file in the protocol base folder. Doing nothing')

        elif etype == autotools.ElementType.VIDEO_FILE:
            # it works as for images
            self.check_and_add_parents(event.mirror_path)
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                logbook_changed = True
                self.autoprotocol_instance.samples[sample_full_name].add_video(Video(event.mirror_path))
            else:
                log.debug('Found a video file in the protocol base folder. Doing nothing')

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_deleted(self, event, skip_elog_update=False):
        """
        Process the deletion of a resource.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.events

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """

        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        # first we need to know what has been deleted
        if etype == autotools.ElementType.NAVIGATION_PIC:
            self.autoprotocol_instance.remove_navigation_camera_image(event.mirror_path)
            self.autoprotocol_instance.remove_from_yaml(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.ATTACHMENT_FILE:
            self.autoprotocol_instance.remove_attachment(event.mirror_path)
            self.autoprotocol_instance.remove_from_yaml(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.YAML_FILE:
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we got an image removed.
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                # the tif image is in a sample folder

                # first we remove the yaml section if existing.
                # the picture id is used as a key for that dictionary.
                pic_id = self.autoprotocol_instance.samples[sample_full_name].images[str(event.mirror_path)].getID()
                self.autoprotocol_instance.remove_from_yaml(pic_id)

                # now remove the picture from the sample
                self.autoprotocol_instance.samples[sample_full_name].remove_microscope_picture_path(event.mirror_path)
                logbook_changed = True
                log.debug('Removing image (%s) from an existing sample (%s)' % (event.mirror_path, sample_full_name))
                self.check_and_remove_parents(event.mirror_path)

            else:
                # the tif image is in the protocol folder.
                # we just ignore it.
                log.debug('Found a TIFF file in the protocol base folder. Doing nothing')

        elif etype == autotools.ElementType.VIDEO_FILE:
            # we got a video removed.

            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                # the video is in a sample folder

                # first we remove the yaml section if existing.
                # the video path is used as a key for that dictionary.
                self.autoprotocol_instance.remove_from_yaml(event.mirror_path)

                # now remove the picture from the sample
                self.autoprotocol_instance.samples[sample_full_name].remove_video(event.mirror_path)
                logbook_changed = True
                log.debug('Removing video (%s) from an existing sample (%s)' % (event.mirror_path, sample_full_name))
                self.check_and_remove_parents(event.mirror_path)

            else:
                # the video is in the protocol folder.
                # we just ignore it.
                log.debug('Found a video file in the protocol base folder. Doing nothing')

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_modified(self, event, skip_elog_update=False):
        """
        Process the modification of a resource.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.events

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """
        # be sure that the file is closed.
        self.wait_until_file_is_closed(event)

        # guess the element type
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        if etype == autotools.ElementType.YAML_FILE:
            # there is a change in the yaml file.
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        if etype == autotools.ElementType.VIDEO_FILE:
            # we got modifications to a video.
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            self.autoprotocol_instance.samples[sample_full_name].videos[str(event.mirror_path)].update()
            logbook_changed = True

        if etype == autotools.ElementType.ATTACHMENT_FILE:
            # we got modifications to an attachment file.
            self.autoprotocol_instance.attachments[str(event.mirror_path)].update()
            logbook_changed = True

        if etype == autotools.ElementType.MICROSCOPE_PIC:
            # we got modifications to a microscope picture
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            self.autoprotocol_instance.samples[sample_full_name].images[str(event.mirror_path)].update()
            logbook_changed = True

        if etype == autotools.ElementType.NAVIGATION_PIC:
            # we got modifications to a navigation picture
            # since the only thing that we store for a navigation image is its path and this is not changed
            # we have nothing to update
            pass

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)


class VegaELOGProtocolEventHandler(ProtocolEventHandler):
    """
    The VegaELOGProtocolEventHandler.

    This is a subclass of the general ProtocolEventHandler customized for the
    Vega microscope.

    Among the specificities of this microscope, there is the fact the metadata are coming in a separate textual file
    that need to be parsed.

    """

    @staticmethod
    def get_picture_key_from_header_file(hdr_file_path: str | Path) -> str:
        r"""
        Return the picture key given an header filename.

        For example if hdr_file_path = C:\path\mypic-012-tif.hdr, this function will return:
        c:\path\mypic-012.tif

        Parameters
        ----------
        hdr_file_path: str | Path
            The header file full path

        Returns
        -------
        The microscope picture key.
        """
        if not isinstance(hdr_file_path, Path):
            hdr_file_path = Path(hdr_file_path)

        folder = hdr_file_path.parent
        hdr_stem = hdr_file_path.stem
        picture_filename = hdr_stem[::-1].replace('-'[::-1], '.'[::-1], 1)[::-1]
        return str(Path(folder) / Path(picture_filename))

    def __init__(self, autoprotocol_instance: Protocol, **kwargs):
        """As the super method, adding the type guesser for the header file"""
        super().__init__(autoprotocol_instance, **kwargs)

        # take the matching and exclude get_patterns from the autoconfig.
        headerfile_include_pattern = autoconfig.HEADERFILE_MATCHING_PATTERNS
        headerfile_exclude_pattern = autoconfig.HEADERFILE_EXCLUDE_PATTERNS
        self.type_guessers[str(autotools.ElementType.HEADER_FILE)] = \
            (autotools.ElementTypeGuesser(headerfile_include_pattern, headerfile_exclude_pattern),
             autotools.ElementType.HEADER_FILE)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_created(self, event, skip_elog_update=False):
        """
        Process the creation of a new element.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.event

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """

        # be sure that the copy is finished.
        self.wait_until_file_is_closed(event)

        # guess the element type
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        # first we need to know what has been added
        if etype == autotools.ElementType.HEADER_FILE:
            picture_key = self.get_picture_key_from_header_file(event.mirror_path)
            sample_full_name = self.get_full_sample_name(picture_key)
            if sample_full_name:
                # the image is in a sample folder
                # does the sample exists already?
                if sample_full_name in self.autoprotocol_instance.samples.keys():
                    # yes!
                    # and is the picture existing?
                    if picture_key in self.autoprotocol_instance.samples[sample_full_name].images.keys():
                        # yes!
                        # then force an update of the picture
                        self.autoprotocol_instance.samples[sample_full_name].images[picture_key].update()
                        logbook_changed = True
            # in all other cases, the image corresponding to the header file was not found. then just let it go

        elif etype == autotools.ElementType.ATTACHMENT_FILE:
            self.autoprotocol_instance.add_attachment(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.YAML_FILE:
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we have a new image, and we need to check if its sample and samples
            # parents already exists
            self.check_and_add_parents(event.mirror_path)

            # we know that sample_name already exists because it is checked
            # in the check_and_add_parents
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                logbook_changed = True
                try:
                    self.autoprotocol_instance.samples[sample_full_name].add_microscope_picture(
                        VegaPicture(str(event.mirror_path)))
                except PIL.UnidentifiedImageError as e:
                    log.error('Cannot identify image %s ' % str(event.mirror_path))
                    log.exception(e, exc_info=True)
                    # if mirroring is required, then try to recopy it
                    if self.params['is_mirroring_requested']:
                        # just dispatch once again the event
                        log.error('Trying to recopy the file from original folder')
                        self.mirror_maker.dispatch(event)
                    raise e  # this will force the tenacity decorator to repeat the whole method.
            else:
                # if we get here, it is because the user saved a tif file in the protocol
                # base folder and we don't know what to do with this. Just ignore it.
                log.debug('Found a TIFF file in the protocol base folder. Doing nothing')

        elif etype == autotools.ElementType.VIDEO_FILE:
            # it works as for images
            self.check_and_add_parents(event.mirror_path)
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                logbook_changed = True
                self.autoprotocol_instance.samples[sample_full_name].add_video(Video(event.mirror_path))
            else:
                log.debug('Found a video file in the protocol base folder. Doing nothing')

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_deleted(self, event, skip_elog_update=False):
        """
        Process the deletion of a resource.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.events

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """

        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        # first we need to know what has been deleted
        if etype == autotools.ElementType.HEADER_FILE:
            # do nothing.
            pass

        elif etype == autotools.ElementType.ATTACHMENT_FILE:
            self.autoprotocol_instance.remove_attachment(event.mirror_path)
            self.autoprotocol_instance.remove_from_yaml(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.YAML_FILE:
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we got an image removed.
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                # the tif image is in a sample folder

                # first we remove the yaml section if existing.
                # the picture id is used as a key for that dictionary.
                pic_id = self.autoprotocol_instance.samples[sample_full_name].images[str(event.mirror_path)].getID()
                self.autoprotocol_instance.remove_from_yaml(pic_id)

                # now remove the picture from the sample
                self.autoprotocol_instance.samples[sample_full_name].remove_microscope_picture_path(event.mirror_path)
                logbook_changed = True
                log.debug('Removing image (%s) from an existing sample (%s)' % (event.mirror_path, sample_full_name))
                self.check_and_remove_parents(event.mirror_path)

            else:
                # the tif image is in the protocol folder.
                # we just ignore it.
                log.debug('Found a TIFF file in the protocol base folder. Doing nothing')

        elif etype == autotools.ElementType.VIDEO_FILE:
            # we got a video removed.

            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                # the video is in a sample folder

                # first we remove the yaml section if existing.
                # the video path is used as a key for that dictionary.
                self.autoprotocol_instance.remove_from_yaml(event.mirror_path)

                # now remove the picture from the sample
                self.autoprotocol_instance.samples[sample_full_name].remove_video(event.mirror_path)
                logbook_changed = True
                log.debug('Removing video (%s) from an existing sample (%s)' % (event.mirror_path, sample_full_name))
                self.check_and_remove_parents(event.mirror_path)

            else:
                # the video is in the protocol folder.
                # we just ignore it.
                log.debug('Found a video file in the protocol base folder. Doing nothing')

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_modified(self, event, skip_elog_update=False):
        """
        Process the modification of a resource.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.events

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """
        # be sure that the file is closed.
        self.wait_until_file_is_closed(event)

        # guess the element type
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        if etype == autotools.ElementType.YAML_FILE:
            # there is a change in the yaml file.
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        if etype == autotools.ElementType.VIDEO_FILE:
            # we got modifications to a video.
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            self.autoprotocol_instance.samples[sample_full_name].videos[str(event.mirror_path)].update()
            logbook_changed = True

        if etype == autotools.ElementType.ATTACHMENT_FILE:
            # we got modifications to an attachment file.
            self.autoprotocol_instance.attachments[str(event.mirror_path)].update()
            logbook_changed = True

        if etype == autotools.ElementType.MICROSCOPE_PIC:
            # we got modifications to a microscope picture
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            self.autoprotocol_instance.samples[sample_full_name].images[str(event.mirror_path)].update()
            logbook_changed = True

        if etype == autotools.ElementType.HEADER_FILE:
            picture_key = self.get_picture_key_from_header_file(event.mirror_path)
            sample_full_name = self.get_full_sample_name(picture_key)
            if sample_full_name:
                # the image is in a sample folder
                # does the sample exists already?
                if sample_full_name in self.autoprotocol_instance.samples.keys():
                    # yes!
                    # and is the picture existing?
                    if picture_key in self.autoprotocol_instance.samples[sample_full_name].images.keys():
                        # yes!
                        # then force an update of the picture
                        self.autoprotocol_instance.samples[sample_full_name].images[picture_key].update()
                        logbook_changed = True
            # in all other cases, the image corresponding to the header file was not found. then just let it go

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)


class XL40ELOGProtocolEventHandler(ProtocolEventHandler):
    """
    The XL40ELOGProtocolEventHandler.

    This is a subclass of the general ProtocolEventHandler customized for the
    XL40 microscope.
    """

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_created(self, event, skip_elog_update=False):
        """
        Process the creation of a new element.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.event

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """

        # be sure that the copy is finished.
        self.wait_until_file_is_closed(event)

        # guess the element type
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        # first we need to know what has been added
        if etype == autotools.ElementType.ATTACHMENT_FILE:
            self.autoprotocol_instance.add_attachment(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.YAML_FILE:
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we have a new image, and we need to check if its sample and samples
            # parents already exists
            self.check_and_add_parents(event.mirror_path)

            # we know that sample_name already exists because it is checked
            # in the check_and_add_parents
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                logbook_changed = True
                try:
                    self.autoprotocol_instance.samples[sample_full_name].add_microscope_picture(
                        XL40Picture(str(event.mirror_path)))
                except PIL.UnidentifiedImageError as e:
                    log.error('Cannot identify image %s ' % str(event.mirror_path))
                    log.exception(e, exc_info=True)
                    # if mirroring is required, then try to recopy it
                    if self.params['is_mirroring_requested']:
                        # just dispatch once again the event
                        log.error('Trying to recopy the file from original folder')
                        self.mirror_maker.dispatch(event)
                    raise e  # this will force the tenacity decorator to repeat the whole method.
            else:
                # if we get here, it is because the user saved a tif file in the protocol
                # base folder and we don't know what to do with this. Just ignore it.
                log.debug('Found a TIFF file in the protocol base folder. Doing nothing')

        elif etype == autotools.ElementType.VIDEO_FILE:
            # it works as for images
            self.check_and_add_parents(event.mirror_path)
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                logbook_changed = True
                self.autoprotocol_instance.samples[sample_full_name].add_video(Video(event.mirror_path))
            else:
                log.debug('Found a video file in the protocol base folder. Doing nothing')

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_deleted(self, event, skip_elog_update=False):
        """
        Process the deletion of a resource.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.events

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """

        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        # first we need to know what has been deleted

        if etype == autotools.ElementType.ATTACHMENT_FILE:
            self.autoprotocol_instance.remove_attachment(event.mirror_path)
            self.autoprotocol_instance.remove_from_yaml(event.mirror_path)
            logbook_changed = True

        elif etype == autotools.ElementType.YAML_FILE:
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we got an image removed.
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                # the tif image is in a sample folder

                # first we remove the yaml section if existing.
                # the picture id is used as a key for that dictionary.
                pic_id = self.autoprotocol_instance.samples[sample_full_name].images[str(event.mirror_path)].getID()
                self.autoprotocol_instance.remove_from_yaml(pic_id)

                # now remove the picture from the sample
                self.autoprotocol_instance.samples[sample_full_name].remove_microscope_picture_path(event.mirror_path)
                logbook_changed = True
                log.debug('Removing image (%s) from an existing sample (%s)' % (event.mirror_path, sample_full_name))
                self.check_and_remove_parents(event.mirror_path)

            else:
                # the tif image is in the protocol folder.
                # we just ignore it.
                log.debug('Found a TIFF file in the protocol base folder. Doing nothing')

        elif etype == autotools.ElementType.VIDEO_FILE:
            # we got a video removed.

            sample_full_name = self.get_full_sample_name(event.mirror_path)
            if sample_full_name:
                # the video is in a sample folder

                # first we remove the yaml section if existing.
                # the video path is used as a key for that dictionary.
                self.autoprotocol_instance.remove_from_yaml(event.mirror_path)

                # now remove the picture from the sample
                self.autoprotocol_instance.samples[sample_full_name].remove_video(event.mirror_path)
                logbook_changed = True
                log.debug('Removing video (%s) from an existing sample (%s)' % (event.mirror_path, sample_full_name))
                self.check_and_remove_parents(event.mirror_path)

            else:
                # the video is in the protocol folder.
                # we just ignore it.
                log.debug('Found a video file in the protocol base folder. Doing nothing')

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)

    @retry(retry=retry_if_not_exception_type(autoerror.ReadOnlyEntry),
           reraise=True, stop=stop_after_attempt(autoconfig.AUTOLOGBOOK_WATCHDOG_MAX_ATTEMPTS),
           wait=wait_incrementing(autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_INCREMENT,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MIN,
                                  autoconfig.AUTOLOGBOOK_WATCHDOG_WAIT_MAX),
           after=after_log(log, logging.WARNING))
    def process_on_modified(self, event, skip_elog_update=False):
        """
        Process the modification of a resource.

        This function is decorated with retry to improve the application stability.

        Parameters
        ----------
        event : watchdog.events

        skip_elog_update : bool, optional
            Allows to skip the posting of HTML code.
            The default is False.

        Returns
        -------
        None.

        """
        # be sure that the file is closed.
        self.wait_until_file_is_closed(event)

        # guess the element type
        etype = self.guess_element_type(event.mirror_path)

        logbook_changed = False
        if etype == autotools.ElementType.YAML_FILE:
            # there is a change in the yaml file.
            self.autoprotocol_instance.initialize_yaml(self.autoprotocol_instance.yamlFilename)
            logbook_changed = True

        elif etype == autotools.ElementType.VIDEO_FILE:
            # we got modifications to a video.
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            self.autoprotocol_instance.samples[sample_full_name].videos[str(event.mirror_path)].update()
            logbook_changed = True

        elif etype == autotools.ElementType.ATTACHMENT_FILE:
            # we got modifications to an attachment file.
            self.autoprotocol_instance.attachments[str(event.mirror_path)].update()
            logbook_changed = True

        elif etype == autotools.ElementType.MICROSCOPE_PIC:
            # we got modifications to a microscope picture
            sample_full_name = self.get_full_sample_name(event.mirror_path)
            self.autoprotocol_instance.samples[sample_full_name].images[str(event.mirror_path)].update()
            logbook_changed = True

        # it is the moment to update the elog. This will be done based only if there is something new in the logbook
        # and if the user didn't explicitly ask for skipping updates.
        #
        if logbook_changed and not skip_elog_update:
            self.update_logbook(skip_attachments=True)
